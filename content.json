{"pages":[],"posts":[{"title":"常用设计模式","text":"单例设计模式单例设计模式一种对象创建模式，用于产生一个对象的具体实例，它可以确保系统中一个类只产生一个实例，其优势主要有以下两点： 可以节省new操作的时间花费 由于减少了new操作的频率，因此降低了内存使用频率，从而减轻了垃圾回收器的压力 1234567891011public class Singleton { //将构造函数设置为private，如果不是private，则instance安全性无法保障 private Singleton(){ System.out.println(\"Singleton is created\"); } private static Singleton instance = new Singleton(); public static Singleton getInstance(){ return instance; }} 上述方法有个问题就是在Singleton构造函数中，Singleton实例的创建是不受控制的，对于静态成员instance，它会在类第一次初始化的时候被创建。这个时刻并不一定是getInstance()方法第一次被调用的时候。要解决上述问题，就需要利用一种延迟加载策略，它只会在instance第一次使用时创建对象。 123456789101112public class LazySingleton(){ private LazySingleton(){ System.out.println(\"LazySingleton is created\"); } private static LazySingleton instance = null; public static synchronized LazySingleton getInstance(){ if (instance == null){ instance = new LazySingleton(); } return instance; }} 还有一种方式结合了上述两种方式的优势，既可以去掉锁使得性能提升，又只会在getInstance()方法第一次调用的时候创建实例。 12345678910111213pulibc class StaticSingleton{ private StaticSingleton(){ System.out.println(\"StaticSingleton is created\"); } private static class SingletonHolder{ private static StaticSingleton instance = new StaticSingleton(); } public static StaticSingleton getInstance(){ return SingletonHolder.instance; }} 常见的懒汉式（线程安全与不安全）、饿汉式和静态内部类的写法 懒汉式（线程不安全） 1234567891011121314public class Singleton { private static Singleton singleton; private Singleton() { } public static Singleton getInstance() { if (singleton == null) { singleton = new Singleton(); } return singleton; }} 懒汉式（线程安全） 12345678910public class Singleton { private static Singleton instance; private Singleton (){} public static synchronized Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; }} 饿汉式 1234567public class Singleton { private static Singleton instance = new Singleton(); private Singleton (){} public static Singleton getInstance() { return instance; }} 静态内部类 123456789public class Singleton { private static class SingletonHolder { private static final Singleton INSTANCE = new Singleton(); } private Singleton (){} public static final Singleton getInstance() { return SingletonHolder.INSTANCE; }} 不变模式在并发编程过程中，需要进行同步操作保证数据的一致性，但是使用同步操作又会降低性能，不变模式利用对象的不变性，可以在没有同步操作的情况下依然保证数据的一致性和正确性。不变模式主要有以下两个特点： 当对象被创建后，其内部状态和数据不再发生任何变化 对象需要被共享，被多线程频繁访问 123456789101112131415161718192021222324public final class Product { private final String no; private final String name; private final double price; public Product(String no, String name, double price) { super(); this.no = no; this.name = name; this.price = price; } public String getNo() { return no; } public String getName() { return name; } public double getPrice() { return price; }} 生产者-消费者模式在生产者-消费者模式中，通常有两类线程，即若干个生产者线程和若干个消费者线程。生产者线程负责提交用户请求，消费者线程则负责具体处理生产者提交的任务。生产者和消费者之间则通过共享内存缓冲区进行通信。 生产者： 12345678910111213141516171819202122232425262728293031323334public class Producer implements Runnable { private volatile boolean isRunning = true; private BlockingQueue&lt;PCData&gt; queue; private static AtomicInteger count = new AtomicInteger(); private static final int SLEEPTIME = 1000; public Producer(BlockingQueue&lt;PCData&gt; queue) { this.queue = queue; } @Override public void run() { PCData data = null; Random r = new Random(); System.out.println(\"start producer id = \" + Thread.currentThread().getId()); try { while (isRunning) { Thread.sleep(r.nextInt(SLEEPTIME)); data = new PCData(count.incrementAndGet()); System.out.println(data + \" is put into queue\"); if (!queue.offer(data, 2, TimeUnit.SECONDS)) { System.out.println(\"failed to put data: \" + data); } } } catch (InterruptedException e) { e.printStackTrace(); Thread.currentThread().interrupt(); } } public void stop() { isRunning = false; }} 消费者： 123456789101112131415161718192021222324252627public class Consumer implements Runnable { private BlockingQueue&lt;PCData&gt; queue; private static final int SLEEPTIME = 1000; public Consumer(BlockingQueue&lt;PCData&gt; queue) { this.queue = queue; } @Override public void run() { System.out.println(\"start Consumer id = \" + Thread.currentThread().getId()); Random r = new Random(); try { while (true) { PCData data = queue.take(); if (null != data) { int re = data.getData() * data.getData(); System.out.println(MessageFormat.format(\"{0}*{1}={2}\", data.getData(), data.getData(), re)); Thread.sleep(r.nextInt(SLEEPTIME)); } } } catch (InterruptedException e) { e.printStackTrace(); Thread.currentThread().interrupt(); } }} 资源(共享数据模型)： 12345678910111213141516171819public final class PCData { private final int intData; public PCData(int d){ intData = d; } public PCData(String d){ intData = Integer.valueOf(d); } public int getData(){ return intData; } @Override public String toString() { return \"data: \" + intData; }} 由于使用BlockingQueue导致性能不佳，提出了另一种改进措施：使用Disruptor框架，Disruptor框架利用环形队列实现高效的无锁内存队列。队列是环形的，则只需要对外提供一个当前位置cursor，利用这个指针既可以进行入队操作，也可以进行出队操作。由于环形队列的缘故，队列的总大小必须事先指定，不能动态扩展。这种固定大小的环形队列的另外一个好处就是可以做到完全的内存复用。在系统的运行过程中，不会有新的空间需要分配或者老的空间需要回收，大大减少系统分配空间及回收空间的额外开销。 资源： 1234567891011public class PCData { private long value; public void set(long value) { this.value = value; } public long get() { return value; }} 工厂类： 123456//它会在Disruptor框架系统初始化时，构造所有的缓冲区中的对象实例public class PCDataFactory implements EventFactory&lt;PCData&gt; { public PCData newInstance(){ return new PCData(); }} 消费者： 1234567public class Consumer implements WorkHandler&lt;PCData&gt; { //回调方法 @Override public void onEvent(PCData pcData) throws Exception { System.out.println(Thread.currentThread().getId() + \":Event: -- \" + pcData.get() * pcData.get() + \"--\"); }} 生产者： 1234567891011121314151617public class Producer { private final RingBuffer&lt;PCData&gt; ringBuffer; public Producer(RingBuffer&lt;PCData&gt; ringBuffer) { this.ringBuffer = ringBuffer; } public void pushData(ByteBuffer bb) { long sequence = ringBuffer.next(); try { PCData event = ringBuffer.get(sequence); event.set(bb.getLong(0)); } finally { ringBuffer.publish(sequence); } }} Future模式当我们需要调用一个函数方法时，如果这个函数执行得很慢，那么我们就要进行等待。但有时候，我们可能并不急着要结果。因此，我们可以让被调者立即返回，让它在后台慢慢处理这个请求。对于调用者来说，则可以先处理一些其他任务，在真正需要数据的场合再去尝试获得需要的数据。 Data接口： 1234//该接口有两个重要的实现，一个是RealData表示真实数据，另一个是FutureData用来立即返回结果（RealData虚拟实现）public interface Data { String getResult();} FutureData： 12345678910111213141516171819202122232425public class FutureData implements Data { protected RealData realdata = null; protected boolean isReady = false; public synchronized void setRealdata(RealData realdata) { if (isReady) { return; } this.realdata = realdata; isReady = true; notifyAll(); } @Override public synchronized String getResult() { while (!isReady) { try { wait(); } catch (InterruptedException e) { } } return realdata.result; }} RealData： 1234567891011121314151617181920public class RealData implements Data { protected final String result; public RealData(String para) { StringBuffer sb = new StringBuffer(); for (int i = 0; i &lt; 10; i++) { sb.append(para); try { Thread.sleep(100); } catch (InterruptedException e) { } } result = sb.toString(); } @Override public synchronized String getResult() { return result; }} Client： 12345678910public class Client { public Data request(final String queryStr) { final FutureData future = new FutureData(); new Thread(() -&gt; { RealData realData = new RealData(queryStr); future.setRealdata(realData); }).start(); return future; }} Main方法： 12345678910111213public class Main { public static void main(String[] args) { Client client = new Client(); Data data = client.request(\"name\"); System.out.println(\"请求完毕\"); try { Thread.sleep(2000); } catch (InterruptedException e) { } System.out.println(\"数据 = \" + data.getResult()); }} 观察者模式(Observer Pattern)一般有一个被观察者和多个观察者，一旦被观察者状态发生改变，就会通知到多个观察者，即当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。 装饰者模式适配器模式工厂模式","link":"/2020/06/01/%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"title":"解决IDEA中Tomcat9.X控制台输出乱码问题","text":"IDEA版本为2019.3.2，Tomcat版本为9.0.31 使用文本编辑器打开Tomcat安装目录下的conf/logging.properties文件，删除java.util.logging.ConsoleHandler.encoding = UTF-8行，保存退出。","link":"/2020/05/27/%E8%A7%A3%E5%86%B3IDEA%E4%B8%ADTomcat9.X%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BA%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/"},{"title":"LeetCode&#x2F;167. 两数之和 II - 输入有序数组","text":"167. 两数之和 II - 输入有序数组给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。 函数应该返回这两个下标值 index1和 index2，其中 index1必须小于 index2。 说明: 返回的下标值（index1和 index2）不是从零开始的。 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。 示例1 ： 123输入: numbers = [2, 7, 11, 15], target = 9输出: [1,2]解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/path-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题首先想到就应该是双指针法，思路也很简单，就是一个指针指向开头，另一个指针指向结尾，然后判断指针所指向的两数之和是否等于target，如果相等就返回相应的index；如果不等判断两数之和和target的大小，如果和大于target，则需要index2向左移动以此来缩小和，如果和小于target，则需要index1向右移动以此来增大和。 具体代码如下： 1234567891011121314151617181920212223242526class Solution { public int searchInsert(int[] nums, int target) { if (nums.length == 0) return -1; int left = 0; //这里用right = nums.length，下面的while循环条件就用left &lt; right //这里如果是right = nums.length - 1，下面的循环条件就是left &lt;= right //这是因为使用right = nums.length循环判等的话会出现越界 int right = nums.length; while (left &lt; right) { int mid = left + (right - left) / 2; //防止left和right太大导致相加除二溢出 if (nums[mid] == target) { //如果target就是nums[mid]的值的话就直接返回 return mid; } if (target &gt; nums[mid]) { //如果target比nums[mid]大，我们向右子区间收缩，所以这里需要left = mid + 1 left = mid + 1; } if (target &lt; nums[mid]) { //因为我们上面的right = nums.length，并且循环条件为left &lt; right //所以这里不能使用right = mid - 1，具体的大家可以debug观察结果 right = mid; } } return left; }} 官方提示中还提到了二分查找，由于二分查找不能同时进行两个数的查找，我们最先能想到的就是固定一个数，然后去剩下的元素中找，看能不能找到一个值和target - numbers[i]的值相等，如果能，则返回两者索引，如果不能，则返回-1。 具体代码如下： 12345678910111213141516171819202122232425262728293031323334public class Solution { public int[] twoSum(int[] numbers, int target) { int right = numbers.length - 1; //固定一个值，在剩下的元素中找一个数是否等于target - numbers[i]的值 for (int i = 0; i &lt; numbers.length; i++) { if (numbers[i] + numbers[right] == target) { return new int[]{i + 1, right + 1}; } int index2 = binarySearch(numbers, i + 1, right, target - numbers[i]); if (index2 != -1) { return new int[]{i + 1, index2 + 1}; } } return new int[]{-1, -1}; } //手写binarySearch()方法，当然也可以直接调用Arrays.binarySearch()方法 public int binarySearch(int[] nums, int fromIndex, int toIndex, int target) { int left = fromIndex; int right = toIndex - 1; while (left &lt;= right) { int mid = left + (right - left) / 2; if (nums[mid] == target) return mid; else if (nums[mid] &gt; target) { right = mid - 1; } else if (nums[mid] &lt; target) { left = mid + 1; } } return -1; }}","link":"/2020/07/20/LeetCode/167.%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%20II%20-%20%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"},{"title":"LeetCode&#x2F;1025. 除数博弈","text":"1025. 除数博弈爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。 最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作： 选出任一 x，满足 0 &lt; x &lt; N 且 N % x == 0 。 用 N - x 替换黑板上的数字 N 。 如果玩家无法执行这些操作，就会输掉游戏。 只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 false。假设两个玩家都以最佳状态参与游戏。 示例1: 123输入：2输出：true解释：爱丽丝选择 1，鲍勃无法进行操作。 示例 2： 123输入：3输出：false解释：爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。 提示： 1 &lt;= N &lt;= 1000 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/unique-paths-ii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：刚拿到题我是懵逼的，如何将实际的场景转化为数学情景，需要思考一番。参考了官方题解，其实这就是一道数学归纳的题型，我们可以列举前几项的情况，从中找出规律： 12345N = 1 的时候，区间 (0, 1) 中没有整数是 n 的因数，所以此时 Alice 败。N = 2 的时候，Alice 只能拿 1，N 变成 1，Bob 无法继续操作，故 Alice 胜。N = 3 的时候，Alice 只能拿 1，N 变成 2，根据 N = 2 的结论，我们知道此时 Bob 会获胜，Alice 败。N = 4 的时候，Alice 能拿 1 或 2，如果 Alice 拿 1，根据 N = 3 的结论，Bob 会失败，Alice 会获胜。N = 5 的时候，Alice 只能拿 1，根据 N = 4 的结论，Alice 会失败。 我们可以看到N为奇数的时候 Alice必败，N为偶数的时候 Alice 必胜，该 在N = 1和N = 2时结论成立，假设N = k时成立，则N = k+1时， 若k+1为奇数，则x为奇数，奇减奇得偶，故Bob拿偶，Alice拿奇必败 若k+1为偶数，x可奇可偶，Alice减去一个奇数，则剩下的数为奇数，Alice必胜 具体实现代码如下： 12345class Solution { public boolean divisorGame(int N) { return N % 2 == 0; }}","link":"/2020/07/24/LeetCode/1025.%20%E9%99%A4%E6%95%B0%E5%8D%9A%E5%BC%88/"},{"title":"LeetCode&#x2F;198. 打家劫舍","text":"198. 打家劫舍你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 示例1 ： 1234输入：[1,2,3,1]输出：4解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 示例2： 1234输入：[2,7,9,3,1]输出：12解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。 提示： 0 &lt;= nums.length &lt;= 100 0 &lt;= nums[i] &lt;= 400 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/path-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题一看到是要求受益最大，那肯定就是动态规划了，这里有一点比较难想，就是偷过第i-1家后不能再偷第i家，否则会触发报警。当前收益最大有两种情况，第一种情况是前一家偷过了，那么当前最大收益就是前一天的最大收益，第二种情况是前一家没有偷过，那么当前的最大收益就是前前天的最大收益，加上当前能偷得钱的金额。 同时边界条件为dp[0] = nums[0],dp[1] = Math.max(nums[0], nums[1])，我们写出状态转移方程： dp[i] = Math.max(dp[i-1] , dp[i-2]+nums[i])具体代码如下： 1234567891011121314151617181920class Solution { public int rob(int[] nums) { //进行判空处理，这道题LeetCode卡的比较严 if (nums.length == 0 || nums == null) { return 0; } if (nums.length == 1){ return nums[0]; } //创建最大收益数组 int[] dp = new int[nums.length]; dp[0] = nums[0]; dp[1] = Math.max(nums[0], nums[1]); for (int i = 2; i &lt; nums.length; i++) { dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]); } //最后返回最大收益结果 return dp[nums.length - 1]; }} 一到动态规划的问题，那我们一定可以想办法优化空间复杂度，这里我们发现最大收益只与dp[i],dp[i-1],dp[i-2]有关，那么我们可以将一维数组优化为三个变量，这三个变量分别存储当前收益，前一天收益和前前一天收益。具体代码如下： 12345678910111213141516171819class Solution { public int rob(int[] nums) { if (nums.length == 0 || nums == null) { return 0; } if (nums.length == 1) { return nums[0]; } int dp0 = nums[0]; int dp1 = Math.max(nums[0], nums[1]); int dp2 = Math.max(dp0, dp1); for (int i = 2; i &lt; nums.length; i++) { dp2 = Math.max(dp1, dp0 + nums[i]); dp0 = dp1; dp1 = dp2; } return dp2; }}","link":"/2020/08/05/LeetCode/198.%20%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/"},{"title":"LeetCode&#x2F;120. 三角形最小路径和","text":"120. 三角形最小路径和给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。 相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。 例如，给定三角形： 123456[ [2], [3,4], [6,5,7], [4,1,8,3]] 自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。 说明： 如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/path-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题若是不考虑说明中的优化空间，思路很清晰，就是动态规划。首先能想到的就是，第i个位置的路径和，与上一行相邻的元素有关，由于要求最短的路径和，所以就是在第i-1行相邻元素中选择一个最小的累加，即$dp[i][j]=min(dp[i-1][j-1],dp[i-1][j])+triangle[i][j]$，这就是状态转移方程。下面我们需要考虑一些细节，比如每行的第一个元素，它没有左邻居，所以状态转移方程为$dp[i][0]=dp[i-1][0]+triangle[i][0]$，同样要考虑的还有每行最后一个元素，它没有右邻居，所以状态转移方程为$dp[i][i]=dp[i-1][i-1]+triangle[i][i]$，最后，dp数组的最后一行就是所有路径结果和，我们只需要遍历最后一行，找出最小的值即为结果值。 具体代码如下： 12345678910111213141516171819202122232425class Solution { public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) { int n = triangle.size(); int[][] dp = new int[n][n]; //创建一个二维数组来存放最短路径和 dp[0][0] = triangle.get(0).get(0); //三角形第一行只有一个元素，所以dp[0][0]就为第一行元素值 for (int i = 1; i &lt; n; i++) { dp[i][0] = dp[i - 1][0] + triangle.get(i).get(0); //每行第一个元素只与上一个第一个元素有关 dp[i][i] = dp[i - 1][i - 1] + triangle.get(i).get(i); //每行最后一个元素只与斜对角线上的上一行元素有关 for (int j = 1; j &lt; i; j++) { //普通位置元素与上一行j-1和j的元素值有关 dp[i][j] = Math.min(dp[i - 1][j - 1], dp[i - 1][j]) + triangle.get(i).get(j); } } //结果数组的最后一行存放着各个情况的路径和，只需要遍历找出最小的即可 int result = dp[n - 1][0]; for (int i = 0; i &lt; n; i++) { result = Math.min(result, dp[n - 1][i]); } return result; }} 当然，这种做法空间复杂度都比较惨烈，我们来思考一下空间还有没有更进一步优化的空间。 通常，动态规划优化空间复杂度都是去除存储的无关值，在本题中，可以看到dp[i][j]只与上一层的dp[i-1][j-1]和dp[i-1][j]有关，所以我们只需要记录这些值即可，具体的思想这里参考了官方题解。要想优化到O(n)的空间复杂度，就需要使用一维数组存储结果。从 i 到0递减地枚举j，这样我们只需要一个长度为n的一维数组f，就可以完成状态转移，即$dp[j]=min(dp[j-1],dp[j])+triangle[i][j]$ 具体代码如下： 1234567891011121314151617181920212223242526class Solution { public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) { int n = triangle.size(); int[] dp = new int[n]; //创建一个二维数组来存放最短路径和 dp[0] = triangle.get(0).get(0); //三角形第一行只有一个元素，所以dp[0][0]就为第一行元素值 for (int i = 1; i &lt; n; i++) { //这里由于使用逆序遍历，所以三条语句的顺序不能打乱，不然会使得结果出错 dp[i] = dp[i - 1] + triangle.get(i).get(i); for (int j = i - 1; j &gt; 0; j--) { dp[j] = Math.min(dp[j - 1], dp[j]) + triangle.get(i).get(j); } dp[0] = dp[0] + triangle.get(i).get(0); } int result = dp[0]; for (int i = 1; i &lt; n; i++) { result = Math.min(result, dp[i]); } return result; }}","link":"/2020/07/14/LeetCode/120.%20%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"},{"title":"LeetCode&#x2F;207. 课程表","text":"207. 课程表你这个学期必须选修 numCourse 门课程，记为 0 到 numCourse - 1 。 在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：[0,1] 给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？ 示例1 ： 123输入: 2, [[1,0]] 输出: true解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。 示例2： 123输入: 2, [[1,0],[0,1]]输出: false解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。 提示: 输入的先决条件是由 边缘列表 表示的图形，而不是 邻接矩阵 。详情请参见图的表示法。 你可以假定输入的先决条件中没有重复的边。 1 &lt;= numCourses &lt;= 10^5 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/path-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：首先应该大概的思路，给定的prerequisites数组可以转化为一个图，我们要求的，就是看该图中是否存在环，若存在，则不能在一学期内学完，否则可以。 具体代码如下： 12","link":"/2020/08/04/LeetCode/207.%20%E8%AF%BE%E7%A8%8B%E8%A1%A8/"},{"title":"LeetCode&#x2F;213. 打家劫舍 II","text":"213. 打家劫舍 II你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。 示例1 ： 123输入: [2,3,2]输出: 3解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。 示例2： 1234输入: [1,2,3,1]输出: 4解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。 偷窃到的最高金额 = 1 + 3 = 4 。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/path-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题是198. 打家劫舍的升级题目，难点在于环状结构，不能同时偷取首尾两家。当前收益最大有两种情况，第一种情况是前一家偷过了，那么当前最大收益就是前一天的最大收益，第二种情况是前一家没有偷过，那么当前的最大收益就是前前天的最大收益，加上当前能偷得钱的金额。 同时边界条件为dp[0] = nums[0],dp[1] = Math.max(nums[0], nums[1])，我们写出状态转移方程： dp[i] = Math.max(dp[i-1] , dp[i-2]+nums[i])解这道题有个取巧的方式就是将一个数组分为两个子数组，一个子数组为nums[0, nums.length - 1]，另一个子数组为nums[1, nums.length - 1]，分别求取两个子数组的最大收益，然后返回最大值即可。 具体代码如下： 123456789101112131415161718192021222324252627282930313233class Solution { public int rob(int[] nums) { if (nums.length == 0 || nums == null) { return 0; } if (nums.length == 1) { return nums[0]; } if (nums.length == 2){ return Math.max(nums[0], nums[1]); } int result1 = 0, result2 = 0; int dp0 = nums[0]; int dp1 = Math.max(nums[0], nums[1]); int dp2 = Math.max(dp0, dp1); for (int i = 2; i &lt; nums.length - 1; i++) { dp2 = Math.max(dp1, dp0 + nums[i]); dp0 = dp1; dp1 = dp2; } result1 = dp2; dp0 = nums[1]; dp1 = Math.max(nums[1], nums[2]); dp2 = Math.max(dp0, dp1); for (int i = 3; i &lt; nums.length; i++) { dp2 = Math.max(dp1, dp0 + nums[i]); dp0 = dp1; dp1 = dp2; } result2 = dp2; return Math.max(result1, result2); }}","link":"/2020/08/05/LeetCode/213.%20%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%20II/"},{"title":"LeetCode&#x2F;112.路经总和","text":"112. 路径总和给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。 说明: 叶子节点是指没有子节点的节点。 示例:给定如下二叉树，以及目标和sum = 22， 5 / \\ 4 8 / / \\ 11 13 4 / \\ \\ 7 2 1 返回 true, 因为存在目标和为22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/path-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题思想就是递归调用左右子树，观察树节点的值加起来是不是sum的值，具体代码如下： 1234567891011121314151617181920212223public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; }}class Solution { public boolean hasPathSum(TreeNode root, int sum) { //判断树是否为空，若为空直接返回false if (root == null) return false; //判断根的左右节点是否为空，若左右节点都为空，则返回sum - root.val的值与0作比较 //若根节点的值等于sum的值，则返回true，否则返回false if (root.left == null &amp;&amp; root.right == null) return sum - root.val == 0; //递归调用左子树，或上递归调用右子树，若左子树中或右子树中满足条件则返回true，否则返回false return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val); }}","link":"/2020/07/18/LeetCode/112.%E8%B7%AF%E7%BB%8F%E6%80%BB%E5%92%8C/"},{"title":"LeetCode&#x2F;216. 组合总和 III","text":"216. 组合总和 III找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。 说明： 所有数字都是正整数。 解集不能包含重复的组合。 示例1 ： 12输入: k = 3, n = 7输出: [[1,2,4]] 示例2： 12输入: k = 3, n = 9输出: [[1,2,6], [1,3,5], [2,3,4]] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/path-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题的思想就是回溯，非常标准的回溯，和组合问题相比没有改变多少 具体代码如下： 123456789101112131415161718192021222324class Solution { List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) { LinkedList&lt;Integer&gt; track = new LinkedList&lt;&gt;(); backtrack(k, n, 1, track); return result; } void backtrack(int k, int n, int start, LinkedList&lt;Integer&gt; track) { if (track.size() == k &amp;&amp; n == 0) { result.add(new LinkedList&lt;&gt;(track)); return; } if (n &lt; 0) return; for (int i = start; i &lt; 10; i++) { track.add(i); backtrack(k, n - i, i + 1, track); track.removeLast(); } }}","link":"/2020/09/10/LeetCode/216.%20%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%20III/"},{"title":"LeetCode&#x2F;309. 最佳买卖股票时机含冷冻期","text":"309. 最佳买卖股票时机含冷冻期给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。 示例: 123输入: [1,2,3,0,2]输出: 3 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/path-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题根据官方提示，是动态规划的思想。当天的收益与昨天的操作有关，让我们来找出状态转移方程。首先我们先考虑第一天的状态，在第一天有两种情况，(1) 我手上没有股票，就表示我没有买入，(2) 我手上有一只股票，表示我买入了一只股票，因为是第一天，我们不考虑冻结期的状态。 第 i 天一共有三种情况： 我们当天手里持有一张股票。这张股票有两种可能性，第一种是我在i 天没有购入，这种状态下我们在i-1天持有一只股票；第二种情况就是在i 天购入的，那么如果在i 天购入的话，就说明在 i-1天没有持有股票且在第i-1天不处在冷冻期。 我们当天没有持有股票，且处在冷冻期。这种状态下，说明在 i-1天的时候购入了一只股票。 我们当天没有持有股票，且不处在冷冻期，这也有两种可能性。第一种是i-1 属于第二种情况，就是处于冷冻期；第二种是i-1属于第三种情况，没有进行任何操作。 下面我们把上述三种情况符号化，我们将第一种情况记为 statusOne，第二种情况记为 statusTwo，第三种情况记为 statusThree，： 第一种情况的状态转移方程为： statusOne = max(statusOne, statusThree - prices[i]) 第二种情况的状态转移方程为： statusTwo = statusOne + prices[i] 第三种情况的状态转移方程为： statusThree = max(statusTwo, statusThree)这里使用三个变量而不是整个数组，是因为第i 天的状态只与第 i-1天的状态有关，这样做会进一步优化空间复杂度。最后，我们只需要返回 statusOne、 statusTwo和 statusThree三者中的最大值就可以了，考虑到最后一天还持有股票肯定不会是最大收益，所以只需要返回 statusTwo和statusThree中的较大值即可。 具体代码实现如下： 1234567891011121314151617181920212223242526272829303132class Solution { public int maxProfit(int[] prices) { int len = prices.length; if (len == 0) return 0; //第一种情况是当天持有股票 //因为是第一天，所以就是当天购买的股票，所以收益需要花费prices[0] int statusOne = -prices[0]; int statusTwo = 0; int statusThree = 0; int temp1, temp2, temp3 = 0; for (int i = 1; i &lt; len; i++) { //根据状态转移方程更新股票收益 temp1 = Math.max(statusOne, statusThree - prices[i]); temp2 = statusOne + prices[i]; temp3 = Math.max(statusTwo, statusThree); statusOne = temp1; statusTwo = temp2; statusThree = temp3; //这里不能这样写，因为这样写的话在一个循环里，statusOne更新过后的值会影响statusTwo的值// statusOne = Math.max(statusOne, statusThree - prices[i]);// statusTwo = statusOne + prices[i];// statusThree = Math.max(statusTwo, statusThree); } //因为在最后一天还持有股票没有意义，会减少收益 //所以只考虑statusTwo和statusThree的情况 return Math.max(statusTwo, statusThree); }}","link":"/2020/07/18/LeetCode/309.%20%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F/"},{"title":"LeetCode&#x2F;337. 打家劫舍 III","text":"337. 打家劫舍 III在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。 计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。 示例1 ： 12345678910输入: [3,2,3,null,3,null,1] 3 / \\ 2 3 \\ \\ 3 1输出: 7 解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7. 示例2： 12345678910输入: [3,4,5,1,3,null,1] 3 / \\ 4 5 / \\ \\ 1 3 1输出: 9解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9. 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/path-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题借鉴官方题解，根据该系列前两题，198. 打家劫舍和213. 打家劫舍 II的进阶版题型，将数组换成了二叉树。根据动态规划的思想，我们肯定要递归遍历这棵树。当我们遍历到该结点时，一共有两种情况，第一种是该结点被偷了，那么该结点的左右孩子结点都不应该再去偷，第二种是该结点没有被偷，那么它的左右孩子可能被偷，也可能没有被偷。我们设置两个HashMap结构存储，用selected表示当前结点被偷，unselected表示当前结点没有被偷，对第一种情况，我们需要将当前结点和当前结点孩子结点没有被偷的情况下的值存入，对第二种情况，我们需要保存的是当前结点左右孩子偷或者不偷后的最大值。通过后序遍历，我们就可以得到根结点的最大收益。 具体代码如下： 1234567891011121314151617181920212223242526272829class Solution { Map&lt;TreeNode, Integer&gt; selected = new HashMap&lt;&gt;(); Map&lt;TreeNode, Integer&gt; unselected = new HashMap&lt;&gt;(); public int rob(TreeNode root) { depthFirstSearch(root); return Math.max(selected.getOrDefault(root, 0), unselected.getOrDefault(root, 0)); } public void depthFirstSearch(TreeNode node) { if (node == null) { return; } depthFirstSearch(node.left); depthFirstSearch(node.right); selected.put(node, node.val + unselected.getOrDefault(node.left, 0) + unselected.getOrDefault(node.right, 0)); unselected.put(node, Math.max(selected.getOrDefault(node.left, 0), unselected.getOrDefault(node.left, 0)) + Math.max(selected.getOrDefault(node.right, 0), unselected.getOrDefault(node.right, 0))); }}class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; }}","link":"/2020/08/05/LeetCode/337.%20%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%20III/"},{"title":"LeetCode&#x2F;315. 计算右侧小于当前元素的个数","text":"309. 最佳买卖股票时机含冷冻期给定一个整数数组 nums，按要求返回一个新数组 counts。数组 counts 有该性质： counts[i] 的值是 nums[i] 右侧小于 nums[i] 的元素的数量。 示例： 1234567输入: [5,2,6,1]输出: [2,1,1,0] 解释:5 的右侧有 2 个更小的元素 (2 和 1).2 的右侧仅有 1 个更小的元素 (1).6 的右侧有 1 个更小的元素 (1).1 的右侧有 0 个更小的元素. 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/path-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：这一题啊，这一题你要说你没想到暴力破解，我都要锤你了， 具体代码实现如下： 1234567891011121314class Solution { public List&lt;Integer&gt; countSmaller(int[] nums) { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) { int temp = 0; for (int j = i + 1; j &lt; nums.length; j++) { if (nums[i] &gt; nums[j]) temp++; } list.add(temp); } return list; }} 你以为这就是困难题的难度？Submit 一下，是不是超时了？啊哈哈哈哈哈哈","link":"/2020/07/11/LeetCode/315.%20%E8%AE%A1%E7%AE%97%E5%8F%B3%E4%BE%A7%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%AA%E6%95%B0/"},{"title":"LeetCode&#x2F;17. 电话号码的字母组合","text":"17. 电话号码的字母组合给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 示例 ： 12输入：&quot;23&quot;输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;]. 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/path-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题我们都应该能想到回溯，但是由于每个数字对应多个字母，需要考虑到所有字母的排列组合。最直观能想到的就是for循环，比如digits为23，我们需要在第一层for循环里遍历2对应的abc，然后嵌套循环3对应的def，这是在我们知道digits情况下可以这么考虑。但题目给定的digits不定，此时我们就需要用到递归，每次先将数字对应的字母取出来，然后进行递归求解。 具体代码如下： 12345678910111213141516171819202122232425262728293031323334class Solution { //存放数字字母对应表 HashMap&lt;Character, String&gt; map = new HashMap&lt;&gt;(); List&lt;String&gt; result = new LinkedList&lt;&gt;(); public List&lt;String&gt; letterCombinations(String digits) { if (digits.length() == 0) return result; map.put('2', \"abc\"); map.put('3', \"def\"); map.put('4', \"ghi\"); map.put('5', \"jkl\"); map.put('6', \"mno\"); map.put('7', \"pqrs\"); map.put('8', \"tuv\"); map.put('9', \"wxyz\"); StringBuilder track = new StringBuilder(); backtrack(digits, track, 0, map); return result; } void backtrack(String digits, StringBuilder track, int start, Map&lt;Character, String&gt; map) { if (track.length() == digits.length()) { result.add(track.toString()); return; } //取出每个数字对应的字母 String value = map.get(digits.charAt(start)); for (int i = 0; i &lt; value.length(); i++) { backtrack(digits, track.append(value.charAt(i)), start + 1, map); track.deleteCharAt(track.length() - 1); } }}","link":"/2020/09/10/LeetCode/17.%20%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/"},{"title":"LeetCode&#x2F;35. 搜索插入位置","text":"35. 搜索插入位置给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数组中无重复元素。 示例1 ： 12输入: [1,3,5,6], 5输出: 2 示例2： 12输入: [1,3,5,6], 2输出: 1 示例 3: 12输入: [1,3,5,6], 7输出: 4 示例 4: 12输入: [1,3,5,6], 0输出: 0 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/path-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题官方提示也说了，就是二分查找，而且就是最最最普通的二分查找，只不过加了一个如果target不存在于nums数组的话要返回插入位置的索引。具体来说，还是二分查找的大框架不变，只需要在最后找不到的时候返回left索引即可，如果非要找出本题的难点，那可能会是left、right值的问题，你到底一开始是选择right = nums.length，还是选择right = nums.length - 1；是选择left = mid，还是left = mid + 1；是right = mid还是right = mid - 1。 具体代码如下： 1234567891011121314151617181920212223242526class Solution { public int searchInsert(int[] nums, int target) { if (nums.length == 0) return -1; int left = 0; //这里用right = nums.length，下面的while循环条件就用left &lt; right //这里如果是right = nums.length - 1，下面的循环条件就是left &lt;= right //这是因为使用right = nums.length循环判等的话会出现越界 int right = nums.length; while (left &lt; right) { int mid = left + (right - left) / 2; //防止left和right太大导致相加除二溢出 if (nums[mid] == target) { //如果target就是nums[mid]的值的话就直接返回 return mid; } if (target &gt; nums[mid]) { //如果target比nums[mid]大，我们向右子区间收缩，所以这里需要left = mid + 1 left = mid + 1; } if (target &lt; nums[mid]) { //因为我们上面的right = nums.length，并且循环条件为left &lt; right //所以这里不能使用right = mid - 1，具体的大家可以debug观察结果 right = mid; } } return left; }}","link":"/2020/07/17/LeetCode/35.%20%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/"},{"title":"LeetCode&#x2F;350. 两个数组的交集 II","text":"350. 两个数组的交集 II给定两个数组，编写一个函数来计算它们的交集。 示例 1： 12输入：nums1 = [1,2,2,1], nums2 = [2,2]输出：[2,2] 示例 2: 12输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出：[4,9] 说明： 输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。我们可以不考虑输出结果的顺序。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/path-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题应该不难想，就是两个指针对两个数组进行遍历，其中需要关注的有几点： 两个指针的地位应该是平等的，也就是说，不应该出现 for 循环嵌套 for 循环的情况； 大家通常只考虑相等情况，忽视了不等的时候如何进行指针的更新操作。 以上两种情况都容易造成死循环和越界，需要仔细考虑一下。 具体代码如下： 123456789101112131415161718192021222324252627class Solution { public int[] intersect(int[] nums1, int[] nums2) { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); //用来存放结果 Arrays.sort(nums1); Arrays.sort(nums2); int i = 0, j = 0; while (i &lt; nums1.length &amp;&amp; j &lt; nums2.length) { //如果两个值不相等，那么只移动数值较小的数组随对应的指针 if (nums1[i] &lt; nums2[j]) { i++; } else if (nums1[i] &gt; nums2[j]) { j++; } else if (nums1[i] == nums2[j]) { //如果nums1[i] == nums2[j]，则将结果加入list中后，将两个指针同时后移 list.add(nums1[i]); i++; j++; } } //使用Java8新特性 int[] result = list.stream().mapToInt(Integer::valueOf).toArray(); return result; }}","link":"/2020/07/13/LeetCode/350.%20%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86%20II/"},{"title":"LeetCode&#x2F;347. 前 K 个高频元素","text":"347. 前 K 个高频元素给定一个非空的整数数组，返回其中出现频率前k高的元素。 示例1： 12输入: nums = [1,1,1,2,2,3], k = 2输出: [1,2] 示例2: 12输入: nums = [1], k = 1输出: [1] 提示： 你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。 你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。 题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。 你可以按任意顺序返回答案。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/path-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题用最直观的思路，就是创建一个Map，通过计数、排序，可以得到每个数字按照出现次数的降序排列的HashMap，然后截取前k个返回就可以得到结果。 具体代码如下： 1234567891011121314151617181920212223242526class Solution { public int[] topKFrequent(int[] nums, int k) { Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); //计数 for (int i = 0; i &lt; nums.length; i++) { if (map.containsKey(nums[i])) { Integer times = map.get(nums[i]); times += 1; map.put(nums[i], times); } else { map.put(nums[i], 1); } } //按value降序排序 List&lt;Map.Entry&lt;Integer, Integer&gt;&gt; list = new ArrayList&lt;&gt;(map.entrySet()); Collections.sort(list, (o1, o2) -&gt; o2.getValue().compareTo(o1.getValue())); int[] result = new int[k]; Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; iterator = list.iterator(); //包装结果 for (int i = 0; i &lt; k; i++) { Map.Entry&lt;Integer, Integer&gt; next = iterator.next(); result[i] = next.getKey(); } return result; }} 当然了，这种暴力解法时间复杂度和空间复杂度都不太好，我们利用官方描述的堆的方式来解题。一顿操作后，发现时间复杂度和空间复杂度依旧很高。 具体代码如下： 1234567891011121314151617181920212223242526272829303132333435class Solution { public int[] topKFrequent(int[] nums, int k) { //建立出现评率数组 Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int num : nums) { map.put(num, map.getOrDefault(num, 0) + 1); } //对频率数组进行排序 List&lt;Map.Entry&lt;Integer, Integer&gt;&gt; list = new ArrayList&lt;&gt;(map.entrySet()); Collections.sort(list, (o1, o2) -&gt; o2.getValue().compareTo(o1.getValue())); //建立小顶堆 PriorityQueue&lt;int[]&gt; queue = new PriorityQueue&lt;&gt;(Comparator.comparingInt(o -&gt; o[1])); for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) { int key = entry.getKey(); int value = entry.getValue(); if (queue.size() == k) { //比较新元素和堆顶元素的大小，如果堆的大小为k且堆顶元素的值比新值小，则将替换堆顶元素 if (queue.peek()[1] &lt; value) { queue.poll(); queue.offer(new int[]{key, value}); } } else { queue.offer(new int[]{key, value}); } } //包装结果 int[] result = new int[k]; for (int i = 0; i &lt; k; i++) { result[i] = queue.poll()[0]; } return result; }} 还有一种桶排序的方法，桶排序的基本思想就是，首先我们还是要得到出现频次数组，然后我们需要新建一个桶数组，将桶数组的下标和出现频次对应起来，比如1出现了3次，那么桶数组下标为3的位置就应该存放1，最后，我们倒序遍历桶数组，就可以得到出现频次前K大的结果。 具体代码如下： 123456789101112131415161718192021222324252627282930class Solution { public int[] topKFrequent(int[] nums, int k) { //建立出现频率数组 Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int num : nums) { map.put(num, map.getOrDefault(num, 0) + 1); } List&lt;Integer&gt;[] freqList = new List[nums.length + 1]; for (int i = 0; i &lt; freqList.length; i++) { freqList[i] = new ArrayList&lt;&gt;(); } //将出现频次与桶数组下标对应 map.forEach((num, freq) -&gt; freqList[freq].add(num)); //包装结果 int[] result = new int[k]; int index = 0; for (int i = freqList.length - 1; i &gt; 0; i--) { for (Integer num : freqList[i]) { result[index++] = num; if (index == k) { return result; } } } return result; }}","link":"/2020/09/07/LeetCode/347.%20%E5%89%8D%20K%20%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/"},{"title":"LeetCode&#x2F;377. 组合总和 Ⅳ","text":"377. 组合总和 Ⅳ给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。 示例 : 123456789101112131415nums = [1, 2, 3]target = 4所有可能的组合为：(1, 1, 1, 1)(1, 1, 2)(1, 2, 1)(1, 3)(2, 1, 1)(2, 2)(3, 1)请注意，顺序不同的序列被视作不同的组合。因此输出为 7。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/path-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题虽然也叫做组合总和问题，但是和前面的问题不太一样，前面的组合总和问题都需要把所有的结果列出来，返回列表，而本题只需要返回所有结果的可能性。如果你试图将所有结果遍历出来然后返回result链表的大小，那么就会超时。因此我们根据官方的提示，尝试用动态规划的方法解决问题。至于这个题目怎么一下子想到动态规划，说实话这个可能就是做得多了才会有感觉吧，反正我一开始是没有想到的。 要用动态规划，我们能想到dp数组肯定是存放可能性的，然后就是需要找出状态转移方程，通过将几种情况列出来后我们发现，dp[i] = dp[i - nums[j]] +dp[i - nums[j + 1]]....这里[]里面的数都要大于零，状态转移方程找到后，问题迎刃而解。 123456789101112131415161718192021222324假设nums[]为[1, 2, 3]，我们通过列举几个例子来看下情况target = 0时dp([1, 2, 3], 0) = {}target = 1时dp([1, 2, 3], 1) = {1} = U({1} x dp([1, 2, 3], 1 - 1))target = 2时dp([1, 2, 3], 2) = U({1} x dp([1, 2, 3], 2 - 1), {1, 1} {2} x dp([1, 2, 3], 2 - 2)) {2}target = 3时dp([1, 2, 3], 3) = U({1} x dp([1, 2, 3], 3 - 1), {1, 1, 1} {1, 2} {2} x dp([1, 2, 3], 3 - 2), {2, 1} {3} x dp([1, 2, 3], 3 - 3)) {3}target = 4时dp([1, 2, 3], 4) = U({1} x dp([1, 2, 3], 4 - 1), {1, 1, 1, 1} {1, 1, 2} {1 ,2, 1} {1, 3} {2} x dp([1, 2, 3], 4 - 2), {2, 1, 1} {2, 2} {3} x dp([1, 2, 3], 4 - 3)) {3, 1} 具体代码如下： 123456789101112131415class Solution { public int combinationSum4(int[] nums, int target) { int[] dp = new int[target + 1]; dp[0] = 1; for (int i = 1; i &lt;= target; i++) { for (int j = 0; j &lt; nums.length; j++) { if (nums[j] &lt;= i) { dp[i] += dp[i - nums[j]]; } } } return dp[target]; }}","link":"/2020/09/10/LeetCode/377.%20%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%20%E2%85%A3/"},{"title":"LeetCode&#x2F;343. 整数拆分","text":"343. 整数拆分给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。 示例1 ： 123输入: 2输出: 1解释: 2 = 1 + 1, 1 × 1 = 1。 示例2： 123输入: 10输出: 36解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。 说明: 你可以假设 n 不小于 2 且不大于 58。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/path-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题根据提示，需要用到动态规划，那么我们首先就需要找出状态转移方程。我们用dp数组来存储两个数的乘积，这个乘积分为两种情况，第一种情况就是，i被拆为i和i-j，那乘积就是i和i-j的乘积，另一种情况就是，拆分出j后还需要对剩下的i-j再次进行拆分，所以乘积就是j和dp[i-j]的乘积。通过以上分析我们就可以列出状态转移方程： dp[i] = Math.max(j * (i-j),j * dp[i-j])我们遍历从0到n的数，就可以得出结果。 具体代码如下： 123456789101112131415class Solution { public int integerBreak(int n) { if (n == 0) return 0; int[] dp = new int[n + 1]; for (int i = 0; i &lt;= n; i++) { int curMax = 0; for (int j = 1; j &lt; i; j++) { curMax = Math.max(curMax, Math.max(j * (i - j), j * dp[i - j])); } dp[i] = curMax; } return dp[n]; }}","link":"/2020/07/30/LeetCode/343.%20%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86/"},{"title":"LeetCode&#x2F;39. 组合总和","text":"39. 组合总和给定一个无重复元素的数组 candidates和一个目标数 target，找出 candidates中所有可以使数字和为 target的组合。 candidates中的数字可以无限制重复被选取。 说明： 所有数字（包括 target）都是正整数。 解集不能包含重复的组合。 示例1 ： 123456输入：candidates = [2,3,6,7], target = 7,所求解集为：[ [7], [2,2,3]] 示例 2： 1234567输入：candidates = [2,3,5], target = 8,所求解集为：[ [2,2,2,2], [2,3,3], [3,5]] 提示： 1 &lt;= candidates.length &lt;= 30 1 &lt;= candidates[i] &lt;= 200 candidate中的每个元素都是独一无二的 1 &lt;= target &lt;= 500 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/path-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题我们还是依靠全排列的回溯思想，让我们在全排列的基础上修改此题。很直观的想法，就是该数组元素之和要等于target，那么我们可以设置一个变量count，每次回溯往track中添加元素后和target比较大小，如果相等则该track就是我们想要的结果，将track加入result中，如果target小于count，显然此时已经没有意义了，我们直接return。 具体代码如下： 123456789101112131415161718192021222324252627282930class Solution { List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) { LinkedList&lt;Integer&gt; track = new LinkedList&lt;&gt;(); int count = 0; backtrack(candidates, target, 0, count, track); return result; } void backtrack(int[] candidates, int target, int start, int count, LinkedList&lt;Integer&gt; track) { //触发结束条件 if (target == count) { result.add(new LinkedList&lt;&gt;(track)); return; } //如果count超过target则直接返回， if (target &lt; count) { return; } for (int i = start; i &lt; candidates.length; i++) { //将track中未出现的元素加入 track.add(candidates[i]); backtrack(candidates, target, i, count + candidates[i], track); //剔除最后一个元素，尝试下一个不同的元素 track.removeLast(); } }} 既然正向加可以，那么自然而然就会想到逆向减也是可行的，并且如果是逆向减的话还不需要设置count变量，节省了空间。我们直接将target - candidates[i]传入backtrack方法，如果target == 0时说明数组之和等于target，同样，如果target &lt; 0证明值超了，这时直接return即可。 具体代码如下： 12345678910111213141516171819202122232425262728class Solution { List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) { LinkedList&lt;Integer&gt; track = new LinkedList&lt;&gt;(); backtrack(candidates, target, 0, track); return result; } void backtrack(int[] candidates, int target, int start, LinkedList&lt;Integer&gt; track) { //触发结束条件 if (target == 0) { result.add(new LinkedList&lt;&gt;(track)); return; } if (target &lt; 0) { return; } for (int i = start; i &lt; candidates.length; i++) { //将track中未出现的元素加入 track.add(candidates[i]); backtrack(candidates, target - candidates[i], i, track); //剔除最后一个元素，尝试下一个不同的元素 track.removeLast(); } }}","link":"/2020/09/08/LeetCode/39.%20%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/"},{"title":"LeetCode&#x2F;392. 判断子序列","text":"392. 判断子序列给定字符串 s和 t，判断s是否为t的子序列。 你可以认为 s和 t中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s是个短字符串（长度 &lt;=100）。 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace“是”abcde“的一个子序列，而”aec“不是）。 示例1： 12s = &quot;abc&quot;, t = &quot;ahbgdc&quot;返回 true. 示例2： 12s = &quot;axc&quot;, t = &quot;ahbgdc&quot;返回 false. 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/path-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题思路其实很简单，就是双指针法，令两个指针分别指向两个字符串，如果两个指针指向的char相同，则两个指向都向后移位，如果两个指针指向的char值不同，则指向字符串t的指针向后移位，等到字符串t遍历完后，我们判断指针i是否已经遍历完s字符串，如果遍历完了，说明s是t的子串，如果没有完，说明s不是t的子串。 具体代码实现如下： 123456789public boolean isSubsequence(String s, String t) { int i = 0, j = 0; while (i &lt; s.length() &amp;&amp; j &lt; t.length()) { if (s.charAt(i) == t.charAt(j)) i++; j++; } return i == s.length();}","link":"/2020/07/27/LeetCode/392.%20%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97/"},{"title":"LeetCode&#x2F;415. 字符串相加","text":"415. 字符串相加给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。 注意： num1和num2的长度都小于 5100. num1和num2都只包含数字0-9. num1和num2都不包含任何前导零。 你不能使用任何內建BigInteger库， 也不能直接将输入的字符串转换为整数形式。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/path-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题思想很简单，就是利用加法原理，对应位相加再加上进位。 有些小细节我们需要注意： 两数相加有进位，我们需要新建一个变量存储进位信息 注意int和char的转换，我们给给越界数字串添加的是int 0而不是char '0' 最后得到的stringBuilder需要逆序 具体代码如下： 1234567891011121314151617181920212223242526272829303132class Solution { public String addStrings(String num1, String num2) { //我们建立两个指针，分别指向两个字符串的尾部 int index1 = num1.length() - 1; int index2 = num2.length() - 1; //count用来记录进位情况 int count = 0; //创建stringBuilder存放结果 StringBuilder stringBuilder = new StringBuilder(); //当两个指针没有越界，或者进位不为0时进行循环 while (index1 &gt;= 0 || index2 &gt;= 0 || count != 0) { //判断指针有没有越界，如果越界则补0 int i = index1 &lt; 0 ? 0 : num1.charAt(index1) - '0'; int j = index2 &lt; 0 ? 0 : num2.charAt(index2) - '0'; //我们将两数相加和进位的结果存放在temp中 int temp = i + j + count; //获取合数的个位存放进结果数组 stringBuilder.append(temp % 10); //获取进位情况 count = temp / 10; index1--; index2--; } //由于我们的stringBuilder是从零开始append的，所以需要将字符串reverse stringBuilder.reverse(); return stringBuilder.toString(); }}","link":"/2020/08/03/LeetCode/415.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0/"},{"title":"LeetCode&#x2F;40. 组合总和 II","text":"40. 组合总和 II给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的每个数字在每个组合中只能使用一次。 说明： 所有数字（包括目标数）都是正整数。解集不能包含重复的组合。示例 1: 12345678输入: candidates = [10,1,2,7,6,1,5], target = 8,所求解集为:[ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6]] 示例 2: 123456输入: candidates = [2,5,2,1,2], target = 5,所求解集为:[ [1,2,2], [5]] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/path-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题和39. 组合总和类似，但是多出了限制条件，要求排列组合不能重复。我们先用最原始的思路在39. 组合总和上进行改造，为了避免重复，我们可以效仿47. 全排列 II的样子，创建一个used数组，用来标记当前元素是否已经被使用，接着，我们在每次backtrack的时候判断result里面是否有当前满足条件的track如果有的话就直接跳过，最后就是常规的回溯算法的标准框架。 具体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738class Solution { List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) { LinkedList&lt;Integer&gt; track = new LinkedList&lt;&gt;(); //设置标记数组用来判断当前数字是否已经被使用 boolean[] used = new boolean[candidates.length]; //对candidates数组进行排序 Arrays.sort(candidates); backtrack(candidates, target, 0, track, used); return result; } void backtrack(int[] candidates, int target, int start, LinkedList&lt;Integer&gt; track, boolean[] used) { //判断结束条件 if (target == 0) { //判读result结果数组中是否包含当前满足条件的排列 if (result.contains(track)) return; result.add(new LinkedList&lt;&gt;(track)); return; } if (target &lt; 0) { return; } for (int i = start; i &lt; candidates.length; i++) { if (used[i]) { continue; } track.add(candidates[i]); used[i] = true; backtrack(candidates, target - candidates[i], i, track, used); used[i] = false; track.removeLast(); } }} 这个结果说实话，是没有办法让人满意的，我们来思考一下如何优化。如果排序后，candidates中相邻两个元素相等，其实排列的结果是重复的，我们可以直接跳过。而且，还有一种更好的办法替代used数组，就是让每次backtrack传进去的start + 1。 具体代码如下： 123456789101112131415161718192021222324252627282930313233class Solution { List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) { LinkedList&lt;Integer&gt; track = new LinkedList&lt;&gt;(); //对candidates数组进行排序 Arrays.sort(candidates); backtrack(candidates, target, 0, track); return result; } void backtrack(int[] candidates, int target, int start, LinkedList&lt;Integer&gt; track) { if (target == 0) { result.add(new LinkedList&lt;&gt;(track)); return; } if (target &lt; 0) { return; } for (int i = start; i &lt; candidates.length; i++) { //如果candidates[i] == candidates[i - 1]证明排列重复，我们可以直接跳过 if (i &gt; start &amp;&amp; candidates[i] == candidates[i - 1]) { continue; } track.add(candidates[i]); //这里注意start要传入i+1 backtrack(candidates, target - candidates[i], i + 1, track); track.removeLast(); } }}","link":"/2020/09/08/LeetCode/40.%20%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%20II/"},{"title":"LeetCode&#x2F;486. 预测赢家","text":"486. 预测赢家给定一个表示分数的非负整数数组。 玩家 1 从数组任意一端拿取一个分数，随后玩家 2 继续从剩余数组任意一端拿取分数，然后玩家 1 拿，…… 。每次一个玩家只能拿取一个分数，分数被拿取之后不再可取。直到没有剩余分数可取时游戏结束。最终获得分数总和最多的玩家获胜。 给定一个表示分数的数组，预测玩家1是否会成为赢家。你可以假设每个玩家的玩法都会使他的分数最大化。 示例1 ： 123456输入：[1, 5, 2]输出：False解释：一开始，玩家1可以从1和2中进行选择。如果他选择 2（或者 1 ），那么玩家 2 可以从 1（或者 2 ）和 5 中进行选择。如果玩家 2 选择了 5 ，那么玩家 1 则只剩下 1（或者 2 ）可选。所以，玩家 1 的最终分数为 1 + 2 = 3，而玩家 2 为 5 。因此，玩家 1 永远不会成为赢家，返回 False 。 示例2： 1234输入：[1, 5, 233, 7]输出：True解释：玩家 1 一开始选择 1 。然后玩家 2 必须从 5 和 7 中进行选择。无论玩家 2 选择了哪个，玩家 1 都可以选择 233 。 最终，玩家 1（234 分）比玩家 2（12 分）获得更多的分数，所以返回 True，表示玩家 1 可以成为赢家。 提示： 1 &lt;= 给定的数组长度 &lt;= 20。 数组里所有分数都为非负数且不会大于 10000000 。 如果最终两个玩家的分数相等，那么玩家 1 仍为赢家。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/path-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：具体代码如下： 12","link":"/2020/09/01/LeetCode/486.%20%E9%A2%84%E6%B5%8B%E8%B5%A2%E5%AE%B6/"},{"title":"LeetCode&#x2F;62.不同路径","text":"62. 不同路径一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 问总共有多少条不同的路径？ 例如，上图是一个7 x 3的网格。有多少可能的路径？ 示例 1: 输入: m = 3, n = 2输出: 3解释:从左上角开始，总共有 3 条路径可以到达右下角。 向右 -&gt; 向右 -&gt; 向下 向右 -&gt; 向下 -&gt; 向右 向下 -&gt; 向右 -&gt; 向右 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/unique-paths著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题思想基于动态规划思想，到(i,j)点的路径之和等于到点(i,j-1)与点(i-1,j)的路径之和，递归方程如下： dp(i,j)= dp(i-1,j)+dp(i,j-1)其中第一行和第一列，由于只能一直横着走或者一直竖着走，那么到该行该列上点的路径恒为1，具体实现代码如下： 123456789101112131415161718192021222324class Solution { public int uniquePaths(int m, int n) { int[][] dp = new int[m][n];//初始化路径数组 //初始化第一行 for (int i = 0; i &lt; m; i++) { dp[i][0] = 1; } //初始化第一列 for (int i = 0; i &lt; n; i++) { dp[0][i] = 1; } //递归求解dp数组 for (int i = 1; i &lt; m; i++) { for (int j = 1; j &lt; n; j++) { dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } //最后返回右下角的dp值，即为总路径数量 return dp[m - 1][n - 1]; }}","link":"/2020/07/18/LeetCode/62.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/"},{"title":"LeetCode&#x2F;46. 全排列","text":"46. 全排列给定一个 没有重复 数字的序列，返回其所有可能的全排列。 示例 ： 12345678910输入: [1,2,3]输出:[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/path-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题的思想就是回溯，也可以说是一种暴力破解方法。我们不断的在递归之前将未出现的元素添加到track数组，在递归之后从track数组剔除元素并尝试加入下一个元素，最终遍历完所有的情况 具体代码如下： 12345678910111213141516171819202122232425262728293031class Solution { //存放结果数组 List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) { //记录路径 LinkedList&lt;Integer&gt; track = new LinkedList&lt;&gt;(); backtrack(nums, track); return res; } void backtrack(int[] nums, LinkedList&lt;Integer&gt; track) { //触发结束条件 if (track.size() == nums.length) { res.add(new LinkedList&lt;Integer&gt;(track)); return; } for (int i = 0; i &lt; nums.length; i++) { //排除不合法的选择 if (track.contains(nums[i])) { continue; } //将track中未出现的元素加入 track.add(nums[i]); backtrack(nums, track); //剔除最后一个元素，尝试下一个不同的元素 track.removeLast(); } }}","link":"/2020/09/01/LeetCode/46.%20%E5%85%A8%E6%8E%92%E5%88%97/"},{"title":"LeetCode&#x2F;657. 机器人能否返回原点","text":"657. 机器人能否返回原点在二维平面上，有一个机器人从原点(0, 0)开始。给出它的移动顺序，判断这个机器人在完成移动后是否在(0, 0) 处结束。 移动顺序由字符串表示。字符 move[i] 表示其第 i 次移动。机器人的有效动作有 R（右），L（左），U（上）和 D（下）。如果机器人在完成所有动作后返回原点，则返回 true。否则，返回 false。 注意：机器人“面朝”的方向无关紧要。 “R” 将始终使机器人向右移动一次，“L” 将始终向左移动等。此外，假设每次移动机器人的移动幅度相同。 示例1 ： 123输入: &quot;UD&quot;输出: true解释：机器人向上移动一次，然后向下移动一次。所有动作都具有相同的幅度，因此它最终回到它开始的原点。因此，我们返回 true。 示例2： 123输入: &quot;LL&quot;输出: false解释：机器人向左移动两次。它最终位于原点的左侧，距原点有两次 “移动” 的距离。我们返回 false，因为它在移动结束时没有返回原点。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/path-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题思路很简单，一开始想到的就是创建两个整型变量，通过加左减右，加上减下的方法，当遍历完整个字符串后，看两个变量是否为0，如果为0则证明机器人回到了原点。 具体代码如下： 123456789101112131415161718192021class Solution { public boolean judgeCircle(String moves) { if (moves.isEmpty()) { return true; } int up = 0; int left = 0; for (int i = 0; i &lt; moves.length(); i++) { char s = moves.charAt(i); if (s == 'U') up++; if (s == 'D') up--; if (s == 'L') left++; if (s == 'R') left--; } return up == 0 &amp;&amp; left == 0; }}","link":"/2020/08/28/LeetCode/657.%20%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%83%BD%E5%90%A6%E8%BF%94%E5%9B%9E%E5%8E%9F%E7%82%B9/"},{"title":"LeetCode&#x2F;63.不同路径Ⅱ","text":"63. 不同路径 II一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？ 网格中的障碍物和空位置分别用 1 和 0 来表示。 说明：m和 n 的值均不超过 100。 示例 1: 输入:[ [0,0,0], [0,1,0], [0,0,0]]输出: 2解释:3x3 网格的正中间有一个障碍物。从左上角到右下角一共有 2 条不同的路径： 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/unique-paths-ii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题是62题的升级版本，思想基于动态规划思想，若碰到障碍物，那么到(i,j)点的路径数量为0，否则到(i,j)点的路径数量为(i,j-1)加上(i-1,j)的路径数量。具体递归方程如下： dp(i,j)=\\begin{cases} 0,&obstacleGrid(i,j)=0 \\\\ dp(i-1,j)+dp(i,j-1),&obstacleGrid(i,j)\\not=0 \\end{cases}其中第一行和第一列，由于只能一直横着走或者一直竖着走，那么到该行该列上点的路径恒为1，具体实现代码如下： 123456789101112131415161718192021222324252627class Solution { public static int uniquePathsWithObstacles(int[][] obstacleGrid) { //初始化方格尺寸 int m = obstacleGrid.length; int n = obstacleGrid[0].length; int[][] dp = new int[m][n]; //初始化路径数组 //初始化第一行 for (int i = 0; i &lt; m &amp;&amp; obstacleGrid[i][0] == 0; i++) { dp[i][0] = 1; } //初始化第一列 for (int i = 0; i &lt; n &amp;&amp; obstacleGrid[0][i] == 0; i++) { dp[0][i] = 1; } //若没有障碍物，则(i,j)点的路径数量为(i,j-1)与(i-1,j)的路径数量之和 for (int i = 1; i &lt; m; i++) { for (int j = 1; j &lt; n; j++) { if (obstacleGrid[i][j] == 0) dp[i][j] = dp[i][j - 1] + dp[i - 1][j]; } } //最后返回右下角的dp值，即为总路径数量 return dp[m - 1][n - 1]; }}","link":"/2020/07/18/LeetCode/63.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%E2%85%A1/"},{"title":"LeetCode&#x2F;60. 第k个排列","text":"60. 第k个排列给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。 按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下： &quot;123&quot; &quot;132&quot; &quot;213&quot; &quot;231&quot; &quot;312&quot; &quot;321&quot; 给定 n 和 k，返回第 k 个排列。 说明： 给定 n 的范围是 [1, 9]。 给定 k 的范围是[1, n!]。 示例1： 12输入: n = 3, k = 3输出: &quot;213&quot; 示例2: 12输入: n = 4, k = 9输出: &quot;2314&quot; 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/path-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题一看到排列，我们就想到了回溯。如果单纯的生成所有可能取值，再从中获取目标字符串肯定会超时。通过观察，我们可以发现一定的规律，即数字的全排列是成组的。 1234567891011121314151617举个例子，比如我们的n = 4, k = 9，我们有如下的排列：------------以&quot;1&quot;开头------------ [1, 2, 3, 4] index = 0 [1, 2, 4, 3] index = 1 [1, 3, 2, 4] index = 2 [1, 3, 4, 2] index = 3 [1, 4, 2, 3] index = 4 [1, 4, 3, 2] index = 5------------以&quot;2&quot;开头------------ [2, 1, 3, 4] index = 6 [2, 1, 4, 3] index = 7 [2, 3, 1, 4] index = 8 这是我们要找的目标值 [2, 3, 4, 1] index = 9 [2, 4, 1, 3] index = 10 [2, 4, 3, 1] index = 11------------以&quot;3&quot;开头------------ 此处省略。。。。。。。 有了如上的规律，那么我们就可以缩减问题的规模，通过n和k可以算出目标字符串是以哪个数字开头的，然后通过剩下的数字进行排列，再定位我们要找的是该组中的第几个，就可以得到最终的结果。比如说，我们现在的n = 4, k = 9，我们可以计算出每组有(n-1)!=3!=6个排列，然后我们给positon + gap和k进行比较，同时初始化一个变量count用来算出第一个数字是多少，如果positon + gap小于k，说明我们要找的目标字符串肯定不在该组中，如果positon + gap大于k，则该组中有我们的目标字符串。我们通过position = k - (position - gap) - 1来定位目标字符串在该组的位置，通过count--来定位目标字符串在哪个组中。最后，我们用backtrack来生成剩下数字的排列，进行拼接就可以获取到目标字符串。 具体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class Solution { //存放结果数组 List&lt;String&gt; res = new LinkedList&lt;&gt;(); //存放路径 StringBuilder track; //gap为每组间隔，position为结果在该组的位置，count为列表第一个数字的值 int n, k, gap = 1, position = 0, count = 1; public String getPermutation(int n, int k) { this.n = n; this.k = k; //标记当前值是否被使用 boolean[] used = new boolean[n - 1]; //计算间隔 for (int i = n - 1; i &gt; 0; i--) { gap *= i; } //如果position位置大于k时，说明目标列表在当前组中 while (position &lt; k) { position += gap; //用来计算第一个数字为几 count++; } //寻找目标最终位置 position = k - (position - gap) - 1; count--; //组装除结果列表第一个元素外的列表 ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; n; i++) { if (i + 1 == count) { continue; } list.add(i + 1); } //将ArrayList转换为int数组 int[] nums = list.stream().mapToInt(m -&gt; m).toArray(); //记录路径 this.track = new StringBuilder(); //将列表开头元素加入 track.append(count); backtrack(nums, track, used); //获取目标字符串 return res.get(position); } void backtrack(int[] nums, StringBuilder track, boolean[] used) { //触发结束条件 //如果track.length() == n，说明生成了一个字符串结果 if (track.length() == n) { res.add(track.toString()); return; } for (int i = 0; i &lt; nums.length; i++) { //排除不合法的选择 if (used[i]) { continue; } //将track中未出现的元素加入 used[i] = true; track.append(nums[i]); backtrack(nums, track, used); //剔除最后一个元素，尝试下一个不同的元素 used[i] = false; track.deleteCharAt(track.length() - 1); } }} 当然了，还有一种数学归纳的方法，可以直接判断出目标字符串。所用到的原理和我们上述的比较positon + gap和k的大小，来判断当前位置该填写哪个数字。我们还是以上述的n = 4, k = 9举例，计算出每组有(n-1)!=3!=6个排列，可以定位到第一个位置的数字为2，利用(n-2)!=2!=2和k = k - m * (n - 1)!= 3 ，这里的m是指经过多少个gap定位到目标字符串。接着我们继续重复上面的过程继续往下搜索，由于2 &lt; 3，所以我们可以确定第二位数组为3，利用(n-3)!=1!=1和k = k - m * (n - 2)!= 1，最终可以定位到2314，即我们需要找的目标字符串。 上述两种方法，都对排列的顺序有要求，如果顺序打乱，就不能得到想要的结果。 具体代码请参考官网题解","link":"/2020/09/01/LeetCode/60.%20%E7%AC%ACk%E4%B8%AA%E6%8E%92%E5%88%97/"},{"title":"LeetCode&#x2F;64. 最小路径和","text":"64. 最小路径和给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。 示例 : 12345678输入:[ [1,3,1], [1,5,1], [4,2,1]]输出: 7解释: 因为路径 1→3→1→1→1 的总和最小。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/unique-paths-ii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题和62. 不同路径基本上就是一毛一样，所以我们还是采用动态规划的思想，第一行和第一列由于只能一直横着走或者一直竖着走比较特殊，我们首先初始化第一行和第一列。对于普通元素(i,j)，我们可以写出状态转移方程$dp[i][j]=min(dp[i-1][j],dp[i][j-1])$，最后返回dp数组的最后一个元素即可。 具体实现代码如下： 1234567891011121314151617181920212223class Solution { public int minPathSum(int[][] grid) { int[][] dp = new int[grid.length][grid[0].length]; dp[0][0] = grid[0][0]; //初始化第一行 for (int i = 1; i &lt; grid.length; i++) { dp[i][0] = dp[i - 1][0] + grid[i][0]; } //初始化第一列 for (int i = 1; i &lt; grid[0].length; i++) { dp[0][i] = dp[0][i - 1] + grid[0][i]; } //动态规划求解dp数组 for (int i = 1; i &lt; grid.length; i++) { for (int j = 1; j &lt; grid[0].length; j++) { dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]; } } return dp[grid.length - 1][grid[0].length - 1]; }} 当然，本题的空间复杂度较高，我们发现dp[i][j]只与dp[i-1][j]和dp[i][j-1]有关，所以我们可以将dp数组从二维压缩到一维。我们必须明确，纵向为i横向为j，如下图所示： 首先将j指向的第一行更新，dp[j]=dp[j-1]+grid[0][j]，然后进行迭代，如果j==0时，dp[0]的更新只与上一次dp[0]的值有关，即dp[j] += grid[i][j]，如果j!=0，dp[j]的值与它左边和上边的值有关，即dp[j] = Math.min(dp[j], dp[j - 1]) + grid[i][j]。 具体代码如下： 12345678910111213141516171819202122class Solution { public int minPathSum(int[][] grid) { int[] dp = new int[grid[0].length]; dp[0] = grid[0][0]; //初始化第一行 for (int j = 1; j &lt; grid[0].length; j++) { dp[j] = dp[j - 1] + grid[0][j]; } for (int i = 1; i &lt; grid.length; i++) { for (int j = 0; j &lt; grid[0].length; j++) { if (j == 0) { dp[j] += grid[i][j]; } else { dp[j] = Math.min(dp[j], dp[j - 1]) + grid[i][j]; } } } return dp[grid[0].length - 1]; }}","link":"/2020/07/23/LeetCode/64.%20%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"},{"title":"LeetCode&#x2F;79. 单词搜索","text":"79. 单词搜索给定一个二维网格和一个单词，找出该单词是否存在于网格中。 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。 示例: 12345678910board =[ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E']]给定 word = &quot;ABCCED&quot;, 返回 true给定 word = &quot;SEE&quot;, 返回 true给定 word = &quot;ABCB&quot;, 返回 false 提示： board 和 word 中只包含大写和小写英文字母。 1 &lt;= board.length &lt;= 200 1 &lt;= board[i].length &lt;= 200 1 &lt;= word.length &lt;= 10^3 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/path-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题思想其实很简单，就是在board限制的范围内，你去上下左右进行搜索，匹配word字符串，每一行每一行的匹配，但是代码非常的绕。 具体代码如下： 1234567891011121314151617181920212223242526272829303132class Solution { public boolean exist(char[][] board, String word) { for (int i = 0; i &lt; board.length; i++) { for (int j = 0; j &lt; board[0].length; j++) { if (backtrack(board, word, i, j, 0)) { return true; } } } return false; } boolean backtrack(char[][] board, String word, int x, int y, int start) { //判断是否越界，如果越界直接返回false if (x &gt;= board.length || x &lt; 0 || y &gt;= board[0].length || y &lt; 0 || board[x][y] != word.charAt(start)) { return false; } //如果start == word.length - 1证明查找结束 if (start == word.length() - 1) { return true; } //保存当前值用于结束递归的时候复原 char temp = board[x][y]; //这里使用这样的方法就可以不用创建二维的标记数组 board[x][y] = '#'; boolean result = backtrack(board, word, x + 1, y, start + 1) || backtrack(board, word, x - 1, y, start + 1) || backtrack(board, word, x, y + 1, start + 1) || backtrack(board, word, x, y - 1, start + 1); board[x][y] = temp; return result; }}","link":"/2020/07/17/LeetCode/79.%20%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/"},{"title":"LeetCode&#x2F;785. 判断二分图","text":"785. 判断二分图给定一个无向图graph，当这个图为二分图时返回true。 如果我们能将一个图的节点集合分割成两个独立的子集A和B，并使图中的每一条边的两个节点一个来自A集合，一个来自B集合，我们就将这个图称为二分图。 graph将会以邻接表方式给出，graph[i]表示图中与节点i相连的所有节点。每个节点都是一个在0到graph.length-1之间的整数。这图中没有自环和平行边： graph[i]中不存在i，并且graph[i]中没有重复的值。 示例1 ： 123456789输入: [[1,3], [0,2], [1,3], [0,2]]输出: true解释: 无向图如下:0----1| || |3----2我们可以将节点分成两组: {0, 2} 和 {1, 3}。 示例2： 123456789输入: [[1,2,3], [0,2], [0,1,3], [0,2]]输出: false解释: 无向图如下:0----1| \\ || \\ |3----2我们不能将节点分割成两个独立的子集。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/path-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题思想不难，但是细节要命。基本思想就是染色法，通过广度优先搜索遍历(BFS)，随机选择一个结点上色，比如说染上黑色，然后找到与该结点相连的所有邻接结点，给他们染上不同的颜色，比如说白色。这样，通过广度优先搜索遍历，如果发现某两个相邻结点染色一致，那么就不是二分图，直接返回false就好，反之，当整个图遍历完后，条件依然满足，那么就是二分图，返回true。 具体代码如下： 123456789101112131415161718192021222324252627282930313233class Solution { public boolean isBipartite(int[][] graph) { int n = graph.length; //存放数组长度 //用来存放颜色 //染色状态，0表示未染色，1表示染成黑色，2表示染成白色 int[] color = new int[n]; //初始化颜色数组 Arrays.fill(color, 0); for (int i = 0; i &lt; n; i++) { if (color[i] == 0) { //如果没有这个判断的话，会增加时间复杂度 Queue&lt;Integer&gt; list = new LinkedList&lt;&gt;(); //初始化队列 list.offer(i); //BFS理论上讲可以随机选择一个开始结点 color[i] = 1; //将初始结点染色，你可以染黑色，也可以染白色 while (!list.isEmpty()) { //下面就是标准的BFS框架了，将一个结点的所有邻接结点全部入队，然后执行相应的染色操作 int index = list.poll(); //将当前结点取出 int colorFlags = color[index] == 1 ? 2 : 1; //判断当前结点的染色情况，如果当前结点染色为黑色，那么就要给邻接结点染上白色 for (int neighbor : graph[index]) { //遍历当前结点所有的邻接结点 if (color[neighbor] == 0) { //若邻接结点没染色，那么给它们染上相反的颜色，并将邻接结点入队 color[neighbor] = colorFlags; list.offer(neighbor); } else if (color[neighbor] != colorFlags) { //到这一步就是，如果邻接结点染色了，并且和当前结点颜色一致，那么就不是二分图，直接返回false return false; } } } } } return true; }} 这里我们不妨回顾一下Java中队列的基本知识，在Java中，队列一般用LinkedList来实现，主要的API有add、offer、poll、remove、peek和element，我们来看一下这些方法的区别在哪里，直接上源码： add方法 123456789101112131415161718192021222324252627/** * Appends the specified element to the end of this list. * * &lt;p&gt;This method is equivalent to {@link #addLast}. * * @param e element to be appended to this list * @return {@code true} (as specified by {@link Collection#add}) */public boolean add(E e) { linkLast(e); return true;}/** * Links e as last element. */void linkLast(E e) { final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++;} add方法就是在队尾添加一个新的结点。 offer方法 12345678910/** * Adds the specified element as the tail (last element) of this list. * * @param e the element to add * @return {@code true} (as specified by {@link Queue#offer}) * @since 1.5 */public boolean offer(E e) { return add(e);} offer方法就是add实现的，惊不惊喜，意不意外？ poll方法 1234567891011121314151617181920212223242526272829/** * Retrieves and removes the head (first element) of this list. * * @return the head of this list, or {@code null} if this list is empty * @since 1.5 */public E poll() { final Node&lt;E&gt; f = first; return (f == null) ? null : unlinkFirst(f);}/** * Unlinks non-null first node f. */private E unlinkFirst(Node&lt;E&gt; f) { // assert f == first &amp;&amp; f != null; final E element = f.item; final Node&lt;E&gt; next = f.next; f.item = null; f.next = null; // help GC first = next; if (next == null) last = null; else next.prev = null; size--; modCount++; return element;} poll方法检索并移除队列第一个元素，如果队列为空，则返回空。 remove方法 1234567891011121314151617181920212223/** * Retrieves and removes the head (first element) of this list. * * @return the head of this list * @throws NoSuchElementException if this list is empty * @since 1.5 */public E remove() { return removeFirst();}/** * Removes and returns the first element from this list. * * @return the first element from this list * @throws NoSuchElementException if this list is empty */public E removeFirst() { final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return unlinkFirst(f);} remove方法也是返回并移除队列第一个元素，不过如果队列为空则会抛出NoSuchElementException异常。 peek方法 12345678910/** * Retrieves, but does not remove, the head (first element) of this list. * * @return the head of this list, or {@code null} if this list is empty * @since 1.5 */public E peek() { final Node&lt;E&gt; f = first; return (f == null) ? null : f.item;} peek方法，只是检索队列的第一个元素，并不会移除元素，如果队列为空，则返回null。 element方法 1234567891011121314151617181920212223/** * Retrieves, but does not remove, the head (first element) of this list. * * @return the head of this list * @throws NoSuchElementException if this list is empty * @since 1.5 */public E element() { return getFirst();}/** * Returns the first element in this list. * * @return the first element in this list * @throws NoSuchElementException if this list is empty */public E getFirst() { final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return f.item;} element方法，和peek方法一样，只不过在队列为空时会抛出NoSuchElementException异常。","link":"/2020/07/16/LeetCode/785.%20%E5%88%A4%E6%96%AD%E4%BA%8C%E5%88%86%E5%9B%BE/"},{"title":"LeetCode&#x2F;841. 钥匙和房间","text":"841. 钥匙和房间有 N个房间，开始时你位于 0 号房间。每个房间有不同的号码：0，1，2，...，N-1，并且房间里可能有一些钥匙能使你进入下一个房间。 在形式上，对于每个房间 i 都有一个钥匙列表 rooms[i]，每个钥匙rooms[i][j]由 [0,1，...，N-1] 中的一个整数表示，其中N = rooms.length。 钥匙rooms[i][j] = v可以打开编号为 v的房间。 最初，除 0 号房间外的其余所有房间都被锁住。 你可以自由地在房间之间来回走动。 如果能进入每个房间返回 true，否则返回 false。 示例1 ： 12 示例2： 12 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/path-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：具体代码如下： 12","link":"/2020/08/31/LeetCode/841.%20%E9%92%A5%E5%8C%99%E5%92%8C%E6%88%BF%E9%97%B4/"},{"title":"LeetCode&#x2F;47. 全排列 II","text":"47. 全排列 II给定一个可包含重复数字的序列，返回所有不重复的全排列。 示例 ： 1234567输入: [1,1,2]输出:[ [1,1,2], [1,2,1], [2,1,1]] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/path-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题的思想就是回溯，也可以说是一种暴力破解方法。我们不断的在递归之前将未出现的元素添加到track数组，在递归之后从track数组剔除元素并尝试加入下一个元素，最终遍历完所有的情况 具体代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution { List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); //临时结果数组，用于去重 HashSet&lt;List&lt;Integer&gt;&gt; temRes = new HashSet&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) { //记录路径 LinkedList&lt;Integer&gt; track = new LinkedList&lt;&gt;(); //标记数组，用于判断当前元素是否已经被遍历过 boolean[] used = new boolean[nums.length]; backtrack(nums, track, used); //将结果存入res中 for (List&lt;Integer&gt; temRe : temRes) { res.add(temRe); } return res; } void backtrack(int[] nums, LinkedList&lt;Integer&gt; track, boolean[] used) { //触发结束条件 if (track.size() == nums.length) { temRes.add(new LinkedList&lt;&gt;(track)); return; } for (int i = 0; i &lt; nums.length; i++) { //排除不合法的选择 if (used[i]) { continue; } if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !used[i - 1]) { continue; } //将当前元素加入track中并将标记为置为true track.add(nums[i]); used[i] = true; backtrack(nums, track, used); //取消选择 used[i] = false; track.removeLast(); } }}","link":"/2020/09/01/LeetCode/47.%20%E5%85%A8%E6%8E%92%E5%88%97%20II/"},{"title":"LeetCode&#x2F;77. 组合","text":"77. 组合给定两个整数n和k，返回1 ... n中所有可能的k个数的组合。 示例 ： 12345678910输入: n = 4, k = 2输出:[ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4],] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/path-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题一看到排列组合，就还是回溯的问题，至于怎么回溯，其实做了这么多题了，我们应该总结出一套框架了：在回溯中，首先会判断结束条件，如果满足结束条件，就将结果保存并返回；如果不满足结束条件，我们需要递归地将当前数值加入临时数组中，然后再次backtrack，只有当临时数组的长度符合要求时才会递归地返回，此时我们就会得到一个结果值；最后递归返回后将当前值去除，添加别的值进行不同的排列组合，重复以上过程，就会得到全部结果。这道题和全排列问题非常的相似，不同的是这里不是返回所有的排列值，而是返回指定长度的组合结果。这里我们可以将结束条件设置为临时数组长度等于k时就结束，然后在backtrack过程中加入一个start变量以防止数字重复。 具体代码如下： 12345678910111213141516171819202122232425262728class Solution { List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) { LinkedList&lt;Integer&gt; track = new LinkedList&lt;&gt;(); if (k &lt;= 0 || n &lt; k) { return result; } backtrack(n, k, 1, track, result); return result; } void backtrack(int n, int k, int begin, LinkedList&lt;Integer&gt; track, List&lt;List&lt;Integer&gt;&gt; result) { //触发结束条件 if (track.size() == k) { result.add(new LinkedList&lt;&gt;(track)); return; } for (int i = start; i &lt;= n; i++) { //将track中未出现的元素加入 track.add(i); backtrack(n, k, i + 1, track, result); //剔除最后一个元素，尝试下一个不同的元素 track.removeLast(); } }}","link":"/2020/09/08/LeetCode/77.%20%E7%BB%84%E5%90%88/"},{"title":"LeetCode&#x2F;剑指 Offer 03. 数组中重复的数字","text":"剑指 Offer 03. 数组中重复的数字找出数组中重复的数字。 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。 示例1 ： 123输入：[2, 3, 1, 0, 2, 5, 3]输出：2 或 3 限制： 2 &lt;= n &lt;= 100000 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/path-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题最直接的解法就是暴力破解，这个不做过多解释，大家应该都能想到。 具体代码如下： 1234567891011class Solution { public int findRepeatNumber(int[] nums) { for (int i = 0; i &lt; nums.length; i++) { for (int j = i + 1; j &lt; nums.length; j++) { if (nums[i] == nums[j]) return nums[i]; } } return -1; }} 还有一种解法用到了Set集合的特性，遍历数组，判断数组中的每个数字是否都在Set集合中，如果存在直接返回，如果不存在则向集合中添加。 具体代码如下: 1234567891011class Solution { public int findRepeatNumber(int[] nums) { Set&lt;Integer&gt; result = new HashSet&lt;&gt;(); for (int num : nums) { if (result.contains(num)) return num; result.add(num); } return -1; }} 至于很多题解说的原地置换的方法，我觉得有些取巧，就不再赘述。","link":"/2020/08/09/LeetCode/%E5%89%91%E6%8C%87%20Offer%2003.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"},{"title":"LeetCode&#x2F;剑指 Offer 06. 从尾到头打印链表","text":"剑指 Offer 06. 从尾到头打印链表输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。 示例1 ： 12输入：head = [1,3,2]输出：[2,3,1] 限制： 10 &lt;= 链表长度 &lt;= 10000 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/path-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本来逆序我们可以想到头插法，但是题目要求用数组返回，那我们直接使用栈结构。将head所有结点值压入栈，然后将所有结点值出栈，顺序存入数组。 具体代码如下： 1234567891011121314class Solution { public int[] reversePrint(ListNode head) { LinkedList&lt;Integer&gt; result = new LinkedList&lt;&gt;(); while (head != null) { result.addFirst(head.val); head = head.next; } int[] res = new int[result.size()]; for (int i = 0; i &lt; result.size(); i++) { res[i] = result.get(i); } return res; }}","link":"/2020/08/11/LeetCode/%E5%89%91%E6%8C%87%20Offer%2006.%20%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"},{"title":"LeetCode&#x2F;剑指 Offer 04. 二维数组中的查找","text":"剑指 Offer 04. 二维数组中的查找在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 示例 ： 现有矩阵 matrix 如下： 1234567[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]] 给定 target = 5，返回 true。 给定 target = 20，返回 false。 限制： 120 &lt;= n &lt;= 10000 &lt;= m &lt;= 1000 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/path-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题最直接的解法就是暴力破解，这个不做过多解释，大家应该都能想到。 具体代码如下： 1234567891011class Solution { public boolean findNumberIn2DArray(int[][] matrix, int target) { for (int i = 0; i &lt; matrix.length; i++) { for (int j = 0; j &lt; matrix[0].length; j++) { if (matrix[i][j] == target) return true; } } return false; }} 本题由于横纵都是有序集合，所以一定有优化的空间，一看到有序的数组，我们本能地反应出要用二分查找，我们对每个小数组进行二分查找，如果找到了target则返回true，否则对下一个小数组进行二分查找，要是都没有找到，就返回false 具体代码如下: 1234567891011class Solution { public boolean findNumberIn2DArray(int[][] matrix, int target) { for (int i = 0; i &lt; matrix.length; i++) { if (Arrays.binarySearch(matrix[i], target) &gt;= 0) return true; else continue; } return false; }} 最后一种方法是借鉴官方做法，我们从二维数组的右上角判断该位置数字和target值的大小，如果该位置数字等于target则返回true；如果该位置数组小于target，我们递增到下一行同样的位置比较大小；如果该位置数字大于target，我们需要向左遍历该子数组，判断target是否存在于这个子数组中，如果存在返回true，否则返回false 具体代码如下： 123456789101112131415161718192021class Solution { public boolean findNumberIn2DArray(int[][] matrix, int target) { if (matrix.length == 0 || matrix[0].length == 0) return false; int m = matrix.length; int n = matrix[0].length; for (int i = 0; i &lt; m; i++) { if (matrix[i][n - 1] == target) { return true; } else if (matrix[i][n - 1] &lt; target) { continue; } else { for (int j = n - 1; j &gt;= 0; j--) { if (matrix[i][j] == target) return true; } } } return false; }}","link":"/2020/08/09/LeetCode/%E5%89%91%E6%8C%87%20Offer%2004.%20%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"},{"title":"LeetCode&#x2F;剑指 Offer 09. 用两个栈实现队列","text":"剑指 Offer 09. 用两个栈实现队列用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail和 deleteHead，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead操作返回 -1 ) 示例1 ： 1234输入：[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;][[],[3],[],[]]输出：[null,null,3,-1] 示例2： 1234输入：[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;][[],[],[5],[2],[],[]]输出：[null,-1,null,null,5,2] 限制： 1 &lt;= values &lt;= 10000 最多会对 appendTail、deleteHead 进行 10000 次调用 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/path-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题要求用栈实现队列，我们可以想象，把栈底看成是队列的头，那么我们每次进行压栈操作，就相当于从队尾添加元素。出队操作需要另一个栈来辅助进行，我们可以将stack1的元素依次弹出并压入stack2，这样，在stack2进行pop操作时，就可以实现出队功能，另外，如果将stack1元素全部压入stack2后stack2还为空，那么说明队列中没有元素，即返回-1。 具体代码如下： 1234567891011121314151617181920212223242526272829class CQueue { //初始化两个栈 LinkedList&lt;Integer&gt; stack1; LinkedList&lt;Integer&gt; stack2; public CQueue() { stack1 = new LinkedList&lt;&gt;(); stack2 = new LinkedList&lt;&gt;(); } //入队操作直接就将元素压入stack1即可 public void appendTail(int value) { stack1.push(value); } public int deleteHead() { //如果stack2为空，则将stack1中的元素全部压入stack2 if (stack2.isEmpty()) { while (!stack1.isEmpty()) { stack2.push(stack1.pop()); } } //将stack1中元素全部压入stack2中后，stack2依然为空则返回-1，若不为空则返回栈顶元素 if (stack2.isEmpty()) return -1; else return stack2.pop(); }}","link":"/2020/08/12/LeetCode/%E5%89%91%E6%8C%87%20Offer%2009.%20%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"},{"title":"LeetCode&#x2F;剑指 Offer 10- II. 青蛙跳台阶问题","text":"剑指 Offer 10- II. 青蛙跳台阶问题一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个n 级的台阶总共有多少种跳法。 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回1。 示例1 ： 12输入：n = 2输出：2 示例2： 12输入：n = 7输出：21 示例3： 12输入：n = 0输出：1 提示： 0 &lt;= n &lt;= 100 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/path-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题思路和剑指 Offer 10- I. 斐波那契数列如出一辙，都是斐波那契数列的应用，与剑指 Offer 10- I. 斐波那契数列不同的是，本题是从斐波那契数列第三个索引上的值开始的，我们依旧利用动态规划进行计算。 具体代码如下： 123456789101112131415161718class Solution { public int numWays(int n) { if (n == 0) return 1; if (n &lt;= 2) return n; int[] dp = new int[]{0, 0, 0}; dp[0] = 1; dp[1] = 2; for (int i = 2; i &lt; n; i++) { dp[2] = (dp[0] + dp[1]) % 1000000007; dp[0] = dp[1]; dp[1] = dp[2]; } return dp[2]; }}","link":"/2020/08/28/LeetCode/%E5%89%91%E6%8C%87%20Offer%2010-%20II.%20%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/"},{"title":"LeetCode&#x2F;剑指 Offer 11. 旋转数组的最小数字","text":"剑指 Offer 11. 旋转数组的最小数字把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组[3,4,5,1,2]为 [1,2,3,4,5]的一个旋转，该数组的最小值为1。 示例 1: 12输入：[3,4,5,1,2]输出：1 示例 2： 12输入：[2,2,2,0,1]输出：0 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/unique-paths-ii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题由于官方测试用例规模小，所以最直接的想法就是遍历整个数组，把numbers[0]当做哨兵，如果后面的元素有小于numbers[0]的，返回第一个检索到的数值，如果没有，则numbers[0]就是该序列最小数，直接返回。当然用二分查找也是可以的，如果时间复杂度超了的话，我们就要考虑二分的方法。 具体实现代码如下： 12345678910class Solution { public int minArray(int[] numbers) { for (int i = 1; i &lt; numbers.length; i++) { if (numbers[i] &lt; numbers[0]) { return numbers[i]; } } return numbers[0]; }}","link":"/2020/07/22/LeetCode/%E5%89%91%E6%8C%87%20Offer%2011.%20%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"},{"title":"LeetCode&#x2F;面试题 08.03. 魔术索引","text":"面试题 08.03. 魔术索引魔术索引。 在数组A[0...n-1]中，有所谓的魔术索引，满足条件A[i] = i。给定一个有序整数数组，编写一种方法找出魔术索引，若有的话，在数组A中找出一个魔术索引，如果没有，则返回-1。若有多个魔术索引，返回索引值最小的一个。 示例1 ： 123输入：nums = [0, 2, 3, 4, 5]输出：0说明: 0下标的元素为0 示例2： 12输入：nums = [1, 1, 1]输出：1 说明: nums长度在[1, 1000000]之间。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/path-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题比较简单，可以遍历数组，这个就不解释了，直接上代码 具体代码如下： 123456789class Solution { public int findMagicIndex(int[] nums) { for (int i = 0; i &lt; nums.length; i++) { if (nums[i] == i) return i; } return -1; }}","link":"/2020/07/31/LeetCode/%E9%9D%A2%E8%AF%95%E9%A2%98%2008.03.%20%E9%AD%94%E6%9C%AF%E7%B4%A2%E5%BC%95/"},{"title":"LeetCode&#x2F;面试题16.11.跳水版","text":"面试题 16.11. 跳水板你正在使用一堆木板建造跳水板。有两种类型的木板，其中长度较短的木板长度为shorter，长度较长的木板长度为longer。你必须正好使用k块木板。编写一个方法，生成跳水板所有可能的长度。 返回的长度需要从小到大排列。 示例： 12345输入：shorter = 1longer = 2k = 3输出： {3,4,5,6} 提示： 0 &lt; shorter &lt;= longer 0 &lt;= k &lt;= 100000 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/path-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题思想比较简单，就是三种情况： k为0的时候，此时长度的可能为0，直接返回0 shorter 等于longer时，这时只有一种可能性，就是k块shorter或者longer拼接而成的长度 普通情况，有shorter有longer且两者不相等，这里一共有k+1种情况，所以将shorter和longer的组合填入result数组即可 这里有两点问题需要说明： 为什么一共有k+1种可能？ 假设这种情况，有shorter和longer两种板子，一共有k块板子，那么在长度组合中，longer的个数应该是从0块递增到k块，即0,1,2,….k，总共k+1块 实现代码中result[i] = (k - i) * shorter + i * longer;如果写成result[i] = i * shorter + (k - i) * longer;就会报错？具体错误如下： 该问题确切的说不是问题，只是因为 result 数组顺序是逆序，所以造成 LeetCode 判断结果为错误，我们可以打印出result[i] = i * shorter + (k - i) * longer;最后一个值和result[i] = (k - i) * shorter + i * longer;值作比较来证明，结果是一样的 具体代码如下： 12345678910111213141516171819202122class Solution { public int[] divingBoard(int shorter, int longer, int k) { //若一共需要0块模板，则直接返回空 if (k == 0) return new int[0]; //题目说了0 &lt; shorter &lt;= longer，所以shorter == longer这种情况存在 //这种情况下直接返回k个shorter或者longer拼接的长度即可 if (shorter == longer) { int[] result = new int[1]; result[0] = shorter * k; return result; } //这里用k块模板拼接一共有k+1种可能 int[] result = new int[k + 1]; for (int i = 0; i &lt; k + 1; i++) { result[i] = (k - i) * shorter + i * longer; } return result; }}","link":"/2020/07/08/LeetCode/%E9%9D%A2%E8%AF%95%E9%A2%9816.11.%E8%B7%B3%E6%B0%B4%E7%89%88/"},{"title":"IDEA使用技巧&#x2F;IDEA热部署","text":"在 File -&gt; Settings -&gt; Build, Execution, Deployment -&gt; Compiler 中勾选 Build project automatically，如下图所示 同时按住 Ctrl + Shift + Alt + / 进入Registry，同时勾选以下三项 开启热部署策略，在Edit Configurations中选择运行策略 引入pom依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 最后需要关闭浏览器缓存，如下图","link":"/2020/07/06/IDEA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/IDEA%E7%83%AD%E9%83%A8%E7%BD%B2/"},{"title":"LeetCode&#x2F;面试题17.13.恢复空格","text":"面试题 17.13. 恢复空格哦，不！你不小心把一个长篇文章中的空格、标点都删掉了，并且大写也弄成了小写。像句&quot;I reset the computer. It still didn’t boot!&quot;已经变成了&quot;iresetthecomputeritstilldidntboot&quot;。在处理标点符号和大小写之前，你得先把它断成词语。当然了，你有一本厚厚的词典dictionary，不过，有些词没在词典里。假设文章用sentence表示，设计一个算法，把文章断开，要求未识别的字符最少，返回未识别的字符数。 注意：本题相对原题稍作改动，只需返回未识别的字符数 示例： 12345输入：dictionary = [&quot;looked&quot;,&quot;just&quot;,&quot;like&quot;,&quot;her&quot;,&quot;brother&quot;]sentence = &quot;jesslookedjustliketimherbrother&quot;输出： 7解释： 断句后为&quot;jess looked just like tim her brother&quot;，共7个未识别字符。 提示： 0 &lt;= len(sentence) &lt;= 1000 dictionary中总字符数不超过 150000。 你可以认为dictionary和sentence中只包含小写字母。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/path-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题直接借鉴官方题解，就是字符串+动态规划，其他的方法都不够通俗易懂。基本思想就是，用一个 dp 数组存储前i个字符中最少未识别的字符的数量，定义两个指针i,j，判断 sentence 中 j-1 到 i-1 的子串是否在 dictionary 中，如果在 dictionary 中，那么状态转移方程为 $dp[i]=min(dp[i], dp[j-1])$ ；如果不存在，状态转移方程为$dp[i]=dp[i-1]+1$，即为前 i-1 个未识别的字符数量，加上当前 i 结点的一个字符。 关于如何存储 dictionary 中的单词，由于暴力破解每次都需要重复遍历，浪费了大量的时间，所以这里官方采用 Trie (字典树) 来存储字典中的单词，将单词的每个字母逆序插入到字典树中，每次状态转移的时候就从 Trie 的根节点出发，如果 sentence[j] 在 Trie 没有出现，则 sentence[j…i-1] 不在字典中，否则需要判断该字串是不是 dictionary 中的一个单词，通过加入 isEnd 标记来判断是否成词。 具体代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Solution { public int respace(String[] dictionary, String sentence) { //获取句子长度 int len = sentence.length(); //建立字典树 Trie root = new Trie(); for (String word : dictionary) { root.buildTrie(word); } int[] dp = new int[len + 1]; //定义dp数组，用来存放最少未识别的字符的个数 Arrays.fill(dp, Integer.MAX_VALUE); //由于后面需要比较，所以这里先将dp数组的默认值设置为最大 dp[0] = 0; //dp[0] = 0表示空字符串的最少未识别字符个数为0个 for (int i = 1; i &lt;= len; i++) { //默认没有找到字串在dictionary中出现 //所以就是前i-1的状态再加上当前未识别的字符 dp[i] = dp[i - 1] + 1; Trie curr = root; for (int j = i; j &gt;= 1; j--) { int t = sentence.charAt(j - 1) - 'a'; //当前元素根本不在字典树中，直接跳出循环 if (curr.next[t] == null) break; //这种情况表示sentence中[j-1,i-1]字串是dictionary中的一个单词 //这时只需要判断dp[i]和dp[j-1]中较小值即可 if (curr.next[t].isEnd == true) dp[i] = Math.min(dp[i], dp[j - 1]); curr = curr.next[t]; } } return dp[len]; }}class Trie { public Trie[] next; public boolean isEnd; //添加isEnd标志是为了判断当前字母在字典树中是否为最后一个单词的字母 public Trie() { next = new Trie[26]; //这里因为全是小写字母，所以一个结点的子结点最多有26个 isEnd = false; } public void buildTrie(String s) { Trie currentPoints = this; //将所有的单词，逆序插入字典树中 for (int i = s.length() - 1; i &gt;= 0; i--) { int temp = s.charAt(i) - 'a'; //将字符转换为整数方便处理 if (currentPoints.next[temp] == null) currentPoints.next[temp] = new Trie(); currentPoints = currentPoints.next[temp]; } currentPoints.isEnd = true; //将该单词的最后一个字母标记为结尾单词 }}","link":"/2020/07/09/LeetCode/%E9%9D%A2%E8%AF%95%E9%A2%9817.13.%E6%81%A2%E5%A4%8D%E7%A9%BA%E6%A0%BC/"},{"title":"Spring框架&#x2F;Spring+SpringMVC+MyBatis整合","text":"此次SSM整合基于黑马教程SSM整合基于黑马教程（使用druid连接池） 创建一个带web的Maven工程，基于JDK 1.8，这里就不赘述； 引入Maven依赖，此次主要用到的有Spring家族 5.2.6 版本、MyBatis 3.5.4 版本、MyBatis-Spring 2.0.4版本、Druid数据库连接池、MySQL驱动、Servlet、JSTL等，具体如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;5.2.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.2.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.2.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.22&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.20&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.30&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;5.2.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.6.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建基础Controller层、Service层、Dao层和Domain层； Account实体类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import java.io.Serializable;import java.util.Objects;public class Account implements Serializable { private Integer id; private String name; private Double money; public Account() { } public Account(Integer id, String name, Double money) { this.id = id; this.name = name; this.money = money; } @Override public String toString() { return \"Account{\" + \"id=\" + id + \", name='\" + name + '\\'' + \", money=\" + money + '}'; } @Override public boolean equals(Object o) { if (this == o) return true; if (!(o instanceof Account)) return false; Account account = (Account) o; return Objects.equals(getId(), account.getId()) &amp;&amp; Objects.equals(getName(), account.getName()) &amp;&amp; Objects.equals(getMoney(), account.getMoney()); } @Override public int hashCode() { return Objects.hash(getId(), getName(), getMoney()); } public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Double getMoney() { return money; } public void setMoney(Double money) { this.money = money; }} 这里可以使用 Lombok 化简过程。 AccountService 接口 1234567891011import cn.itcast.domain.Account;import java.util.List;public interface AccountService { //查询数据库所有数据 List&lt;Account&gt; findAll(); //存储指定 Account 类型数据 void saveAccount(Account account);} AccountServiceImpl 实现类 123456789101112131415161718//这里需要添加Service注解，括号里面可以起别名@Service(\"accountService\")public class AccountServiceImpl implements AccountService { //使用 Autowired 自动注入 @Autowired private AccountDao accountDao; public List&lt;Account&gt; findAll() { System.out.println(\"业务层，查询所有账户\"); return accountDao.findAll() ; } public void saveAccount(Account account) { System.out.println(\"业务层：保存账户\"); accountDao.saveAccount(account); }} AccountDao 操作数据库接口 123456789101112131415import cn.itcast.domain.Account;import org.apache.ibatis.annotations.Insert;import org.apache.ibatis.annotations.Select;import org.springframework.stereotype.Repository;import java.util.List;@Repositorypublic interface AccountDao { @Select(\"select * from account\") List&lt;Account&gt; findAll(); @Insert(\"insert into account (name, money) values(#{name},#{money})\") void saveAccount(Account account);} AccountController 123456789101112131415161718192021222324import cn.itcast.domain.Account;import cn.itcast.service.AccountService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import java.util.List;@Controller@RequestMapping(\"/account\")public class AccountController { @Autowired private AccountService accountService; @RequestMapping(\"/findAll\") public String findAll(Model model){ System.out.println(\"表现层：查询所有账户\"); List&lt;Account&gt; list = accountService.findAll(); model.addAttribute(\"list\", list); return \"list\"; }} 创建数据库和account表 1234567create table account( id int auto_increment primary key, name varchar(20) null, money double null); 添加如下测试数据： 配置 web.xml 文件 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app version=\"2.4\" xmlns=\"http://java.sun.com/xml/ns/j2ee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd\"&gt;&lt;!--Spring监听器，默认只加载WEB-INF目录下的applicationContext.xml配置文件--&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;&lt;!-- 设置配置文件路径--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt;&lt;!--SpringMVC前端控制器--&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;!-- 解决中文乱码--&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 配置 applicationContext.xml(Spring 配置文件) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!--开启注解扫描,controller不需要Spring处理--&gt; &lt;context:component-scan base-package=\"cn.itcast\"&gt; &lt;context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/&gt; &lt;/context:component-scan&gt; &lt;!-- Spring整合MyBatis框架--&gt; &lt;!-- 配置连接池--&gt; &lt;bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\"&gt; &lt;!-- 基本属性 url、user、password --&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/ssm\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"3570\"/&gt; &lt;!-- 配置初始化大小、最小、最大 --&gt; &lt;property name=\"initialSize\" value=\"1\"/&gt; &lt;property name=\"minIdle\" value=\"3\"/&gt; &lt;property name=\"maxActive\" value=\"20\"/&gt; &lt;!-- 配置获取连接等待超时的时间 --&gt; &lt;property name=\"maxWait\" value=\"60000\"/&gt; &lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt; &lt;property name=\"timeBetweenEvictionRunsMillis\" value=\"60000\"/&gt; &lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt; &lt;property name=\"minEvictableIdleTimeMillis\" value=\"300000\"/&gt; &lt;/bean&gt; &lt;!-- 配置SqlSessionFactory工厂--&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;/bean&gt; &lt;!-- 配置AccountDao接口--&gt; &lt;bean id=\"mapperScanner\" class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"basePackage\" value=\"cn.itcast.dao\"/&gt; &lt;/bean&gt; &lt;!--配置Spring框架声明式事务管理--&gt; &lt;!--1. 配置事务管理器--&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;/bean&gt; &lt;!-- 2. 配置事务属性 --&gt; &lt;!--&lt;tx:advice&gt;元素声明事务通知--&gt; &lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt; &lt;tx:attributes&gt; &lt;!-- 根据方法名指定事务的属性 --&gt; &lt;tx:method name=\"*\"/&gt; &lt;!--propagation配置事务传播行为--&gt; &lt;tx:method name=\"purchase\" propagation=\"REQUIRES_NEW\"/&gt; &lt;!--isolation配置事务的隔离级别--&gt; &lt;tx:method name=\"update*\" isolation=\"SERIALIZABLE\"/&gt; &lt;!--rollback-for配置事务遇到异常必须回滚，no-rollback-for配置事务遇到异常必须不能回滚--&gt; &lt;tx:method name=\"add*\" rollback-for=\"java.io.IOException\" no-rollback-for=\"com.dmsd.spring.tx.BookStockException\"/&gt; &lt;!--read-only配置事务只读属性--&gt; &lt;tx:method name=\"find*\" read-only=\"true\"/&gt; &lt;!--timeout配置事务的超时属性--&gt; &lt;tx:method name=\"get*\" timeout=\"3\"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 3. 配置事务切入点, 以及把事务切入点和事务属性关联起来 --&gt; &lt;aop:config&gt; &lt;aop:pointcut expression=\"execution(* cn.itcast.service.*.*(..))\" id=\"txPointCut\"/&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"txPointCut\"/&gt; &lt;/aop:config&gt;&lt;/beans&gt; 配置 springmvc.xml (SpringMVC配置文件) 1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;!--开启注解扫描--&gt; &lt;context:component-scan base-package=\"cn.itcast\"&gt; &lt;context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/&gt; &lt;/context:component-scan&gt; &lt;!-- 配置视图解析器--&gt; &lt;bean id=\"internalResourceViewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/pages/\"/&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt; &lt;!-- 过滤静态资源--&gt; &lt;mvc:resources location=\"/css/\" mapping=\"/css/**\"/&gt; &lt;mvc:resources location=\"/images/\" mapping=\"/images/**\"/&gt; &lt;mvc:resources location=\"/js/\" mapping=\"/js/**\"/&gt; &lt;!-- 开启springmvc注解支持--&gt; &lt;mvc:annotation-driven/&gt;&lt;/beans&gt; 创建JSP页面 index.jsp 12345678910111213141516171819202122&lt;%-- Created by IntelliJ IDEA. User: sxl Date: 2020/5/30 Time: 22:05 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;a href=\"account/findAll\"&gt;测试&lt;/a&gt;&lt;h3&gt;测试保存&lt;/h3&gt;&lt;form action=\"/account/save\" method=\"post\"&gt; 姓名：&lt;input type=\"text\" name=\"name\"/&gt;&lt;br&gt; 金额：&lt;input type=\"text\" name=\"money\"/&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"保存\"&gt;&lt;br&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; list.jsp 1234567891011121314151617181920&lt;%-- Created by IntelliJ IDEA. User: sxl Date: 2020/5/30 Time: 22:07 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" isELIgnored=\"false\" %&gt;&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;查询所有账户信息&lt;/h3&gt; &lt;c:forEach items=\"${list}\" var=\"account\"&gt; ${account.name} &lt;/c:forEach&gt;&lt;/body&gt;&lt;/html&gt; 配置 Tomcat 服务器，配置如下图所示： 配置完成后目录结构如下图所示： 启动服务器，测试查询和保存功能，页面显示出 数据库中用户信息则证明整合成功。","link":"/2020/06/01/Spring%E6%A1%86%E6%9E%B6/Spring+SpringMVC+MyBatis%E6%95%B4%E5%90%88/"},{"title":"Linux&#x2F;MySQL安装","text":"本文将介绍MySQL8.0在Centos 7下的安装使用。 安装MySQL 将自带的MySQL数据删除干净 查看是否安装过MySQL 1rpm -qa | grep -i mysql 删除MySQL 1yum -y remove MySQL-* 找出所有的目录使用rm -rf命令删除 1find / -name mysql 删除my.cnf配置文件 1rm -rf /etc/my.cnf 删除MySQL默认密码 1rm -rf /root/.mysql_sercret 配置MySQL安装源 1sudo rpm -Uvh https://dev.mysql.com/get/mysql80-community-release-el7-3.noarch.rpm 安装MySQL 8.0 1sudo yum --enablerepo=mysql80-community install mysql-community-server 配置MySQL 启动MySQL服务 1systemctl start mysqld.service 查看MySQL运行状态 1systemctl status mysqld.service 通过vim /etc/my.cnf修改字符集配置，在[mysqld]节点下添加，并保存退出 12default-character-set=utf8character-set-server=utf8 开放3306端口，并重启防火墙 12firewall-cmd --zone=public --add-port=3306/tcp --permanentfirewall-cmd --reload 查看root临时密码 1grep \"A temporary password\" /var/log/mysqld.log 更改临时密码 1ALTER USER 'root'@'localhost' IDENTIFIED BY 'new password'; 使用select user,host from mysql.user;查看是否有匿名用户，使用delete from mysql.user where user='';删除所有的匿名用户 插入新用户，为新用户赋予所有权限 12CREATE USER myuser IDENTIFIED BY 'mypass';grant all privileges on databasename.tablename to 'user'@'host'； 创建新的数据库 1create database `mmall` default character set utf8 collate utf8_general_ci; 给账号开通所有外网权限 1grant all privileges on mmall.* to 'myuser'@'%'; 使用Navicat就可以进行远程连接了 ​ ​","link":"/2020/07/21/Linux/MySQL%E5%AE%89%E8%A3%85/"},{"title":"Linux&#x2F;Git安装","text":"本文将介绍Git在Centos 7下的安装使用。 安装Git 去Git下载页面下载对应版本的Git 执行yum -y install zlib-devel openssl-devel cpio expat-devel gettext-devel curl-devel perl-ExtUtils-CBuilder perl-ExtUtils-MakeMaker安装所需要的依赖 使用tar -zxvf git-2.9.5.tar.gz命令解压缩 使用make prefix=/usr/local all、make prefix=/usr/local install进行编译 使用git --vserion验证安装是否成功 ​ 基础配置 配置用户名 1git config --global user.name \"yourname\" 配置邮箱 1config --global user.email \"youemail@xxxx.com\" 忽略换行符转换 1git config --global core.autocrlf false 避免git gui中的中文乱码 1git config --global gui.encoding utf-8 避免git status显示的中文文件名乱码 1git config --global core.quotepath off git ssh key pair配置 12ssh-keygen -t rsa -C \"youemail@xxxx.com\"ssh-add ~/.ssh/id_rsa 执行ssh-add ~/.ssh/id_rsa可能会报错，如下图所示，我们需要先执行 1eval `ssh-agent` 去gitee上添加公钥即可进行git clone操作","link":"/2020/07/21/Linux/Git%E5%AE%89%E8%A3%85/"},{"title":"Linux&#x2F;JDK安装","text":"本文将介绍JDK 1.8在Centos 7下的安装使用。 我们需要卸载干净Centos本身携带的OpenJDK，使用命令rpm -qa | grep jdk查看当前安装的JDK，如下图所示 ​ 使用yum remove+名称命令将其卸载干净。 我们在 Oracle官网下载Linux对应的JDK rpm包，Oracle官网 将我们下载好的安装包放在/opt目录下，使用chmod 777 jdk-8u261-linux-x64.rpm命令将所有权限全部打开，使用rpm -ivh jdk-8u261-linux-x64.rpm命令安装JDK， 进行环境变量的配置，使用vim /etc/proflie编辑配置文件，在最下面添加三句配置 1234#这里使用你的JDK安装路径，使用rpm安装默认安装在/user目录下 export JAVA_HOME=/usr/java/jdk1.8.0_261-amd64 export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt/jar:$JAVA_HOME/lib/tools/jarexport PATH=$PATH:$JAVA_HOME/bin 最后使用source /ect/profile命令更新配置文件，通过java -version命令可以看到JDK已经安装成功 ​","link":"/2020/07/15/Linux/JDK%E5%AE%89%E8%A3%85/"},{"title":"Linux&#x2F;Maven安装","text":"本文将介绍Maven3.6.3在Centos 7下的安装使用。 在Maven官网下载apache-maven-3.6.3-bin.tar.gz，并将压缩包上传到/opt目录下 使用tar -zxvf apache-maven-3.6.3-bin.tar.gz命令解压缩文件 使用vim /etc/profile配置环境变量，在profile配置文件中添加如下语句： 12#Maven环境变量配置export MAVEN_HOME=/opt/apache-maven-3.6.3 #该路径为安装Maven路径 将$MAVEN_HOME/bin添加到PATH中 1export PATH=$PATH:$JAVA_HOME/bin:$MAVEN_HOME/bin 使用 source /etc/profile生效 使用mvn -version查看配置生效，配置成功后如下图所示","link":"/2020/07/15/Linux/Maven%E5%AE%89%E8%A3%85/"},{"title":"Linux&#x2F;vsftpd安装","text":"本文将介绍vsftp 3.0.2在Centos 7下的安装使用。 安装vsftp 使用yum -y install vsftpd安装vsftpd 默认配置文件在/etc/vsftpd/vsftpd.conf 创建虚拟用户 使用mkdir ftpfile创建用户文件夹(上传文件夹) 添加匿名用户：useradd ftpuser -d /ftpfile -s /sbin/nologin 修改ftpfile权限：chown -R ftpuser.ftpuser /ftpfile 重设ftpuser密码：passwd ftpuser 配置vsftpd 进入vsftpd根目录cd /etc/vsftpd 编辑配置文件vim vsftpd.conf 12345678ftpd_banner=Welcome to mmall FTP service.local_root=/ftpfileuse_localtime=yeschroot_list_enable=YESchroot_list_file=/etc/vsftpd/chroot_listanonymous_enable=NOpasv_min_port=61001pasv_max_port=62000 创建chroot_list文件，输入ftpuser 使用vim /etc/selinux/config，修改如下配置 1SELINUX=disabled 使用firewall-cmd --zone=public --add-port=61001-62000/tcp --permanent开启防火墙端口 打开ftp://192.168.111.105，输入用户名密码就可以访问了 注意：这里很可能会出现输入了正确的用户名和密码后，循环登录的问题。这个问题网上众说纷纭，但是我遇到的问题是这样的，我们进入user_list文件，如下图所示， ​ 可以看到，userlist_deny默认设置为YES，也就是说，不允许该文件里面的用户访问，我们只要删除ftpuser就可以正常访问了。 ​","link":"/2020/07/16/Linux/vsftpd%E5%AE%89%E8%A3%85/"},{"title":"Linux&#x2F;Nginx安装","text":"本文将介绍Nginx1.18.0在Centos 7下的安装使用。 安装Nginx 在Nginx官网下载最新版本的Nginx1.18.0版本，并放在服务器的/opt目录下 使用yum install gcc命令安装gcc 使用yum install pcre-devel安装pcre-devel 使用yum install zlib zlib-devel安装zlib 使用yum install openssl openssl-devel安装openssl 使用tar -zxvf nginx-1.18.0.tar.gz解压缩 进入nginx目录执行./configure，完成后执行make命令，最后执行make install命令 配置Nginx 使用systemctl status firewalld.service查看防火墙运行状态 使用firewall-cmd --list-ports查看已经开放的端口 使用firewall-cmd --zone=public --add-port=80/tcp --permanent打开80端口 使用firewall-cmd --reload重启防火墙 进入/usr/local/nginx/conf，使用mkdir vhost创建vhost文件夹 使用vim nginx.conf进入配置文件添加include vhost/*.conf; 问题解决 出现503报错，这个问题是没有启动Tomcat，我们启动Tomcat后就可以解决 出现403报错，这个问题是权限不足，我们需要修改nginx.conf文件里面，将uer改为root，如下图所示：","link":"/2020/07/20/Linux/Nginx%E5%AE%89%E8%A3%85/"},{"title":"Linux&#x2F;配置静态IP","text":"由于近期学习docker，需要两台CentOS 7 虚拟机，由于刚配置好的虚拟机使用动态IP，是没有办法上网的，所以顺手写下配置静态IP的方法。 配置虚拟网络编辑器首先，我们在 VMware 的选项卡中找到 “编辑” -&gt; “虚拟网络编辑器”，在弹出的窗口中点击 “更改设置” 在该界面配置子网IP和子网掩码 在NAT设置中配置配置网关 IP 然后在 Windows 中 “网络与Internet” -&gt; “以太网” -&gt; “更改适配器选项” 中配置虚拟机网络 在属性中”网络”选项卡下双击IPv4协议，对 IP地址、子网掩码、和默认网关进行配置，这里的配置要和 VMware 中保持一致 最后，还有一步非常关键，就是将当前 Windows 环境下的网络适配器共享给虚拟机网络 至此，虚拟机网络配置已经完成了。 配置Linux网络IP和网关在 Linux 系统中，我们此时是无法上网的，如下图所示 首先，我们需要通过修改 ifcfg-ens33 来修改IP配置，使用vim /etc/sysconfig/network-scripts/ifcfg-ens33 来修改配置文件 这里需要改动的地方如下： BOOTPROTO = static ONBOOT = yes IPADDR = 192.168.111.102 GATEWAY = 192.168.111.2 DNS1 = 114.114.114.114 DNS2 = 8.8.8.8 修改完如下图所示 至此，静态IP配置已经完成。 配置主机名称使用hostname命令可以查看当前主机的主机名称 通过vim /etc/hostname来配置主机名称，这里配置为 docker1 通过vim /etc/hosts来添加所有主机名和IP地址 最后，我们进入C:\\Windows\\System32\\drivers\\etc路径来修改host文件 以上就是静态IP配置的全部内容，重启机器后，就可以正常访问网络了。","link":"/2020/06/29/Linux/%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP/"},{"title":"Linux&#x2F;Tomcat安装","text":"本文将介绍Tomcat9.0.37在Centos 7下的安装使用。 在Tomcat官网下载apache-tomcat-9.0.37.tar.gz压缩包，并上传到Centos /opt文件夹中 ​ 使用tar -zxvf apache-tomcat-9.0.37.tar.gz命令解压安装包 使用vim /etc/profile配置环境变量，并使用source /etc/profile命令使配置生效 12#Tomcat环境变量配置export CATALINA_HOME=/opt/apache-tomcat-9.0.37 #这里是你Tomcat解压缩路径 进入con文件夹，编辑server.xml配置UTF-8字符集，添加URIEncoding=&quot;UTF-8&quot; 123&lt;Connector port=\"8080\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\" URIEncoding=\"UTF-8\"/&gt; 验证Tomcat是否安装成功，进入Tomcat目录中的bin文件夹，执行命令./startup.sh ，执行成功如下图所示","link":"/2020/07/15/Linux/Tomcat%E5%AE%89%E8%A3%85/"},{"title":"图解机器学习&#x2F;第三章 最小二乘学习法","text":"最小二乘学习法&emsp;最小二乘学习法是对模型的输出$f_{\\theta}(x_i)$和训练集输出$\\lbrace y_i \\rbrace_{i=1}^n$的平方误差 J_{LS}(\\theta)=\\frac{1}{2}\\sum_{i=1}^n(f_{\\theta}(x_i) - y_i)^2为最小时的参数$\\theta$进行学习 \\hat{\\theta}_{LS}=\\mathop{argmin}_{\\theta} J_{LS}(\\theta)平方误差$(f_{\\theta}(x_i)-y_i)^2$是残差$f_{\\theta}(x_i) - y_i$的$\\mathcal{l}_2$范数，因此最小二乘学习法有时也称为$\\mathcal{l}_2$损失最小化学习法。 &emsp;如果使用线性模型 f_{\\theta}(x_i)=\\sum_{j=1}^b \\theta_i \\phi_i (x)=\\theta^{\\intercal}\\phi(x)训练样本的平方差 J_{LS}(\\theta)=\\frac{1}{2}||\\Phi \\theta - y||^2其中，$y=(y_1,\\dots,y_n)^{\\intercal}$是训练输出的$n$维向量，$\\Phi$是下式中定义的$n\\times b$阶矩阵，也称为设计矩阵 \\Phi=\\left[ \\begin{matrix} \\phi_1(x_1) & \\cdots & \\phi_b(x_1) \\\\ \\vdots & \\ddots & \\vdots \\\\ \\phi_1(x_n) & \\cdots & \\phi_b(x_n) \\\\ \\end{matrix} \\right]训练样本的平方差$J_{LS}$的参数向量$\\theta$的偏微分 \\nabla_{\\theta}J_{LS}=(\\frac{\\partial J_{LS}}{\\partial \\theta_1},\\dots,\\frac{\\partial J_{LS}}{\\partial \\theta_b})^{\\intercal} = \\Phi^{\\intercal}\\Phi \\theta - \\Phi^{\\intercal}y将其微分设置为0，则 \\hat{\\theta}_{LS} = (\\Phi^{\\intercal}\\Phi)^{-1}\\Phi^{\\intercal}y对顺序为$i$的训练样本的平方差通过权重$\\omega_i \\ge 0$进行加权，然后采用最小二乘学习，这称为加权最小二乘学习法 \\mathop{min}_{\\theta} \\frac{1}{2}\\sum_{i=1}^n \\omega_i (f_{\\theta}(x_i)-y_i)^2 最小二乘解的性质&emsp;设计矩阵$\\Phi$的奇异值分解 \\Phi = \\sum_{k=1}^{min(n,b)} \\kappa_k \\psi_k \\varphi_k^{\\intercal}$\\kappa_k、\\psi_k、\\varphi_k$分别称为奇异值、左奇异向量、右奇异向量。奇异值全部是非负的，奇异向量满足正交性。 线性模型的最小二乘学习法中，训练输出向量$y$是由$\\Phi$的值域$\\mathcal{R}(\\Phi)$的正投影得到的。 大规模数据的学习算法&emsp;随机梯度算法是指，沿着训练平方误差$J_{LS}$梯度下降，对参数$\\theta$依次进行学习的算法。 凸函数 对于任意的两点$\\theta_1、\\theta2$和任意的$t\\in [0,1]$ J(t\\theta_1 + (1-t)\\theta_2) \\le tJ(\\theta_1) + (1-t)J(\\theta_2)凸函数是只有一个峰值的函数，所以通过梯度法就可以得到训练平方误差$J_{LS}$在值域范围内的最优解，即全局最优解。 使用随机梯度算法对线性模型进行最小二乘学习算法 给$\\theta$以适当的初值 随机选择一个训练样本 对于选定的训练样本，采用使其梯度下降的方式，对参数$\\theta$进行更新 \\theta \\leftarrow \\theta- \\epsilon \\nabla J_{LS}^{(i)}(\\theta)在这里，$\\epsilon$是名为学习系数的正标量，表示梯度下降的步幅。$\\nabla J_{LS}^{(i)}(\\theta)$是顺序为$i$的训练样本相对应的训练平方误差的梯度，表示梯度下降的方向。 \\nabla J_{LS}^{(i)}(\\theta)=\\phi(x_i)(f_{\\theta}(x_i)-y_i) 直到解$\\theta$达到收敛精度为止，重复上述2、3步的计算。","link":"/2020/05/09/%E5%9B%BE%E8%A7%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E5%AD%A6%E4%B9%A0%E6%B3%95/"},{"title":"图解机器学习&#x2F;第一章 什么是机器学习","text":"学习的种类 监督学习 是指学生从老师那里获取知识、信息，老师提供对错指示、告知最终答案的学习过程。这一类机器学习的典型任务包括：预测数值型数据的回归、预测分类标签的分类、预测顺序的排序等。 无监督学习 是指在没有老师的情况下，学生自学的过程。这一类机器学习的典型任务包括：聚类、异常检测等。 强化学习 是指在没有老师提示的情况下，自己对预测的结果进行评估的方法。这一类机器学习的典型任务包括：回归、分类、聚类和降维等。 机器学习任务的例子 回归（连续） 是指把实函数在样本点附近加以近似的有监督的函数近似问题。 分类（离散） 是指对于指定的模式进行识别的有监督的模式识别问题。 异常检测 是指寻找输入样本$\\lbrace x_i \\rbrace_{i=1}^n$中所包含的异常数据的问题。在已知正常数据与异常数据的例子的情况下， 其与有监督的分类问题是相同的。 聚类 与分类问题相同，也是模式识别问题，但是属于无监督学习的一种。 降维 是指从高纬度数据中提取关键信息，将其转换为易于计算的低纬度问题进而求解的方法。降维根据数据种类的不同，可以分为监督学习和无监督学习。 机器学习的方法生成的分类和识别的分类&emsp;在已知模式$x$的时候，如果能求得使分类类别$y$的条件概率$p(y|x)$达到最大值的类别$\\hat{y}$的话，就可以进行模式识别了。 \\hat{y}=\\mathop{argmax}_y p(y|x)其中，$”argmax”$是取得最大值时的参数的意思，条件概率$p(y|x)$通常也称为后验概率，联合概率$p(x,y)$也称为数据生成概率，通过预测数据生成概率$p(x,y)$来进行模式识别的分类方法，称为生成的分类。 &emsp;应用训练集直接对后验概率$p(y|x)$进行学习的过程，称为判别式分类 统计概率和朴素贝叶斯&emsp;在统计概率的机器学习方法中，将模式$\\theta$作为决定论的变量，使用手头的训练样本$\\mathcal{D}=\\lbrace (x_i,y_i) \\rbrace_{i=1}^n$对模式$\\theta$进行学习，如何由训练集$\\mathcal{D}$得到高精度的模式$\\theta$是主要的研究课题。 &emsp;在朴素贝叶斯方法中，将模式$\\theta$作为概率变量，对其先验概率$p(\\theta)$加以考虑，计算与训练集$\\mathcal{D}$相对应的后验概率$p(\\theta|\\mathcal{D})$。通过运用贝叶斯定理，就可以使用先验概率$p(\\theta)$来求解后验概率$p(\\theta|\\mathcal{D})$，如下所示： p(\\theta|\\mathcal{D}) = \\frac{p(\\mathcal{D}|\\theta) p(\\theta)}{p(\\mathcal{D})}=\\frac{\\prod_{i=1}^n q(x_i,y_i|\\theta)p(\\theta)}{\\int \\prod_{i=1}^n q(x_i,y_i|\\theta)p(\\theta) d\\theta}在朴素贝叶斯算法中，如何精确的计算后验概率是一个主要的研究课题。","link":"/2020/05/09/%E5%9B%BE%E8%A7%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"title":"图解机器学习&#x2F;第七章 基于最小二乘法的分类","text":"模式识别是指，对于输入的模式$x \\in \\mathbb{R}^d$，将其分类到它所属的类别$y \\in \\lbrace 1,\\dots,c \\rbrace$的方法，$c$表示的是类别的数目。 最小二乘分类&emsp;测试模式$x$所对应的类别$y$的预测值$\\hat{y}$，是由学习后的输出结果的符号决定的 \\hat{y}=sign(f_{\\hat{\\theta}}(x))= \\begin{cases} +1, &(f_{\\hat{\\theta}}>0) \\\\0,&(f_{\\hat{\\theta}}=0) \\\\-1,&(f_{\\hat{\\theta}}","link":"/2020/07/30/%E5%9B%BE%E8%A7%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E5%9F%BA%E4%BA%8E%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95%E7%9A%84%E5%88%86%E7%B1%BB/"},{"title":"图解机器学习&#x2F;第九章 集成分类","text":"集成学习，是指把性能较低的多种弱学习器，通过适当组合而形成高性能的强学习器的方法。本章有介绍两种集成学习法，一种是对多个弱学习器独立进行学习的Bagging学习法，一种是对多个弱学习器依次进行学习的Boosting学习法。 剪枝分类剪枝分类是属于弱学习器的一种单纯分类器。是指对于$d$次维的输入变量$x=(x^{(1)},\\dots,x^{(d)})^{\\intercal}$，任意选定其中的一维，通过将其值与给定的阈值相比较来进行分类的线性分类器。即以输入空间内的坐标轴与超平面进行正交的方式对模式进行分类。 剪枝分类器的自由度很低，但是具有计算成本低的优点。 Bagging学习法统计学上的Bootstrap一般称为自助法，是指从$n$个训练样本$\\lbrace (x_i,y_i) \\rbrace_{i=1}^n$中随机选取$n$个，允许重复，生成与原始的训练样本集有些许差异的样本集的方法。 在Bagging学习中，首先经由自助法生成虚拟的训练样本，并对这些样本进行学习。然后，反复重复这一过程，对得到的多个分类器的输出求平均值。通过上述方法，就可以从大量略有不同的训练样本集合，得到多个稍微不同的弱分类器，然后再对这些分类器加以统合，就可以得到稳定、可靠的强分类器。 一般而言，像剪枝分类器这样非常单一的弱分类器，对其进行集成学习很少会发生过拟合现象，因此将Bagging学习的重复次数设置为较大的值是比较好的选择。在这种情况下，因为多个弱分类器的学习是个并行的过程，因此使用多台计算机并行处理，会使计算效率得到巨大的提升。 Bagging学习算法： 对$j=1,\\dots,b$重复进行如下计算 从$n$个训练样本$\\lbrace (x_i,y_i) \\rbrace_{i=1}^n$中随机选取$n$个，允许重复，生成若干个与原始的训练样本集有些许差异的新样本集。 使用上述得到的样本集求得弱学习器$\\varphi_j$ 对所有的弱学习器$\\lbrace \\varphi_j \\rbrace_{j=1}^b$，求平均值，得到一个强学习器$f$ f(x) \\leftarrow \\frac{1}{b}\\sum_{j=1}^b \\varphi_j(x) 剪枝分类器不断地生长、积累，形成多层级的模型，该模型就称为决策树分类器。对决策树分类器进行Bagging学习的时候，通过随机选择输入变量中的某个维度进行学习，可以大幅提高分类器的性能，这种手法也称为随机森林学习。 Boosting学习法AdaboostBoosting学习，首先使用一个原始的学习算法，对训练样本 \\lbrace (x_i,y_i)| x_i \\in \\mathbb{R}^d,y_i \\in \\lbrace +1,-1 \\rbrace \\rbrace_{i=1}^n进行普通分类器的学习。如果原始算法的学习性能不高，就不能对所有的训练样本进行正确的分类。因此，对于不能正确分类的困难样本就加大其权重（反之，对于能正确分类的简单样本则减少其权重），再重新进行学习。然后，再循环多次进行加权学习，慢慢地就可以对所有的训练样本都进行正确的分类了。然而另一方面，在进行加权的过程中，最开始就能够正确分类的样本的权重会慢慢变小，有可能造成简单的样本反而不能正确分类的情况。 因此，Boosting学习应该边学习边更新样本的权重，并把学习过程中得到的所有分类器放在一起，对其可信度进行平均后训练得到最终的强分类器。 样本的加权方法多种多样，最为标准的就是Adaboost算法 Adaboost学习算法： 把训练样本$\\lbrace (x_i,y_i) \\rbrace_{i=1}^n$对应的各个权重$\\lbrace \\omega_i \\rbrace_{i=1}^n$设置为均等，即1/n，并把强分类器$f$的初始值设为零 \\omega_1,\\dots,\\omega_n \\leftarrow 1/n, f\\leftarrow0 对$j=1,\\dots,b$重复进行如下计算 对于现在的样本权重$\\lbrace \\omega_i \\rbrace_{i=1}^n$，对加权的误分类率（0/1损失的权重之和）$R(\\varphi)$为最小的弱分类器$\\varphi_j$进行学习 \\varphi_j = \\mathop{argmin}_{\\varphi}R(\\varphi),R(\\varphi)=\\sum_{i=1}^n \\frac{\\omega_i}{2}(1-\\varphi(x_i)y_i) 通过下式 定义弱分类器$\\varphi_i$的权重$\\theta_j$由下 \\theta_j = \\frac{1}{2}log\\frac{1-R(\\varphi_j)}{R(\\varphi_j)} 通过下式更新强分类器$f$ f \\leftarrow f+ \\theta_j \\varphi_j 通过下式更新样本权重$\\lbrace \\omega_i \\rbrace_{i=1}^n$ \\omega_i \\leftarrow \\frac{exp(-f(x_i)y_i)}{\\sum_{i'=1}^n exp(-f(x_{i'})y_i)},\\forall i=1,\\dots,n ​","link":"/2020/05/09/%E5%9B%BE%E8%A7%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E9%9B%86%E6%88%90%E5%88%86%E7%B1%BB/"},{"title":"图解机器学习&#x2F;第二章 学习模型","text":"线性模型&emsp;在对函数$f$进行近似时，最简单的模型就是线性模型$\\theta \\times x$。$\\theta$表示模型的参数，通过对参数进行学习，完成函数的近似计算。在实际应用中，经常会对线性模型进行扩展，使其变成基于参数的线性模型： f_{\\theta}(x)=\\sum_{j=1}^b \\theta_j \\phi_j(x)=\\theta^{\\intercal}\\phi(x)&emsp;乘法模型是指，把一维基函数作为因子，通过使其相乘而获得多维基函数的方法： f_{\\theta}(x)=\\sum_{j_1=1}^{b'} \\dots \\sum_{j_d=1}^{b'} \\theta_{j1,\\dots,j_d}\\phi_{j1}(x^{(1)} \\dots\\phi_{jd}(x^{(d)})) 由于乘法模型随着维数的增加，计算量呈指数级增长的现象，称为维数灾难。 &emsp;加法模型是指，把一维的基函数作为因子，通过使其相加而获得多维基函数的方法： f_{\\theta}(x)=\\sum_{k=1}^d \\sum_{j=1}^{b'} \\theta_{k,j} \\phi_j(x^{(k)}) 加法模型只会随着输入维数线性增长，但是，由于加法模型只考虑了一维基函数相加的情况，因此表现力要比乘法模型逊色许多。 核模型&emsp;核模型，是以使用被称为核函数的二元函数$K(.,.)$，以$K(x,x_j)_{j=1}^n$的线性结合方式加以定义的 f_{\\theta}(x)=\\sum_{j=1}^n \\theta_j K(x,x_j)在众多核函数中，以高斯核函数的使用最为广泛 K(x,c)=exp(-\\frac{||x-c||^2}{2h^2})在上式中，$||\\cdot||$表示2范数，即$||x||=\\sqrt{x^{\\intercal}x}$。$h$和$c$分别对应于高斯核函数的带宽和均值。 由于只能在训练集的输入样本附近对函数进行近似，所以从某种程度上来说也减轻了维数灾难的影响。 &emsp;在核模型里，参数的个数不依赖于输入变量$x$的维数$d$，只由训练样本数$n$决定。在统计学中，通常把与基于参数的线性模型称为参数模型，把核模型称为非参数模型。 &emsp;核模型的另一个特征是：当输入样本$x$不是向量的时候，也能很容易实现扩展。目前已经有人提出了输入样本$x$是字符串、决策树或图表等的核函数，这样的核函数进行的机器学习算法，称为核映射方法。 层级模型&emsp;层级模型是非线性模型。","link":"/2020/05/09/%E5%9B%BE%E8%A7%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B/"},{"title":"图解机器学习&#x2F;第五章 稀疏学习","text":"$l_1$约束的最小二乘学习法 \\mathop{min}_{\\theta}J_{LS}(\\theta) \\quad 约束条件 \\quad ||\\theta||_1 \\le R \\\\ ||\\theta||_1 = \\sum_{j=1}^b|\\theta_j|&emsp;$l_1$约束的最小二乘学习法，在有些著作中也成为Lasso回归。 $l_1$约束的最小二乘学习的求解方法&emsp;因为$l_1$范数中包含在原点处不能微分的绝对值，因此不能像$l_2$约束那样简单地进行求解。近年来产生了许多求解$l_1$约束的最小二乘学习法的算法，特别是当参数b使非常大的数值的时候，$l_1$约束的最小二乘学习法可以获得比$l_2$约束的最小二乘学习法更高的求解速度。 &emsp;使用由$l_1$约束的上限$R$决定的拉格朗日乘子$\\lambda$，来考虑最优化问题： \\mathop{min}_{\\theta}J(\\theta),J(\\theta)=J_{LS}(\\theta)+\\lambda||\\theta||_1另外，对于$l_1$范数中包含的不能进行微分的绝对值函数，使用可以微分的二次函数进行控制 |\\theta_j| \\le \\frac{\\theta_j^2}{2c_j} + \\frac{c_j}{2}对于c_j >0上述的二次函数就是该绝对值函数的上界，与绝对值函数在点$\\theta_j = ±c_j$处相切。 &emsp;通过反复迭代来对其进行求解，可以用现在的解$|\\tilde{\\theta_j}| \\not= 0$来替换$c_j$，以构成上界约束 |\\theta_j| \\le \\frac{\\theta_j^2}{2|\\tilde{\\theta_j}|} + \\frac{|\\tilde{\\theta_j}|}{2}据此可以得到$l_2$正则化最小二乘学习法的一般表达式 \\hat{\\theta}=\\mathop{argmin}_{\\theta} \\tilde{J}(\\theta),\\tilde{J}(\\theta) = J_{LS}(\\theta)+ \\frac{\\lambda}{2}\\theta^{\\intercal}\\tilde{\\Theta}^{\\dagger}\\theta+C上式中，$\\tilde{\\Theta}$是对角元素为$|\\tilde{\\theta_1}|,\\dots,|\\tilde{\\theta_b}|$的对角矩阵，$C=\\sum_{j=1}^b|\\tilde{\\theta_1}|/2$是不依赖于$\\theta$的常数。 使用一般$l_2$约束的最小二乘学习法求解$l_1$约束的最小二乘学习法的迭代方法 给初始值$\\theta$以适当的值 通过现在的解$\\theta$来计算矩阵$\\Theta$ \\Theta \\leftarrow diag(|\\theta_1|,\\dots,|\\theta_b|)其中，$diag(a,b,\\dots,c)$是以$a,b,\\dots,c$为对角元素的对角矩阵 使用矩阵$\\Theta$来计算解$\\theta$ \\theta \\leftarrow (\\Phi^{\\intercal}\\Phi+\\lambda\\Theta^{\\dagger})^{-1}\\Theta^{\\intercal}y 直到解$\\theta$达到收敛精度为止，重复上述2、3步的计算 通过稀疏学习进行特征选择&emsp;使用$l_1$约束的稀疏学习进行特征选择，可以在一定程度上考虑到各个特征之间的相互联系。 $l_p$约束的最小二乘学习法&emsp;$p \\ge 0$的$l_p$范数的约束方法 ||\\theta||_p = (\\sum_{j=1}^b|\\theta_j|^p)^{\\frac{1}{p}} \\le R但是，当$p=\\infty$的时候 ||\\theta||_{\\infty} = max \\lbrace|\\theta_1|,\\dots,|\\theta_b| \\rbrace因此，$l_{\\infty}$范数表示的是向量元素绝对值中的最大值，$l_{\\infty}$范数也成为最大值范数。$l_0$范数表示的是非零的向量元素个数。 在坐标轴上呈有峰值的尖形是存在稀疏解的秘诀，满足约束条件的空间如果不是凸形的话，可能存在局部最优解。当$p=1$时，稀疏解存在唯一的凸形，由此可知，$l_1$约束的最小二乘学习法是非常特殊的一种学习方法。 $l_1+l_2$约束的最小二乘学习法&emsp;通过利用$l_1+l_2$范数的凸结合来进行约束 (1-\\tau)||\\theta||_1 + \\tau||\\theta||^2 \\le R&emsp;$l_1+l_2$约束的最小二乘学习法，也成为弹性网回归学习法。","link":"/2020/05/09/%E5%9B%BE%E8%A7%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E7%A8%80%E7%96%8F%E5%AD%A6%E4%B9%A0/"},{"title":"图解机器学习&#x2F;第八章 支持向量机分类","text":"间隔最大化分类从线性2类别分类问题说明 f_{\\omega,\\gamma}(x) = \\omega^{\\intercal}x+\\gamma上式中的$\\omega$为把正负样本分割开的超平面的法线，$\\gamma$为截距。只要能够对各个训练样本的间隔$m_i=f_{\\omega,\\gamma}(x_i)y_i$为正时的$\\omega$和$\\gamma$进行学习，就可以利用这个模型对所有的训练样本进行正确的分类。 当存在满足条件的$\\omega$和$\\gamma$，使得$(\\omega^{\\intercal}x+\\gamma)y_i \\ge1 \\quad \\forall i=1,\\dots,n$，称这样的训练样本为线性可分的样本，一般选取能够最充裕地把正样本和负样本进行分离的超平面作为最优解。“最充裕”是指与正则化后地间隔$m_i=(\\omega^{\\intercal}x+\\gamma)y_i/||\\omega||$地最大值对应的。从几何学上讲，间隔为两端的两个超平面$\\omega^{\\intercal}x+\\gamma=+1$和$\\omega^{\\intercal}x+\\gamma = -1$地间距的一半，使这个间隔最大的超平面对应的分类器，成为硬间隔支持向量机分类器。 软间隔支持向量机分类器的基本思路是，允许在间隔的计算中出现少许的误差$\\xi=(\\xi_1,\\dots,\\xi_n)^{\\intercal}$ 支持向量机分类器的求解方法支持向量机分类器的最优化问题，是目标函数为二次函数、约束条件为线性的典型的二次规划问题。 二次规划问题，始于矩阵$F、G$以及向量$f、g$相对应的由下式定义的最优化问题 \\mathop{min}_{\\theta}[\\frac{1}{2}\\theta^{\\intercal}F\\theta+f^{\\intercal}\\theta)] \\quad 约束条件 \\quad G\\theta \\le g这里把向量不等式$G\\theta \\le g$分解，表示为各个元素的不等式 \\tbinom{a}{b} \\le \\tbinom{c}{d} \\iff f(n)=\\begin{cases} a\\le c \\\\ b \\le d \\end{cases}假定矩阵$F$是正定值（即所有的固有值都为正），当条件不充分，数值不稳定时，为$F$的对角元素加上一个特别小的正值，从而使其稳定性得以提高。 稀疏性 Karush-Kuhn-Tucker最优化条件，经常简称为KKT条件 可微分的凸函数$f:\\mathbb{R}^d \\rightarrow \\mathbb{R}^p$的约束条件的最小化问题 \\mathop{min}_t f(t) \\quad 约束条件 \\quad g(t) \\le 0的解，满足如下的KKT最优化条件 \\frac{\\partial L}{\\partial t}=0,g(t)\\le0, \\lambda \\ge 0, \\lambda_{i}g_i(t)=0,\\forall i=1,\\dots,n在上式中，$L(t,\\lambda)=f(t)+\\lambda^{\\intercal}g(t)$为拉格朗日函数，$\\lambda=(\\lambda_1,\\dots,\\lambda_p)$为拉格朗日乘子。最后的条件式$\\lambda_{i}g_i(t)=0$，是指参数$\\lambda_i$和$g_i(t)$中至少一个为零，因此也将其称为互补性条件。 对偶变量和约束条件应该满足如下的互补条件 \\alpha_i (m_i-1+\\xi_i)=0,\\beta_i\\xi_i=0,\\forall i =1,\\dots,n当$\\alpha_i =0$时，训练样本$x_i$位于间隔边界上或边界内侧，可充裕地进行正确分类。当$0&lt;\\alpha_i &lt; C$的时候，$x_i$刚好位于间隔边界上，可正确分类。当$\\alpha_i =C$的时候，$x_i$位于间隔边界上或边界外侧，如果其间隔误差$\\xi_i$大于1，则间隔为负，训练样本$x_i$就不能得到正确的分类。另外，如果训练样本$x_i$位于间隔边界内侧，就有$\\alpha_i=0$如果位于间隔边界外侧，就有$\\alpha_i=C$。 与$0&lt;\\alpha_i &lt; C$相对应的训练样本$x_i$称为支持向量。 使用核映射的非线性模型首先使用非线性函数$\\psi$，对训练输入样本$\\lbrace x_i \\rbrace_{i=1}^n$的特征空间进行描述；然后，对特征空间内的训练输入样本$\\lbrace \\psi(x_i) \\rbrace_{i=1}^n$，适用线性的支持向量机分类器。通过这种方式得到的特征空间内的线性分类器， 在原始的输入空间是非线性分类器。 如果选择比原始的输入维数d维数更高的空间作为特征空间，则训练样本为线性可分的可能性就比较高。然而，如果特征空间的维数过大的话，计算时间也会相应的增加。 利用核映射求解支持向量机分类器的非线性模型。直接通过核函数$K(x,x’)$定义内积$\\langle \\psi(x), \\psi(x’) \\rangle$数，而不需要明确地知道特征变换$\\psi$是什么的方法，就称为核映射方法。如果核函数的值与特征空间的维数无关、相互独立，非线性支持向量机的全体学习时间就完全不依赖于特征空间的维数了，例如常用的多项式核函数以及高斯核函数。 核映射方法的另一个重要特征是，即使输入$x$不是向量，也可以正确地进行分类。 使用Hinge损失最小化学习来解释使用如下Hinge损失作为代理损失 max \\lbrace 0,1-m \\rbrace当$m \\ge 1$的时候，与0/1损失相同，其损失为0，当$m &lt; 1$的时候，其损失为$1-m &gt; 0$。当其损失为正的时候，与$m$相关的函数有倾向于负的趋势。 使用Ramp损失的鲁棒学习Hinge损失没有上界，因此当间隔比较大的负数值时，损失就会变得非常大。所以在训练样本中包含异常值的情况下，支持向量机分类器非常容易受影响。 Ramp损失： min \\lbrace 1,max(0,1-m) \\rbrace = \\begin{cases} 1 &\\text{(m1)} \\end{cases}Ramp损失是指，在Hinge损失的左侧以范围1做截断的损失。因为Ramp有损失边界，对异常值有非常强的鲁棒性，但是Ramp损失为非凸函数，很难求得最优解。","link":"/2020/07/30/%E5%9B%BE%E8%A7%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%E5%88%86%E7%B1%BB/"},{"title":"图解机器学习&#x2F;第六章 鲁棒学习","text":"最小二乘学习法具有易受异常值影响的特点 在统计学领域和机器学习领域，对异常值也能保持稳定、可靠的性质，称为鲁棒性。 $l_1$损失最小化学习&emsp;对训练样本的合理性，一般使用$l_2$损失$J_{LS}(\\theta)$来测定 J_{LS}(\\theta)=\\frac{1}{2} \\sum_{i=1}^n r_i^2这里的$r_i$是顺序为$i$的训练样本所对应的残差 r_i = f_{\\theta}(x_i) -y_i&emsp;使用$l_1$损失对残差的增幅加以抑制的学习算法 \\hat{\\theta}_{LA} = \\mathop{argmin}_{\\theta}J_{LA}(\\theta), J_{LA}(\\theta)=\\sum_{i=1}^n|r_i|&emsp;对于常数模型$f_{\\theta}(x)=\\theta$，最小二乘学习的最终输出结果是训练样本输出值$\\lbrace y_i \\rbrace _{i=1}^n$的平均值 \\hat{\\theta}_{LS}=\\mathop{argmin}_{\\theta}\\sum_{i=1}^n (\\theta-y_i)^2 = mean(\\lbrace y_i \\rbrace _{i=1}^n)&emsp;最小绝对值偏差学习的最终输出结果则是训练样本输出值$\\lbrace y_i \\rbrace _{i=1}^n$的中间值 \\hat{\\theta}_{LA}=\\mathop{argmin}_{\\theta}\\sum_{i=1}^n |\\theta-y_i| = median(\\lbrace y_i \\rbrace _{i=1}^n) Huber损失最小化学习&emsp;Huber损失混合使用了$l_2$损失和$l_1$损失 \\rho Huber(r)=\\begin{cases} r^2 /2,&\\text{|r| $\\le \\eta$}\\\\\\eta |r|- \\eta^2/2,&\\text{|r| >$ \\eta$}\\end{cases} 如果残差的绝对值$|r|$小于阈值$\\eta$的话，上式就变成了$l_2$损失；如果残差的绝对值$|r|$大于阈值$\\eta$的话，就变成了$l_1$损失，但是，为了与$l_2$损失平滑地连接，在$l_1$损失中减去了常数$\\eta^2/2$ 使用加权最小二乘学习法对Huber损失最小化学习进行反复迭代计算的方法 给$\\theta$以适当的初始值 通过现在的解$\\theta$来计算权重矩阵$W$ W \\leftarrow diag(\\omega_1,\\dots,\\omega_n),\\omega_i=\\begin{cases} 1,&\\text{ $|r_i|\\le \\eta$}\\\\\\eta/|r_i|,&\\text{$ |r_i| >\\eta$}\\end{cases}其中，$r_i=f_{\\theta}(x_i)-y_i$为残差 使用权重矩阵$W$来计算解$\\theta$ \\theta \\leftarrow(\\Phi^{\\intercal}W \\Phi)^{\\dagger}\\Phi^{\\intercal}Wy 直到解$\\theta$达到收敛精度为止，重复上述2、3步的计算 &emsp;将阈值$\\eta$设定为非常小的数值时，Huber损失可以认为是$l_1$损失的平滑近似。因此，可通过反复加权最小二乘学习法，对$l_1$损失最小二乘学习法进行近似的求解。 图基损失最小化学习&emsp;使用$l_1$损失对异常值进行处理，就会使得 异常值对结果的影响非常巨大，在实际应用中，Huber损失最小化学习的权重$\\tilde{\\omega}_i$即使对于大的残差也不会变为零。采用图基(Tukey)损失法可以解决上述问题。 \\rho Tukey(r)=\\begin{cases} (1-[1-r^2 /\\eta^2]^3)\\eta^2/6,&\\text{|r| $\\le \\eta$}\\\\\\eta^2/6,&\\text{|r| >$ \\eta$}\\end{cases}图基损失中，如果残差的绝对值$|r|$大于阈值$\\eta$的话，就以$\\eta^2/6$的形式输出，因此图基损失最小化学习一般具有非常高的鲁棒性。但是，因为图基损失并不是凸函数，一般拥有多个局部最优解，所以在整个值域范围内求得最优解非常困难。 &emsp;将以下权重应用到实际问题中就可以求出局部最优解 \\omega =\\begin{cases} (1-r^2 /\\eta^2)^2,&\\text{|r| $\\le \\eta$}\\\\ 0,&\\text{|r| >$ \\eta$}\\end{cases}当$|r|&gt;\\eta$的时候，权重完全变为零，因此图基损失最小化学习完全不受显著异常值的影响。 使用图基损失最小化学习可以得到鲁棒性更强的结果，但是数据中的噪声稍微发生变化都会产生其他的局部最优解。 $l_1$约束的Huber损失最小化学习 \\mathop{min}_{\\theta}\\sum_{i=1}^n \\rho Huber(r_i) \\quad 约束条件 \\quad ||\\theta||_1 \\le R $l_1$约束的Huber损失最小化学习的迭代解法 给$\\theta$以适当的初始值 通过现在的解$\\theta$来计算权重矩阵$W$和矩阵$\\Theta$ W \\leftarrow diag(\\omega_1,\\dots,\\omega_n),\\Theta \\leftarrow diag(|\\theta_1|,\\dots,|\\theta_b|)其中，权重$\\omega_i$使用残差$r_i=f_{\\theta}(x_i)-y_i$由下式加以定义 \\omega_i = \\begin{cases} 1, &\\text{($|r_i| \\le \\eta$)} \\\\ \\eta/|r_i|, &\\text{($|r_i|>\\eta$)} \\end{cases} 使用权重矩阵$W$和矩阵$\\Theta$来计算解$\\theta$ \\theta \\leftarrow (\\Phi^{\\intercal}W \\Phi + \\lambda \\Theta^{\\dagger})^{-1}\\Phi^{\\intercal}Wy 直到解$\\theta$达到收敛精度为止，重复上述2、3步的计算","link":"/2020/07/07/%E5%9B%BE%E8%A7%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E9%B2%81%E6%A3%92%E5%AD%A6%E4%B9%A0/"},{"title":"图解机器学习&#x2F;第十一章 序列数据的分类","text":"字符串的分类问题，比起将字符串拆分为独立的文字，并分别对各个文字进行识别，对字符串整体同时进行识别的话，因为能充分利用文字的前后关系，所以识别精度会更高。 序列数据的模型化将顺序为$k$的模式定义为$x^{(k)}$，该模式所属的类别定义为$y^{(k)}$，然后将这样的$m$个模式的序列分别用$\\overline{x}$和$\\overline{y}$进行表示 \\overline{x} = (x^{(1)}, \\dots, x^{(m)}), \\overline{y} = (y^{(1)}, \\dots,y^{(m)})如果对各个模式$x^{(k)}$进行独立的识别，那么$c$个类别的模式识别问题进行$m$次求解就可以完成对此模式序列的识别。然而，这样的识别方式并没有充分利用各个模式的前后关系。 在个模式的类别为$c$个的情况下，如果对连续的$m$个模式同时进行识别的话，就需要对$\\overline{c} = c^m$个类别的模式识别问题进行求解。然而，在这种方式中，由于类别个数$\\overline{c}$和参数$\\overline{\\theta}$的维度是以模式序列的长度$m$为基数呈指数级增长的，因此直接对其进行学习往往很困难。 假定只有前一个模式所属的类别$y^{(k-1)}$会对现在的模式$x^{(k)}$所属的类别$y^{(k)}$有影响，通过把连续的两个模式的识别加以组合，对模式序列全体进行识别。这样的方法，并不是简单地对连续的两种模式所对应的$c^2$个类别的识别问题进行单独求解，而是尽可能地对模式序列全体同时进行识别。这种方法称为条件随机场。 q(\\overline{y}|\\overline{x};\\zeta) = \\frac{exp(\\zeta^{\\intercal} \\varphi(\\overline{x},\\overline{y}))}{\\sum_{\\overline{y}'=1}^{\\overline{c}} exp(\\zeta^{\\intercal} \\varphi(\\overline{x},\\overline{y'}))}这里的$\\varphi(\\overline{x},\\overline{y})$表示的是基函数的向量。 条件随机场模型的学习 使用随机梯度算法的条件随机场的算法流程： 给$\\zeta$以适当的值 随机选择一个训练样本(假设选择了顺序为$i$的训练样本$(\\overline{x},\\overline{y})$) 对于选定的训练样本，以梯度上升的方向对参数$\\zeta$进行更新 \\zeta \\leftarrow \\zeta + \\epsilon(\\varphi(\\overline{x},\\overline{y}) - \\frac{ \\sum_{\\overline{y}=1}^{\\overline{c}_i} exp(\\zeta^{\\intercal} \\varphi(\\overline{x}_i,\\overline{y}))\\varphi(\\overline{x}_i,\\overline{y})}{\\sum_{\\overline{y}'=1}^{\\overline{c}_i} exp(\\zeta^{\\intercal} \\varphi(\\overline{x}_i,\\overline{y'}))})在这里，$\\epsilon$为表示梯度向上的幅度的正常数。$\\overline{c_i}=c^{m_i}$是长度为$m_i$的模式序列所对应的类别个数。 直到解$\\zeta$达到收敛精度为止，重复上述2、3步的计算","link":"/2020/05/09/%E5%9B%BE%E8%A7%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%20%E5%BA%8F%E5%88%97%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%86%E7%B1%BB/"},{"title":"图解机器学习&#x2F;第十七章 监督降维","text":"监督降维算法的目的，是通过将输入$x$变换为低维的$z$，使输出$y$的预测更加容易。假设输入样本$x$的维度为$d$，低纬度下的$z$的维度为$m$，$d\\times m$阶矩阵为$T$ z = Tx并预先对训练样本$\\lbrace (x_i) \\rbrace_{i=1}^n$进行中心化处理 x_i \\leftarrow x_i-\\frac{1}{n}\\sum_{i'=1}^n x_{i'}与分类问题相对应的判别分析Fisher判别分析Fisher判别分析，是寻找能够使相同类别的样本尽量靠近，不同类别的样本尽量远离的矩阵$T$的方法。 定义组内分散矩阵$S^{(w)}$和组间分散矩阵$S^{(b)}$ S^{(w)} = \\sum_{y=1}^c \\sum_{i:y_i = y}(x_i-\\mu_y)(x_i-\\mu_y)^{\\intercal} \\in \\mathbb{R}^{(d \\times d)}\\\\ S^{(b)}=\\sum_{y=1}^n n_y \\mu_y \\mu_y^{\\intercal} \\in \\mathbb{R}^{d \\times d}“w”和“b”分别是“within-class”和“between-class”的首字母。$\\sum_{i:y_i = y}$是所有满足$y_i = y$的$y$的和，$\\mu_y$是所有属于类别$y$的输入样本的平均值 \\mu_y = \\frac{1}{n_y}\\sum_{i:y_i = y}x_i$n_y$是属于类别$y$的训练样本总数。使用这样的分散矩阵，Fisher判别分析的投影矩阵可由下式定义 \\mathop{max}_{T\\in \\mathbb{R}^{m \\times d}} tr((TS^{(w)}T^{\\intercal})^{-1}TS^{(b)}T^{\\intercal}) Fisher判别分析，是通过使投影后的组间分散矩阵$TS^{(b)}T$变大，组内分散矩阵$TS^{(w)}T$变小，来决定矩阵$T$的*。 考虑对与矩阵对$(S^{(b)},S^{(w)})$相关的一般化特征值问题 S^{(b)}\\xi = \\lambda S^{(W)} \\xi与一般化特征值对应的一般化特征向量分别用$\\lambda_1 \\ge,\\dots,\\ge \\lambda_d \\ge 0$和$\\xi_1,\\dots,\\xi_d$来表示。这样，Fisher判别分析即可进行解析求解。 \\hat{T} = (\\xi_1,\\dots,\\xi_m)^{\\intercal}即Fisher判别分析的投影矩阵，是依据与矩阵对$(S^{(b)},S^{(w)})$的较大的$m$个一般化特征值相对应的一般化特征向量来确定的。 局部Fisher判别分析当某些类别的输入样本具有多峰值特性的时候，往往不能得到理想的结果。Fisher判别分析也会无视簇构造，强行把它们撮合为相同的类别，这样有时就不能得到理想的降维效果。 为了解决上述问题，局部Fisher判别分析使用如下的局部组内分散矩阵$S^{(lw)}$和局部组间分散矩阵$S^{(lb)}$ S^{(lw)}=\\frac{1}{2}\\sum_{i:i'=1}^n Q_{i:i'}^{(lw)}(x_i-x_{i'})(x_i-x_{i'})^{\\intercal} S^{(lb)}=\\frac{1}{2}\\sum_{i:i'=1}^n Q_{i:i'}^{(lb)}(x_i-x_{i'})(x_i-x_{i'})^{\\intercal}其中，$Q_{i:i’}^{(lw)}$和$Q_{i:i’}^{(lb)}$由下式定义 Q_{i:i'}^{(lw)}= \\begin{cases} W_{i,i'}/n_y &\\text{$(y_i=y_{i'}=y)$} \\\\ 0 &\\text{$(y_i \\not= y_{i'})$}\\end{cases} Q_{i:i'}^{(lb)}= \\begin{cases} W_{i,i'}(1/n-1/n_y) &\\text{$(y_i=y_{i'}=y)$} \\\\ 1/n &\\text{$(y_i \\not= y_{i'})$}\\end{cases}其中$0 \\le W_{i,i’} \\le 1$为训练样本$x_i$和$x_{i’}$的相似度。通过这样的方法，对于属于相同类别但不相似的样本，强行把他们撮合为相同类别的能力就会变弱，簇构造就可以得到保护。 局部Fisher判别分析的投影矩阵可由下式进行定义 \\mathop{max}_{T\\in \\mathbb{R}^{m \\times d}} tr((TS^{(lw)}T^{\\intercal})^{-1}TS^{(lb)}T^{\\intercal})上式与原始Fisher判别分析形式完全一致，故对局部Fisher判别分析求解 \\hat{T} = (\\xi_1,\\dots,\\xi_m)^{\\intercal}半监督局部Fisher判别分析半监督局部Fisher判别分析，是把无监督的降维方法中的主成分分析法和局部Fisher判别分析法组合起来进行学习的一种方法。主成分分析的解，对应的是分散矩阵 S^{(t)} = \\sum_{i=1}^{n+n'} (x_i-\\mu^{(t)})(x_i-\\mu^{(t)})^{\\intercal},\\mu^{(t)}=\\frac{1}{n+n'}\\sum_{i=1}^{n+n'}x_i的较大的特征值所对应的特征向量。其中$\\mu^{(t)}$表示的是全部输入样本$\\lbrace x_i \\rbrace_{i=n+1}^{n+n’}$的平均值。 半监督局部Fisher判别分析将对特征值问题加以组合，具体而言就是采用半监督分散矩阵 S^{(slw)}=(1-\\beta)S^{(lw)}+\\beta S^{(t)},S^{(slb)}=(1-\\beta)S^{(lb)}+\\beta I半监督局部Fisher判别分析的解$\\hat{T}$，可以使用与一般化特征值问题 S^{(slb)}\\xi = \\lambda S^{(slw)} \\xi的一般化特征值$\\lambda_1 \\ge,\\dots,\\ge \\lambda_d \\ge 0$和对应的一般化特征向量$\\xi_1,\\dots,\\xi_d$进行解析求解 \\hat{T} = (\\xi_1,\\dots,\\xi_m)^{\\intercal}这个解在$\\beta =0$的时候与局部Fisher判别分析的解一致，在$\\beta = 1$的时候与主成分分析的解一致。 充分降维充分降维是一种适用于回归问题的监督降维算法，主要着眼于输入和输出的依赖关系。就是在给定投影后的数据$z=Tx$的时候，使原始的输入$x$和输出$y$条件独立，以此来确定投影矩阵$T$ p(x,y|z)=p(x|z)p(y|z)在给定$z$之后，$x$和$y$在统计上是相互独立的，$y$中包含的所有信息在$z$中均可以找到。这种条件独立性，是通过确定$z=Tx$和$y$最相互依存时对应的矩阵$T$来实现的。通过引入平方损失互信息，来确定下式为最大值时所对应的$T$，这时候$z$和$y$的从属关系也将达到最大 \\frac{1}{2} \\iint p(z)p(y)(\\frac{p(z,y)}{p(z)p(y)}-1)^2dzdy利用最小二乘互信息估计法来计算平方损失互信息，可以得到 J(T)=\\frac{1}{2}\\hat{h}^{\\intercal}(\\hat{G}+ \\lambda I)^{-1}\\hat{h}-\\frac{1}{2}上式中， \\hat{G}=\\frac{1}{n^2}\\sum_{i:i'=1}^n \\psi(z_i,y_{i'})\\psi(z_i,y_{i'})^{\\intercal},\\hat{h}=\\frac{1}{n}\\sum_{i=1}^n \\psi(z_i,y_i)$\\psi(z,y)\\in \\mathbb{R}^b$表示的是基函数 与上式的规则$J$中的$T$中编号为$(j,j’)$的元素$T_{j,j’}$相关的微分为 \\hat{h}^{\\intercal}(\\hat{G}+\\lambda I)^{-1} \\frac{\\part \\hat{h}}{\\part T_{j.j'}}-\\frac{1}{2}\\hat{h}^{\\intercal}(\\hat{G}+\\lambda I)^{-1}\\frac{\\part \\hat{G}}{\\part T_{j,j'}}(\\hat{G}+\\lambda I)^{-1} \\hat{h}使用这样的表示方式，通过梯度法就可以求得$J$的局部最优解。","link":"/2020/07/30/%E5%9B%BE%E8%A7%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0%20%E7%9B%91%E7%9D%A3%E9%99%8D%E7%BB%B4/"},{"title":"图解机器学习&#x2F;第十九章 多任务学习","text":"在对多个相似的学习任务进行学习的时候，共享各学习任务的信息并同时对其进行求解的方法，往往比对各个学习任务单独进行求解有更高的学习精度。 多任务学习是在多个学习任务之间实现信息的共享、转移的一种学习方法 使用最小二乘回归的多任务学习对于序号为$t$的回归任务，使用与参数$\\theta_t = (\\theta_{t,1},\\dots,\\theta_{t,b})^{\\intercal}$相关的线性模型 \\sum_{j=1}^b \\theta_{t,j}\\phi_j(x) = \\theta_t^{\\intercal} \\phi(x)基函数$\\phi(x)$对所有的学习任务都相同。在多任务学习里，添加约束条件使各个任务的参数$\\theta_1,\\dots,\\theta_T$具有相似的值，在此基础上对所有的参数$\\theta=(\\theta_1^{\\intercal}, \\dots, \\theta_T^{\\intercal})^{\\intercal}$同时进行学习。 使用$l_2$正则化的最小二乘法对下式$J(\\theta)$为最小时所对应的参数$\\theta$进行学习 J(\\theta) = \\frac{1}{2}\\sum_{i=1}^n (\\theta_{t_i}^{\\intercal} \\phi(x_i) - y_i)^2+\\frac{1}{2}\\sum_{t=1}^T \\lambda_t||\\theta_t||^2 + \\frac{1}{4}\\sum_{t,t'=1}^T \\gamma_{t,t'}||\\theta_t - \\theta_{t'}||^2在这里，$\\lambda_t \\ge 0$是与序号为$t$的学习任务对应的$l_2$正则化参数0，$\\gamma_{t,t’} \\ge 0$是序号为$t$的学习任务和序号为$t’$的学习任务的相似度。对于所有的$t,t’=1,\\dots,T$，当$\\gamma_{t,t’} = 0$时，$J(\\theta)$的第三项就没有了，这就对应于$T$个学习任务分别进行$l_2$正则化最小二乘学习。另一方面，如果$\\gamma_{t,t’} &gt; 0$的话，$\\theta_t$和$\\theta_{t’}$向着$l_2$范数的方向进行学习，即可实现多个学习任务间的信息共享。","link":"/2020/05/04/%E5%9B%BE%E8%A7%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%AC%AC%E5%8D%81%E4%B9%9D%E7%AB%A0%20%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%AD%A6%E4%B9%A0/"},{"title":"图解机器学习&#x2F;第十六章 半监督学习","text":"灵活应用输入数据的流形构造半监督学习会首先假定输入概率密度$p(x)$和条件概率密度$p(y|x)$之间具有某种关联，利用对输入概率密度$p(x)$的估计来辅助对条件概率密度$p(y|x)$的估计，进而使得最终的学习精度得以提升。 流形是一数学用于，一般指局部具有欧几里得空间性质的图形，在半监督学习里指的是输入空间的局部范围。半监督学习中流形的假设，即输入数据只出现在某个流形上，输出则在该流形上平滑的变化。 高斯核函数实际上是灵活运用了流行的假设后形成的模型 f_{\\theta}(x)=\\sum_{j=1}^n \\theta_j K(x,x_j), K(x,c)=exp(-\\frac{||x-c||^2}{2h^2})即通过在训练输入样本$\\lbrace x_i \\rbrace_{i=1}^n$上设置平滑的高斯核函数，进而使得输入数据在流形上学习得到平滑的输入输出函数。 半监督学习在核函数的构成中，也应用了只有输入数据的训练样本$\\lbrace x_i \\rbrace_{i=n+1}^{n+n’}$ f_{\\theta}(x)=\\sum_{j=1}^{n+n'} \\theta_j K(x,x_j)另外，为了使训练输入样本的输出$\\lbrace f_{\\theta}(x_i) \\rbrace_{i=n+1}^{n+n’}$拥有局部相似值，还需要添加约束条件。对于$l_2$正则化最小二乘学习的情况，有以下学习规则 \\mathop{min}_{\\theta}[\\frac{1}{2}\\sum_{i=1}^n(f_{\\theta}(x_i)-y_i)^2 + \\frac{\\lambda}{2}||\\theta||^2+ \\frac{v}{4}\\sum_{i,i'=1}^{n+n'}W_{i,i'}(f_{\\theta}(x_i) - f_{\\theta}(x_i'))^2]其中第一项和第二项与$l_2$正则化最小二乘学习相对应。第三项是进行半监督学习所需的正则化项，称为拉普拉斯正则化。$v \\ge 0$是调整流形的平滑性的半监督学习的正则化参数。$W_{i,i’} \\ge0$是$x_i$和$x_{i’}$的相似度，当$x_i$和$x_{i’}$相似的时候，$W_{i,i’}$具有较大的值；当$x_i$和$x_{i’}$不相似的时候，$W_{i,i’}$具有较小的值。$W_{i,i’}$是对称的，即假定满足$W_{i,i’}=W_{i’,i}$。 拉普拉斯正则化最小二乘学习的求解方法对角元素为矩阵$W$的各行元素之和的对角矩阵用$D$来表示，矩阵$D$和矩阵$W$的差用矩阵$L$表示。上式第三项可以简化为 \\sum_{i,i'=1}^{n+n'}W_{i,i'}(f_{\\theta}(x_i) - f_{\\theta}(x_i'))^2 =\\sum_{i=1}^{n+n'}D_{i,i}f_{\\theta}(x_i)^2 - 2\\sum_{i,i'=1}^{n+n'}W_{i,i'}f_{\\theta}(x_i)f_{\\theta}(x_{i'})+\\sum_{i'=1}^{n+n'}D_{i',i'}f_{\\theta}(x_i)^2\\\\ =2 \\sum_{i,i'=1}^{n+n'}L_{i,i'}f_{\\theta}(x_i)f_{\\theta}(x_{i'})使用这样的表现形式，就可以归结为一般化$l_2$约束的最小二乘学习。 拉普拉斯正则化的解释把输入数据在流形上进行函数平滑的半监督学习算法称为拉普拉斯正则化。 对于训练输入样本$\\lbrace x_i \\rbrace_{i=n+1}^{n+n’}$的相似度$W_{i,i’}$，从如下图论规则进行说明 将训练输入样本$V=\\lbrace 1,\\dots,n+n’ \\rbrace$作为接点 当$W_{i,i’}=1$的时候，接点$i$和$i’$之间有分支；当$W_{i,i’}=0$的时候，接点$i$和$i’$之间没有分支。 在图论中，表示分支有无的矩阵$W$称为邻接矩阵。这个矩阵$W$的各行元素之和与各个接点相连接的分支的个数相对应。以维度为对角元素的对角矩阵$D$，有$L=D-W$，称为拉普拉斯矩阵（图论矩阵）。 在基于拉普拉斯正则化的半监督学习中，分支连接的各接点具有相同的类别标签。即通过从有标签的接点向没有标签的接点传播标签，相互连接的接点就可以实现标签的共享。 通常的最小二乘学习，可以理解为利用有一正一负的标签的训练样本，基于样本间的欧氏距离来求解其分类面。与此相对，拉普拉斯正则化学习，则可以理解为沿着输入样本的流形计算路径距离（图论中为最短路径），基于样本间的最短路径来求解其分类面。利用这样的方法，就可以把各个聚类中的所有数据，都归类到相同的类别中。","link":"/2020/05/09/%E5%9B%BE%E8%A7%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0%20%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/"},{"title":"图解机器学习&#x2F;第十三章 无监督降维","text":"高维数据的处理是相当困难的，一般称为维数灾难。为了使机器学习算法从维数灾难中解放出来，一般采取的有效方法是尽量保持输入数据中包含的所有信息，并对其维数进行削减。 线性降维的原理无监督降维的目的，是把高维的训练输入样本$\\lbrace x_i \\rbrace_{i=1}^n$变换为低维的训练样本$\\lbrace z_i \\rbrace_{i=1}^n$，并在降维后还能尽可能地保持其原本包含的所有信息。 通过$x_i$的线性变换求解$z_i$的时候，即使用维数为$m \\times d$的投影矩阵$T$根据下式 z_i = Tx_i来求解$z_i$的时候，称为线性降维。 中心化： $x_i \\leftarrow x_i \\frac{1}{n} \\sum_{i’=1}^n x_{i’}$ 主成分分析主成分分析法，是尽可能地忠实再现原始数据地所有信息地降维方法。具体而言，就是在降维后地输入$z_i$是原始训练输入样本$x_i$地正投影这一约束条件下，设计投影矩阵$T$，让$z_i$和$x_i$尽可能相似。 $z_i$是$x_i$的正投影这一假设，与投影矩阵$T$满足$TT^{\\intercal}=I_m$是等价的。其中$I_m$表示的是$m \\times m$的单位矩阵。 当$z_i$和$x_i$的维度不一样的时候，并不能直接计算其平方误差。因此，一般先把$m$次维的$z_i$通过$T^{\\intercal}$变换到$d$次维空间，再计算其与$x_i$的距离。所有训练样本的$T^{\\intercal}z_i$与$x_i$的平方距离的和，可以通过下式表示 \\sum_{i=1}^n ||T^{\\intercal}Tx_i - x_i||^2 = -tr(TCT^{\\intercal}) + tr(C)其中，$C$为训练输入样本的协方差矩阵 C=\\sum_{i=1}^n x_ix_i^{\\intercal}主成分学习的过程可以用下式表示 \\mathop{max}_{T\\in \\mathbb{R}^{m \\times d}} tr(TCT^{\\intercal}) \\quad 约束条件 TT^{\\intercal}=I_m考虑到矩阵$C$的特征值问题 C\\xi = \\lambda \\xi将特征值和相对应的特征向量分别表示为$\\lambda_1 \\ge \\dots \\ge \\lambda_d \\ge 0$和$\\xi_1,\\dots,\\xi_d$，这样主成分分析的解就可以通过下式求得 T=(\\xi_1,\\dots,\\xi_m)^{\\intercal}主成分分析的投影矩阵，是通过向训练输入样本的协方差矩阵$C$中的较大的$m$个特征值所对应的特征向量张成的局部空间正投影而得到的。与此相反，通过把较小的特征值所对应的特征向量进行削减，与原始样本的偏离就可以达到最小。另外，主成分分析中求得的低维$\\lbrace z_i \\rbrace_{i=1}^n$，其各个元素之间是无关联的，相互独立的，即协方差矩阵为对角矩阵 \\sum_{i=1}^n z_i z_i^{\\intercal} = diag(\\lambda_1,\\dots,\\lambda_m)局部投影保持局部保持投影利用了训练输入样本间的相似度信息。训练输入样本$x_i$和$x_{i’}$的相似度用$W_{i,i’} \\ge 0$来表示。当$x_i$和$x_{i’}$较为相似的时候，$W_{i,i’}$为较大的值；当$x_i$和$x_{i’}$不那么相似的时候，$W_{i,i’}$为较小的值。相似度是对称的，即可以假设$W_{i,i’}=W_{i’,i}$ 训练输入样本$\\lbrace x_i \\rbrace_{i=1}^n$间的相似度的实例： 高斯相似度： W_{i,i'}=exp(- \\frac{||x_i - x_{i'}||^2}{2t^2})其中，$t&gt;0$是调整相似度衰减值的参数 $k$近邻相似度： W_{i,i'} = \\begin{cases}1 &\\text{$(x_i \\in \\mathcal{N}_k(x_{i'})或x_{i'}\\in \\mathcal{N}_k(x_i))$} \\\\ 0 &\\text{(其他)} \\end{cases}其中，$\\mathcal{N}_k(x)$为$\\lbrace x_i \\rbrace_{i=1}^n$中的$x$近邻的$k$个样本的集合。$k\\in [1,\\dots,n]$是调整相似度局部性的参数。$k$近邻相似度的优点是，以$W_{i,i’}$为第$(i,i’)$个元素的矩阵$W$是稀疏矩阵。 局部尺度相似度： W_{i,i'}=exp(- \\frac{||x_i - x_{i'}||^2}{2t_it_{i'}})其中，$t_i$为局部尺度，定义为$t_i=||x_i - x_i^{(k)}||$。$x_i^{(k)}$是$\\lbrace x_i \\rbrace_{i=1}^n$中与$x_i$的距离为第$k$近的样本。把局部尺度相似度和$k$近邻相似度组合在一起的$k$近邻局部相似度，有着广泛的实际应用。 在局部保持投影中，认为相似度较高的样本对的投影也较为相似，以此来决定投影矩阵$T$。具体而言，就是计算下式的值最小时所对应的$T$ \\frac{1}{2}\\sum_{i,i'=1}^n W_{i,i'}||Tx_i - Tx_{i'}||^2为了避免得到$T=O$这样不证自明的结果，加入约束条件 TXDX^{\\intercal}T^{\\intercal}=I_m上式中，$X=(x_1,\\dots,x_n)\\in \\mathbb{R}^{d \\times n}$是训练输入样本的矩阵，$D$是以矩阵$W$的各行元素之和为对角元素的对角矩阵 D_{i,i'} = \\begin{cases} \\sum_{i''=1}^n W_{i,i'} &\\text{$(i=i')$} \\\\ 0 &\\text{($i \\not= i'$)} \\end{cases}令$L=D-W$，综上，局部投影保持的学习规则可以用下式表示 \\mathop{min}_{T\\in \\mathbb{R}^{m \\times n}} tr(TXLX^{\\intercal}T^{\\intercal}) \\quad 约束条件 \\quad TXDX^{\\intercal}T^{\\intercal}=I_m考虑到关于矩阵对$(XLX^{\\intercal},XDX^{\\intercal})$的一般化特征值问题 XLX^{\\intercal}\\xi = \\lambda XDX^{\\intercal}\\xi将一般化特征值及与其对应的一般化特征向量，分别用$\\lambda_1 \\ge \\dots \\ge \\lambda_d \\ge 0$和$\\xi_1,\\dots,\\xi_d$来表示。局部保持投影就可以用下式来求解 T=(\\xi_d,\\xi_{d-1}, \\dots,\\xi_{d-m+1})^{\\intercal}局部保持投影的投影矩阵，是通过矩阵对$(XLX^{\\intercal},XDX^{\\intercal})$的较小的$m$个一般化特征值对应的一般化特征向量来求解的。 核函数主成分分析把训练样本$\\lbrace x_i \\rbrace_{i=1}^n$通过非线性函数$\\psi$进行变换，在变换后的特征空间里进行主成分分析。通过这样的方法，就可以在原始训练样本的特征空间中进行非线性降维操作。 协方差矩阵$C$的大小往往依赖于特征空间的维度，但是核矩阵$K$的大小则只与样本数有关。因此，当特征空间的维数比样本数大的时候，使用与核矩阵$K$相关的特征值问题，可以得到更高效的求解。 拉普拉斯特征映射将核函数方法应用在局部保持投影的非线性降维方法，称为拉普拉斯特征映射。 与$(XLX^{\\intercal},XDX^{\\intercal})$相关的一般化特征值问题就可以变换为 L\\alpha=\\lambda D \\alpha上式中一般化特征值及与其对应的一般化特征向量，分别可以用$\\lambda_1 \\ge \\dots \\ge \\lambda_n \\ge 0$和$\\alpha_1,\\dots,\\alpha_n$来表示。这里因为$L1_n=0_n$是成立的，显然与最小的一般化特征值$\\lambda_n=0$相对应的一般化特征向量为$\\alpha_n = 1_n$，这里去掉$\\alpha_n$变为 (z_1,\\dots,z_n)=(\\alpha_{n-1},\\alpha_{n-2},\\dots,\\alpha_{n-m})^{\\intercal}上式即为拉普拉斯特征映射的最终结果。 如果相似度矩阵$W$为稀疏矩阵，$L=D-W$也为稀疏矩阵，这样就变成了稀疏的一般化特征值问题，可以进行高效的求解。","link":"/2020/05/09/%E5%9B%BE%E8%A7%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0%20%E6%97%A0%E7%9B%91%E7%9D%A3%E9%99%8D%E7%BB%B4/"},{"title":"图解机器学习&#x2F;第十二章 异常检测","text":"异常检测，是指找出给定的输入样本$\\lbrace x_i \\rbrace_{i=1}^n$中包含的异常值的问题。 局部异常因子局部异常因子，是指对偏离大部分数据的异常数据进行检测的方法。 从$x$到$x’$的可达距离 RD_k(x,x')=max(||x-x^{(k)}||,||x-x'||)$x^{(k)}$表示的是训练样本$\\lbrace x_i \\rbrace_{i=1}^n$中距离$x$第$k$近的样本。 $x$的局部可达密度可由下式加以定义 LRD-k(x) = (\\frac{1}{k} \\sum_{i=1}^k RD_k(x^{(i)},x))^{-1}$x$的局部可达密度，是从$x^{(i)}$到$x$的可达距离的平均值的倒数。 $x$的局部异常因子 LOF_k(x) = \\frac{ \\frac{1}{k} \\sum_{i=1}^k LRD_k(x^{(i)})}{LRD_k(x)}$LOF_k(x)$的值越大，$x$的异常度就越大。$LOF_k(x)$是$x^{(i)}$的局部可达密度的平均值和$x$的局部可达密度的比。当$x^{(i)}$的周围的密度比较高而$x$周围的密度比较低的时候，局部异常因子就比较大，$x$就会被看作是异常值。 局部异常因子，是遵循事先制定的规则(偏离大部分正常值的数据被认为是异常值)，寻找异常值的无监督的异常检测算法。 支持向量机异常检测支持向量机异常检测器会求出几乎包含所有训练样本$\\lbrace x_i \\rbrace_{i=1}^n$的超球，并将没有包含在超球内的训练样本看作是异常值。 具体而言，就是通过求解下述的最优化问题来求得超球的球心$c$和半径$R$ \\mathop{min}_{c,R,\\xi}[R^2+C\\sum_{i=1}^n\\xi_i] \\\\ 约束条件 ||x_i-c||^2 \\le R^2+\\xi_i,\\xi_i \\ge0 对于i=1,\\dots,n这样就变成了支持向量机分类器类似的最优化问题。 基于密度比的异常检测由于无监督学习的异常检测中完全没有与异常值相关的信息，因此要想进行理想的异常检测是很困难的。异常值各式各样，对其进行模型化一般是比较困难的，而正常值则相对比较稳定，因此通过把非正常的数据看作是异常数据的方法，有望实现高精度的异常检测。 已知是正常值的样本$\\lbrace x’_{i’} \\rbrace_{i’=1}^{n’}$的概率密度$p’(x)$，测试样本$\\lbrace x_i \\rbrace_{i=1}^n$的概率密度值$\\lbrace p’(x_i) \\rbrace_{i=1}^n$就可以看作是正常度。当概率密度函数$p’(x)$的值较小的时候需要较高精度的估计，但是因为概率密度很低的时候数据基本上是没有的，所以想要进行高精度的估计往往是比较困难的。 因此，一般通过计算正常样本的概率密度$p’(x)$和测试样本的概率密度$p(x)$的比值 w(x) = \\frac{p'(x)}{p(x)}这样的密度比$w(x)$，对于正常样本会输出接近1的值，对于异常样本则会输出和1相差较大的值。因为密度比函数对异常值的变化较为明显，因此使用密度比可以很容易地进行异常值的检测。 如果密度比分母很小，则分子值得误差会相应地增加。利用KL散度密度比估计法可以不计算概率密度而直接进行密度比估计。 KL散度密度比估计法的算法流程： 给$\\alpha$以适当的初值 直到解$\\alpha$达到收敛精度为止，重复以下的参数更新计算 $\\alpha \\leftarrow \\alpha+ \\epsilon A^{\\intercal}(1./A\\alpha)$ $\\alpha \\leftarrow \\alpha + (1-b^{\\intercal}\\alpha)b/(b^{\\intercal}b)$ $\\alpha \\leftarrow max(0,\\alpha)$ $\\alpha \\leftarrow \\alpha/(b^{\\intercal}\\alpha)$ $\\epsilon$为表示梯度上升幅度的正常数。$A$是第$(i’,j)$个元素为$\\psi_j(x’_{j’})$的矩阵，1为所有元素为1的向量，“./”表示对各个元素进行除法运算，0为所有元素为0的向量，b为第$j$个元素为$\\frac{1}{n}\\sum_{i=1}^n \\psi_j(x_i)$的向量。另外，向量的max运算表示对各个单独元素进行max运算。步骤2.1为梯度上升，2.2到2.4分别与满足约束条件的各个正交投影矩阵相对应。","link":"/2020/05/09/%E5%9B%BE%E8%A7%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%20%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B/"},{"title":"图解机器学习&#x2F;第十八章 迁移学习","text":"利用过去学习的得到的经验、知识，来提高当前以及将来进行的学习任务的求解精度，这样的方式称为迁移学习。 协变量移位下的迁移学习在统计学里，输入变量称为协变量。协变量移位是指输入输出关系不变，协变量的概率分布发生变化的情况。 重要度加权学习 如果只利用当前学习任务的输入训练样本$\\lbrace x’_{i’} \\rbrace_{i’=1}^{n’}$近旁的输入输出训练样本$\\lbrace (x_i, y_i)\\rbrace _{i=1}^n$进行学习，一般是可以很好地对$\\lbrace x’_{i’} \\rbrace_{i’=1}^{n’}$的输出进行预测。这种思路可以通过使用输入输出训练样本的重要度权重进行学习来实现。 重要度，是指当前学习任务的输入训练样本$\\lbrace x’_{i’} \\rbrace_{i’=1}^{n’}$的概率密度$p’(x)$和原始学习任务的输入训练样本$\\lbrace x_i \\rbrace_{i=1}^n$的概率密度$p(x)$的比 w(x) = \\frac{p'(x)}{p(x)}重要度加权最小二乘学习 \\mathop{min}_{\\theta} \\frac{1}{2}\\sum_{i=1}^n w(x_i)(f_{\\theta}(x_i)-y_i)^2重要度加权最小二乘学习，理论上可以认为是统计学中的重要性采样，可以据此来理解其算法的本质。重要性采样，是指利用与$p(x)$相关的加权期望值来计算与$p’(x)$相关的期望值的方法 \\int g(x)p'(x)dx = \\int g(x)\\frac{p'(x)}{p(x)}p(x)dx \\approx \\frac{1}{n}\\sum_{i=1}^n g(x_i)w(x_i)相对重要度加权学习一般而言，当重要度函数$w(x)$的值非常大的时候，就特别容易引起不稳定现象，因此如果能使得重要度函数稍许平滑，就可以使学习结果稳定下来。为此可以使用比重要度稍微钝一些的相对重要度 w_{\\beta}(x) = \\frac{p'(x)}{\\beta p'(x)+(1-\\beta)p(x)}重要度加权模型选择 重要度加权交叉验证法的算法流程： 把训练样本$\\mathcal{T}=\\lbrace (x_i,y_i) \\rbrace_{i=1}^n$随机划分为$m$个集合$\\lbrace \\mathcal{T}_i \\rbrace_{i=1}^m$ 对$i=1,\\dots,m$循环执行如下操作 使用除$\\mathcal{T}_i$以外的训练样本$\\mathcal{T}/ \\mathcal{T}_i$，求解其学习结果$f_i$ 把上述过程中没有参与学习的训练样本$\\mathcal{T}_i$作为测试样本，对$f_i$的泛化误差进行重要度加权评估 \\hat{G}_i = \\begin{cases} \\frac{1}{|\\mathcal{T_i}|}\\sum_{(x,y)\\in \\mathcal{T}_i}w(x)(f_i(x)-y)^2 &\\text{回归} \\\\ \\frac{1}{|\\mathcal{T_i}|} \\sum_{(x,y)\\in \\mathcal{T}_i \\frac{w(x)}{2}}(1-sign(f_i(x)y)) &\\text{分类} \\end{cases}在这里，$|\\mathcal{T}_i|$表示集合$\\mathcal{T}_i$包含的训练样本的个数 对各个$i$的泛化误差的评估值$\\hat{G}_i$进行平均，得到最终的泛化误差$\\hat{G}$ \\hat{G}=\\frac{1}{m}\\sum_{i=1}^m \\hat{G}_i 重要度加权估计不计算概率密度而直接求得相对重要度的方法。 首先把相对重要度函数$w_{\\beta}(x)$用下式的与参数相关的线性模型进行模型化 w_{\\alpha}(x) = \\sum_{j=1}^b \\alpha_j \\psi_j(x) = \\alpha^{\\intercal}\\psi(x)在这里，$\\alpha = (\\alpha_1,\\dots,\\alpha_b)^{\\intercal}$为参数向量，$\\psi(x)=(\\psi_1(x), \\dots, \\psi_b(x))^{\\intercal}$为基函数向量。 类别平衡变化下的迁移学习类别平衡变化，是指各个类别的输入样本的概率分布不变，但是各个类别之间的样本数的平衡发生变化的情况。 类别平衡加权学习在分类问题中，有时候各个类别的样本数的平衡在训练样本和测试样本中是不一致的。为了使最终结果与测试样本的类别平衡相吻合，可以对训练样本进行加权学习，来纠正误差。 具体而言，就是在训练时的类别$y$出现的概率为$p(y)$，测试时的类别$y$出现的概率为$p’(y)$的时候，对$p’(y)/p(y)$的概率比进行加权学习。 最小二乘学习的情况下，进行如下式学习 \\mathop{min}_{\\theta}\\frac{1}{2}\\sum_{i=1}^n \\frac{p'(y_i)}{p(y_i)}(f_{\\theta}(x_i)-y_i)^2","link":"/2020/07/30/%E5%9B%BE%E8%A7%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%AC%AC%E5%8D%81%E5%85%AB%E7%AB%A0%20%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0/"},{"title":"图解机器学习&#x2F;第十四章 聚类","text":"聚类是无监督机器学习方法的一种。 K均值聚类 K均值聚类的算法流程： 给各个簇中心$\\mu_1,\\dots,\\mu_c$以适当的初值 更新样本$x_1,\\dots,x_n$对应的簇标签$y_1,\\dots,y_n$ y_i \\leftarrow \\mathop{argmin}_{y\\in \\lbrace 1,\\dots,c \\rbrace}||x_i - \\mu_y||^2,i=1,\\dots,n 更新各个簇中心$\\mu_1,\\dots,\\mu_c$ \\mu_y \\leftarrow \\frac{1}{n_y}\\sum_{i:y_i=y}x_i,y=1,\\dots,c上式中，$n_y$为属于簇$y$的样本总数 直到簇标签达到收敛精度为止，重复上述2、3步的计算。 核K均值聚类由于K均值聚类是依据欧氏距离的大小来决定样本所属的簇，因此只能处理线性可分的聚类问题。利用核映射的方法就可以得到处理非线性可分的聚类问题的核K均值聚类算法。 具体而言，首先把欧氏距离的平方$||x-\\mu_y||^2$用样本间的内积$\\langle x,x’ \\rangle$来表示 ||x-\\mu_y||^2=||x - \\frac{1}{n_y}\\sum_{i:y_i=y}x_i||^2=\\langle x,x \\rangle - \\frac{1}{n_y}\\sum_{i:y_i=y}\\langle x,x_i \\rangle \\frac{1}{n_y^2} \\sum_{i,i':y_i=y_{i'}=y} \\langle x,x_{i'} \\rangle将上式內积置换为核函数$K(x,x’)$，就变成了核K均值聚类算法 y \\leftarrow \\mathop{argmin}_{y \\in \\lbrace1,\\dots,c \\rbrace}[- \\frac{2}{n_y}\\sum_{i:y_i=y} K(x,x_i) + \\frac{1}{n_y^2}\\sum_{i,i':y_i=y_i'=y} K(x_i,x_{i'})]在这里，与$\\langle x,x \\rangle$相对应的$K(x,x)$是与最小化无关的常数，因此在实际计算中可以忽略。 然而，采用核函数的非线性核K均值聚类算法，最终的聚类结果强烈依赖于初始值的选择。 谱聚类对于核K均值聚类算法的不足，可以通过降维来解决，这种方法称为谱聚类。 谱聚类，首先在核特征空间中应用局部保持投影法，然后直接应用通常的K均值聚类方法。 谱聚类的具体算法流程： 对样本$\\lbrace x_i \\rbrace_{i=1}^n$应用拉普拉斯特征映射，得到$c-1$次维的$\\lbrace z_i \\rbrace_{i=1}^n$ 对于得到的样本$\\lbrace z_i \\rbrace_{i=1}^n$，应用通常的K均值聚类方法求其簇标签$\\lbrace y_i \\rbrace_{i=1}^n$ 调整参数的自动选取核K均值聚类法与谱聚类的结果依赖于高斯核函数的带宽等核参数的选择。 互信息是信息论里的一个基本的概念，由概率变量$x$和$y$的联合概率$p(x,y)$到各个边缘概率$p(x)p(y)$的KL距离来定义 \\int \\sum_{y=1}^c p(x,y)log\\frac{p(x,y)}{p(x)p(y)}dx互信息一般为非负的数值，只有当概率变量$x$和$y$在统计上是相互独立的时候，即当$p(x,y)=p(x)p(y)$的时候，其值为零。 互信息越大，簇标签$\\lbrace y_i \\rbrace_{i=1}^n$则包含的样本$\\lbrace x_i \\rbrace_{i=1}^n$的信息越多","link":"/2020/05/09/%E5%9B%BE%E8%A7%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0%20%E8%81%9A%E7%B1%BB/"},{"title":"图解机器学习&#x2F;第十五章 在线学习","text":"一般来说，在训练样本不同时给定的情况下，比起将所有的训练样本集中起来同时进行学习，把训练样本逐个输入到学习算法中，并在新的数据进来的时候马上对现有的学习结果进行更新，这样的逐次学习算法更加有效。 当训练样本总数$n$非常大的时候，在线学习算法对于有限内存的利用、管理来说非常有效。 被动攻击学习梯度下降量的抑制在训练样本$(x,y)$逐个给定的在线学习中，也可以使用随机梯度下降算法进行参数的更新。概率梯度下降算法中，当梯度下降幅度过大的时候，学习结果往往会不稳定；而当梯度下降幅度过小的时候，又会使得收敛速度变慢。因此，一般引入一个惩罚系数，即偏离现在的解$\\tilde{\\theta}$的幅度，对梯度下降量进行适当地调整。 这样的学习方法对激进的梯度下降进行了抑制，称为被动攻击学习。 被动攻击分类进行分类时的损失函数，一般使用Hinge损失的平方形式，即 J(\\theta)=\\frac{1}{2}(max\\lbrace 0,1-m \\rbrace)^2 被动攻击分类的具体算法流程： 选取初始值为$\\theta \\leftarrow 0$ 利用新输入的训练样本$(x,y)$，使用下式对参数$\\theta$进行更新 \\theta \\leftarrow \\theta + \\frac{ymax(0,1-\\theta^{\\intercal}xy)}{||x||^2+ \\lambda}x 返回2步 被动攻击回归改变损失函数，即可适用于回归问题。使用$l_2$损失或$l_1$损失 J(\\theta)=\\frac{1}{2}r^2,J(\\theta)=|r|通过推导可得到更新规则 \\theta \\leftarrow \\theta-\\frac{r}{||x||^2 + \\lambda}x,\\theta \\leftarrow \\theta-sign(r)min \\lbrace \\frac{1}{\\lambda},\\frac{|r|}{||x||^2} \\rbrace x适应正则化学习被动攻击学习中使用的是没有上界的损失函数，因此往往不能很好地处理异常值。然而，具有上界的损失函数是非凸函数，进行最优化求解往往是很困难的。 参数分布的学习适应正则化学习，并不只是对参数$\\theta$进行学习，而是对参数的概率分布进行学习。 适应正则化分类 适应正则化分类的具体算法流程： 选取初始值为$\\mu \\leftarrow 0, \\Sigma \\leftarrow I$ 与新输入的训练样本$(x,y)$相对应的间隔$m=\\mu^{\\intercal}xy$，如果满足$m&lt;1$的话，则使用下式对参数进行更新 \\mu \\leftarrow \\mu + ymax(0,1-m)\\Sigma x/ \\beta,\\Sigma \\leftarrow \\Sigma-\\Sigma xx^{\\intercal}\\Sigma / \\beta其中，$\\beta=x^{\\intercal}\\Sigma x + C$ 返回第二步 适应正则化回归 \\mu \\leftarrow \\mu + (\\mu^{\\intercal}x-y)\\Sigma x/ \\beta,\\Sigma \\leftarrow \\Sigma - \\Sigma xx^{\\intercal} \\Sigma/ \\beta其中，$\\beta=x^{\\intercal}\\Sigma x + C$","link":"/2020/07/30/%E5%9B%BE%E8%A7%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0%20%E5%9C%A8%E7%BA%BF%E5%AD%A6%E4%B9%A0/"},{"title":"图解机器学习&#x2F;第十章 概率分类法","text":"对模式基于概率进行分类的手法称为概率分类法。基于概率的模式识别，是指对与模式$x$所对应的类别$y$的后验概率$p(y|x)$进行学习。其所属类别为后验概率达到最大值时所对应的类别。 \\hat{y} = \\mathop{argmax}_{y=1,\\dots,c}p(y|x)类别的后验概率$p(y=\\hat{y}|x)$，可以理解为模式$x$属于类别$y$的可信度。另外，基于概率的模式识别算法还有一个优势，就是对于多种类别的分类问题通常会有较好的分类结果。 Logistic回归Logistic模型的最大似然估计Logistic回归，使用线性对数函数对分类后验概率$p(y|x)$进行模型化 q(y|x;\\theta)=\\frac{exp(\\sum_{j=1}^b \\theta_j^{(y)} \\phi_j(x)) }{\\sum_{y'=1}^c exp(\\sum_{j=1}^b \\theta_j^{(y')} \\phi_j(x))}Logistic回归模型的学习，通过对数似然为最大时的最大似然估计进行求解。 一般使用对数使得乘法变成加法的方法来防止丢位现象的发生。 Logistic回归的学习模式由下式的最优化问题来定义 \\mathop{max}_{\\theta}\\sum_{i=1}^n logq(y_i|x_i;\\theta) 使用概率梯度下降法的Logistic回归学习算法： 给$\\theta$以适当的初值 随机选择一个训练样本(选择顺序为$i$的训练样本$(x_i,y_i)$ 对于选定的训练样本，以梯度上升的方向对参数$\\theta = (\\theta^{(1)^{\\intercal}}, \\dots,\\theta^{(c)^{\\intercal}})^{\\intercal}$进行更新 \\theta^{(y)} \\leftarrow \\theta^{(y)} + \\epsilon \\nabla_yJ_i(\\theta)对于y=1,\\dots,c在这里，$\\epsilon$为表示梯度上升幅度的正的常数。$\\nabla_yJ_i$是指顺序为$i$的训练样本所对应的对数似然$J_i(\\theta)=logq(y_i|x_i;\\theta)$的关于$\\theta^{(y)}$的梯度上升的方向 \\nabla_yJ_i(\\theta) = -\\frac{exp(\\theta^{(y)^{\\intercal}} \\phi(x_i)) \\phi(x_i)}{\\sum_{y'=1}^c exp(\\theta^{(y‘)^{\\intercal}} \\phi(x_i))} + \\begin{cases} \\phi(x_i) &\\text{$y=y_i$}\\\\ 0 &\\text{$y \\not= y_i$} \\end{cases} 直到解$\\theta$达到收敛精度为止，重复上述2、3步计算 使用Logistic损失最小化学习来解释首先从2分类问题$y\\in \\lbrace +1,-1 \\rbrace$进行说明 q(y=+1|x;\\theta) + q(y=-1|x;\\theta)=1通过上述关系式，Logistic模型的参数个数就可以由2b个降为b个。 最小二乘概率分类最小二乘概率分类器，对于各个类别$y=1,\\dots,c$的后验概率$p(y|x)$，使用与参数相关的线性模型 q(y|x;\\theta^{(y)}) = \\sum_{j=1}^b \\theta_j^{(y)} \\phi_j(x) =\\theta^{(y)^{\\intercal}} \\phi(x_i)进行模型化，与Logistic模型不同的是，这个模型只依赖于与各个类别$y$对应的参数$\\theta^{(y)} = (\\theta_i^{(y)},\\dots, \\theta_b^{(y)})^{\\intercal}$。","link":"/2020/05/09/%E5%9B%BE%E8%A7%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E6%A6%82%E7%8E%87%E5%88%86%E7%B1%BB%E6%B3%95/"},{"title":"数据库&#x2F;MyBatis学习笔记","text":"MyBatis学习笔记(参考官方文档 3.5.4版本) 安装使用 创建Maven工程 在pom.xml中引入Maven依赖 12345678910111213141516171819&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.19&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 在resources目录下创建mybatis-config.xml全局配置文件（这里参考官方文档创建格式） 1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;!--配置数据库链接驱动--&gt; &lt;property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"这里配置数据库URL\"/&gt; &lt;property name=\"username\" value=\"你的数据库账号\"/&gt; &lt;property name=\"password\" value=\"你的数据库密码\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--mappers标签关联映射，这些映射器的 XML 映射文件包含了 SQL 代码和映射定义信息--&gt; &lt;mappers&gt; &lt;!--这里相对路径从resources文件夹开始--&gt; &lt;mapper resource=\"mappers/BlogMapper.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 根据官方文档给出的信息在Java目录下创建实体类、映射接口和测试类 Blog实体类 12345package entity;public class Blog { } BlogMapper映射接口类 12345678package mapper;import entity.Blog;public interface BlogMapper { //创建查询方法 Blog selectBlog(Long id);} 创建测试类，这里使用junit单元测试类。 从XML文件中构建SqlSessionFactory，获取mybatis-config.xml文件资源 利用SqlSessionFactoryBuilder的build()方法创建sqlSessionFactory工厂类 通过openSession()方法获取连接 关联映射接口类，调用映射接口的查询方法 1234567891011121314@Test public void test01() throws IOException { String resource = \"src/main/resources/mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); //SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //SqlSession 的实例不是线程安全的，因此是不能被共享的 SqlSession sqlSession = sqlSessionFactory.openSession(); BlogMapper mapper = sqlSession.getMapper(BlogMapper.class); //首先得有Blog这个数据库表才能查询到数据 Blog blog = mapper.selectBlog(1L); //最后需要关闭资源 sqlSession.close(); } SqlSession的实例不是线程安全的，同时映射器实例应该在调用它们的方法中被获取，使用完毕之后即可丢弃，因此，最好将映射器放在方法作用域内。就像下面的例子一样： 1234try (SqlSession session = sqlSessionFactory.openSession()) { BlogMapper mapper = session.getMapper(BlogMapper.class); // 你的应用逻辑代码} 在resources下创建mappers文件夹用来放入mapper配置文件，创建BlogMapper接口类的映射文件 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;!-- namespace命名就可以直接映射到在命名空间中同名的映射器类， 并将已映射的 select 语句匹配到对应名称、参数和返回类型的方法--&gt;&lt;mapper namespace=\"mapper.BlogMapper\"&gt; &lt;!--id必须与映射接口中的方法名一致，resultType为返回结果类型--&gt; &lt;select id=\"selectBlog\" resultType=\"Blog\"&gt; select * from Blog where id = #{id} &lt;/select&gt;&lt;/mapper&gt; 对命名空间的一点补充 在之前版本的 MyBatis 中，命名空间（Namespaces）的作用并不大，是可选的。 但现在，随着命名空间越发重要，你必须指定命名空间。 命名空间的作用有两个，一个是利用更长的全限定名来将不同的语句隔离开来，同时也实现了你上面见到的接口绑定。就算你觉得暂时用不到接口绑定，你也应该遵循这里的规定，以防哪天你改变了主意。 长远来看，只要将命名空间置于合适的 Java 包命名空间之中，你的代码会变得更加整洁，也有利于你更方便地使用 MyBatis。 对于映射类还有另一种注解的配置方法，比如，上面的 XML 示例可以被替换成如下的配置： 1234public interface BlogMapper { @Select(\"SELECT * FROM blog WHERE id = #{id}\") Blog selectBlog(int id);} 优先使用XML配置文件的方式开发 创建完成后层级目录如下图： XML 配置配置文档的顶层结构如下： 属性（properties）12345678910&lt;!--配置数据库用户名密码--&gt;&lt;!-- 这些属性可以在外部进行配置，并可以进行动态替换, 既可以在典型的 Java 属性文件中配置这些属性， 也可以在 properties 元素的子元素中设置--&gt;&lt;properties resource=\"org/mybatis/example/config.properties\"&gt; &lt;property name=\"username\" value=\"dev_user\"/&gt; &lt;property name=\"password\" value=\"F2Fa3!33TYyg\"/&gt;&lt;/properties&gt; 设置好的属性可以在整个配置文件中用来替换需要动态配置的属性值 123456789&lt;!-- username 和 password 将会由 properties 元素中设置的相应值来替换。 driver 和 url 属性将会由 config.properties 文件中对应的值来替换--&gt;&lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"${driver}\"/&gt; &lt;property name=\"url\" value=\"${url}\"/&gt; &lt;property name=\"username\" value=\"${username}\"/&gt; &lt;property name=\"password\" value=\"${password}\"/&gt;&lt;/dataSource&gt; 类型别名（typeAliases）类型别名可为 Java 类型设置一个缩写名字。 它仅用于 XML 配置，意在降低冗余的全限定类名书写。例如： 12345678&lt;typeAliases&gt; &lt;typeAlias alias=\"Author\" type=\"domain.blog.Author\"/&gt; &lt;typeAlias alias=\"Blog\" type=\"domain.blog.Blog\"/&gt; &lt;typeAlias alias=\"Comment\" type=\"domain.blog.Comment\"/&gt; &lt;typeAlias alias=\"Post\" type=\"domain.blog.Post\"/&gt; &lt;typeAlias alias=\"Section\" type=\"domain.blog.Section\"/&gt; &lt;typeAlias alias=\"Tag\" type=\"domain.blog.Tag\"/&gt;&lt;/typeAliases&gt; 映射器（mappers）123456&lt;!-- 使用相对于类路径的资源引用 --&gt;&lt;mappers&gt; &lt;mapper resource=\"org/mybatis/builder/AuthorMapper.xml\"/&gt; &lt;mapper resource=\"org/mybatis/builder/BlogMapper.xml\"/&gt; &lt;mapper resource=\"org/mybatis/builder/PostMapper.xml\"/&gt;&lt;/mappers&gt; 123456&lt;!-- 使用完全限定资源定位符（URL） --&gt;&lt;mappers&gt; &lt;mapper url=\"file:///var/mappers/AuthorMapper.xml\"/&gt; &lt;mapper url=\"file:///var/mappers/BlogMapper.xml\"/&gt; &lt;mapper url=\"file:///var/mappers/PostMapper.xml\"/&gt;&lt;/mappers&gt; 123456&lt;!-- 使用映射器接口实现类的完全限定类名 --&gt;&lt;mappers&gt; &lt;mapper class=\"org.mybatis.builder.AuthorMapper\"/&gt; &lt;mapper class=\"org.mybatis.builder.BlogMapper\"/&gt; &lt;mapper class=\"org.mybatis.builder.PostMapper\"/&gt;&lt;/mappers&gt; 1234&lt;!-- 将包内的映射器接口实现全部注册为映射器 --&gt;&lt;mappers&gt; &lt;package name=\"org.mybatis.builder\"/&gt;&lt;/mappers&gt; XML映射器 select标签 1234&lt;!--select标签用于查询数据库数据，其中id为映射接口对应的方法名，必须保持一致，parameterType为接收参数类型，resultType为返回查询结果的数据类型，#{id}用以获取传入参数数值--&gt;&lt;select id=\"selectPerson\" parameterType=\"int\" resultType=\"HashMap\"&gt; SELECT * FROM PERSON WHERE ID = #{id}&lt;/select&gt; 官方提供的select语句的标签属性： 123456789101112&lt;select id=\"selectPerson\" //命名空间中唯一标识符 parameterType=\"int\" //可选，传入参数的类全限定名或别名 parameterMap=\"deprecated\" //已废弃 resultType=\"hashmap\" //返回结果的类全限定名或别名 resultMap=\"personResultMap\" //对外部 resultMap 的命名引用，resultType 和 resultMap 之间只能同时使用一个 flushCache=\"false\" //是否清空本地缓存和二级缓存，默认为false useCache=\"true\" //是否启用二级缓存 timeout=\"10\" //在抛出异常之前，驱动程序等待数据库返回请求结果的秒数 fetchSize=\"256\" //让驱动程序每次批量返回的结果行数等于这个设置值 statementType=\"PREPARED\" //可选 STATEMENT，PREPARED 或 CALLABLE resultSetType=\"FORWARD_ONLY\" //FORWARD_ONLY，SCROLL_SENSITIVE, SCROLL_INSENSITIVE 或 DEFAULT（等价于 unset） 中的一个&gt; insert、update和delete 1234567891011121314151617&lt;insert id=\"insertAuthor\"&gt; insert into Author (id,username,password,email,bio) values (#{id},#{username},#{password},#{email},#{bio})&lt;/insert&gt;&lt;update id=\"updateAuthor\"&gt; update Author set username = #{username}, password = #{password}, email = #{email}, bio = #{bio} where id = #{id}&lt;/update&gt;&lt;delete id=\"deleteAuthor\"&gt; delete from Author where id = #{id}&lt;/delete&gt; 1234567891011121314151617181920212223&lt;insert id=\"insertAuthor\" parameterType=\"domain.blog.Author\" flushCache=\"true\" statementType=\"PREPARED\" keyProperty=\"\" //（仅适用于 insert 和 update）指定能够唯一识别对象的属性 keyColumn=\"\" //（仅适用于 insert 和 update）设置生成键值在表中的列名 useGeneratedKeys=\"\" //（仅适用于 insert 和 update）取出由数据库内部生成的主键 timeout=\"20\"&gt;&lt;update id=\"updateAuthor\" parameterType=\"domain.blog.Author\" flushCache=\"true\" statementType=\"PREPARED\" timeout=\"20\"&gt;&lt;delete id=\"deleteAuthor\" parameterType=\"domain.blog.Author\" flushCache=\"true\" statementType=\"PREPARED\" timeout=\"20\"&gt; 字符串替换 有时你就是想直接在 SQL 语句中直接插入一个不转义的字符串。 比如 ORDER BY 子句，这时候你可以： 1ORDER BY ${columnName} 当 SQL 语句中的元数据（如表名或列名）是动态生成的时候，字符串替换将会非常有用。举个例子，如果你想 select 一个表任意一列的数据时，不需要这样写： 12345678@Select(\"select * from user where id = #{id}\")User findById(@Param(\"id\") long id);@Select(\"select * from user where name = #{name}\")User findByName(@Param(\"name\") String name);@Select(\"select * from user where email = #{email}\")User findByEmail(@Param(\"email\") String email); 而是可以只写这样一个方法： 12@Select(\"select * from user where ${column} = #{value}\")User findByColumn(@Param(\"column\") String column, @Param(\"value\") String value); 其中 ${column} 会被直接替换，而 #{value} 会使用 ? 预处理。 这样，就能完成同样的任务： 123User userOfId1 = userMapper.findByColumn(\"id\", 1L);User userOfNameKid = userMapper.findByColumn(\"name\", \"kid\");User userOfEmail = userMapper.findByColumn(\"email\", \"noone@nowhere.com\");","link":"/2020/05/31/%E6%95%B0%E6%8D%AE%E5%BA%93/MyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"图解机器学习&#x2F;第四章 带有约束条件的最小二乘法","text":"单纯的最小二乘法对于包含噪声的学习过程经常有过拟合的弱点 部分空间约束的最小二乘学习法&emsp;通过把参数空间限制在一定范围内，来防止过拟合现象。 \\mathop{min}_{\\theta}J_{LS}(\\theta) \\quad 约束条件P\\theta=\\theta$P$是满足$P^2=P$和$P^{\\intercal}=P$的$b\\times b$矩阵，表示的是矩阵$P$的值域$\\mathcal{R}(P)$的正交投影矩阵。通过附加$P\\theta=P$约束条件，参数$\\theta$就不会偏移到值域$\\mathcal{R}(P)$范围外了。 $l_2$约束的最小二乘学习法 \\mathop{min}_{\\theta}J_{LS}(\\theta) \\quad 约束条件 \\quad ||\\theta||^2 \\le R&emsp;$l_2$约束的最小二乘学习法是以参数空间的原点为圆心，在一定半径范围的圆内进行秋季。$R$表示的即是圆的半径。 拉格朗日对偶问题 可微分的凸函数$f:\\mathbb{R}^d \\rightarrow \\mathbb{R}$和$g:\\mathbb{R}^d \\rightarrow \\mathbb{R}^p$的约束条件的最小化问题 \\mathop{min}_t f(t) \\quad 约束条件 \\quad g(t) \\le 0的拉格朗日对偶问题，可以使用拉格朗日乘子 \\lambda=(\\lambda_1,\\dots,\\lambda_p)^{\\intercal}和拉格朗日函数 L(t,\\lambda)=f(t)+\\lambda^{\\intercal}g(t)采用以下方式进行定义： \\mathop{max}_{\\lambda}\\mathop{inf}_t L(t,\\lambda) \\quad 约束条件 \\quad \\lambda \\ge 0拉格朗日对偶问题的$t$的解，与原来的问题的解是一致的。 \\mathop{max}_{\\lambda} \\mathop{min}_{\\theta}[J_{LS}(\\theta) + \\frac{\\lambda}{2}(||\\theta||^2)-R] \\quad 约束条件 \\quad \\lambda \\ge 0&emsp;拉格朗日对偶问题的拉格朗日乘子$\\lambda$的解由圆的半径$R$决定，如果不根据$R$来决定$\\lambda$，而是直接指定的话，$l_2$约束的最小二乘学习法的解 \\hat{\\theta}=\\mathop{argmin}_{\\theta}[J_{LS}(\\theta)+\\frac{\\lambda}{2}||\\theta||^2]上式的第一项$J_{LS}(\\theta)$表示的是对训练样本的拟合程度，通过与第二项的$\\frac{\\lambda}{2}||\\theta||^2$相结合得到最小值，来防止过拟合发生。 令偏微分为0，解得 \\hat{\\theta}=(\\Phi^{\\intercal}\\Phi + \\lambda I)^{-1}\\Phi^{\\intercal}y其中，$I$是单位矩阵。通过将矩阵$\\Phi^{\\intercal}\\Phi$与$\\lambda I$相加提高其正则性，进而就可以更稳定的进行逆矩阵的求解。 $l_2$正则化的最小二乘学习法在有些著作中也成为岭回归。 &emsp;如果考虑设计矩阵$\\Phi$的奇异值分解 \\Phi = \\sum_{k=1}^{min(n,b)} \\kappa_k \\psi_k \\varphi_k^{\\intercal}$l_2$约束的最小二乘学习法的解 \\hat{\\theta}=\\sum_{k=1}^{min(n,b)} \\frac{\\kappa_k}{\\kappa_k^2+\\lambda}\\psi_k^{\\intercal}y\\varphi_k 当设计矩阵$\\Phi$的计算条件很恶劣，即包含非常小的奇异值$\\kappa_k$的时候，$\\frac{\\kappa}{\\kappa^2}$就会变成非常大的数值，训练输出向量$y$包含的噪声就会有所增加。另一方面，在$l_2$约束的最小二乘法中，通过在分母的$\\kappa_k^2$中加入正的常数$\\lambda$，使$\\kappa_k / (\\kappa_k^2+\\lambda)$避免变得过大，进而可以达到防止过拟合的目的。 通过使用$b\\times b$的正则化矩阵$G$，就可以得到更为普遍的表示方法 \\mathop{min}_{\\theta}J_{LS}(\\theta) \\quad 约束条件 \\quad \\theta^{\\intercal}G\\theta \\le R \\\\ \\hat{\\theta}=(\\Phi^{\\intercal}\\Phi + \\lambda G)^{-1}\\Phi^{\\intercal}y模型选择&emsp;通过采用不同的输入训练样本，来决定机器学习算法中包含的各个参数值，一般称为模型选择。 一般的模型选择流程 准备模型的候选$M_1,\\dots,M_k$ 对各个模型$M_1,\\dots,M_k$求解其学习结果$f^{(1),\\dots,f^{(k)}}$ 对各学习结果$f^{(1),\\dots,f^{(k)}}$的泛化误差$G^{(1)},\\dots,G^{(k)}$进行评价 选择泛化误差$G^{(1)},\\dots,G^{(k)}$最小的模型为最终模型 泛化是指学习机器对未知的测试输入样本的处理能力，泛化误差是指对未知的测试输入样本的输出所做的预测的误差 &emsp;交叉验证发用于评估模型发话误差，在交叉验证法中，把训练样本的一部分拿出来作为测试样本，不将其用于学习，而只用于评价最终学习结果的泛化误差。 分割数为m的交叉验证法一般称为m折交叉验证。 分割的集合数m设定为训练样本数n的交叉验证法， 即对n-1个训练样本及进行学习，将余下的1个作为测试样本的方法，称为留一交叉验证法。","link":"/2020/05/09/%E5%9B%BE%E8%A7%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E5%B8%A6%E6%9C%89%E7%BA%A6%E6%9D%9F%E6%9D%A1%E4%BB%B6%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95/"},{"title":"算法4笔记&#x2F;排序算法","text":"排序类算法模板12345678910111213141516171819202122232425262728293031public static void sort(Comparable[] a) { //排序内容}private static boolean less(Comparable v, Comparable w) { //比较两数大小，若v小于w，则返回true return v.compareTo(w) &lt; 0;}private static void exch(Comparable[] a, int i, int j) { //交换两元素位置 Comparable t = a[i]; a[i] = a[j]; a[j] = t;}private static void show(Comparable[] a) { // 在单行中打印数组 for (int i = 0; i &lt; a.length; i++) StdOut.print(a[i] + \" \"); StdOut.println();}public static boolean isSorted(Comparable[] a) { //测试数组元素是否有序 for (int i = 1; i &lt; a.length; i++) { if (less(a[i], a[i - 1])) return false; } return true;} 选择排序首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置（如果第一个元素就是最小元素那么它就和自己交换）。再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。这种方法叫做选择排序，因为它在不断地选择剩余元素之中的最小者。 对于长度为 N 的数组，选择排序需要大约$N^2/ 2 $次比较和 N 次交换。 123456789101112public class Selection { public static void sort(Comparable[] a) { // 将a[]按升序排列 int N = a.length; // 数组长度 for (int i = 0; i &lt; N; i++) { // 将a[i]和a[i+1..N]中最小的元素交换 int min = i; // 最小元素的索引 for (int j = i + 1; j &lt; N; j++) if (less(a[j], a[min])) min = j; exch(a, i, min); } } // less()、exch()、isSorted()和main()方法见“排序算法类模板”} 冒泡排序从左到右不断交换相邻逆序的元素，在一轮的循环之后，可以让未排序的最大元素上浮到右侧。在一轮循环中，如果没有发生交换，那么说明数组已经是有序的，此时可以直接退出。 123456789101112131415public class Bubble { public void sort(Comparable[] nums) { int N = nums.length; boolean isSorted = false; for (int i = N - 1; i &gt; 0 &amp;&amp; !isSorted; i--) { isSorted = true; for (int j = 0; j &lt; i; j++) { if (less(nums[j + 1], nums[j])) { isSorted = false; exch(nums, j, j + 1); } } } }} 插入排序每次都将当前元素插入到左侧已经排序的数组中，使得插入之后左侧数组依然有序。 对于随机排列的长度为 N 且主键不重复的数组，平均情况下插入排序需要$N^2 / 4$ 次比较以及$N^2 / 4$ 次交换。最坏情况下需要$N^2 / 2$ 次比较和$N^2 / 2$ 次交换，最好情况下需要 N-1次比较和 0 次交换。 12345678910public class Insertion { public static void sort(Comparable[] a) { // 将a[]按升序排列 int N = a.length; for (int i = 1; i &lt; N; i++) { // 将 a[i] 插入到 a[i-1]、a[i-2]、a[i-3]...之中 for (int j = i; j &gt; 0 &amp;&amp; less(a[j], a[j - 1]); j--) exch(a, j, j - 1); } } // less()、exch()、isSorted()和main()方法见“排序算法类模板”} 插入排序需要的交换操作和数组中倒置的数量相同，需要的比较次数大于等于倒置的数量，小于等于倒置的数量加上数组的大小再减一。 希尔排序希尔排序使用插入排序对间隔 h 的序列进行排序。通过不断减小 h，最后令 h=1，就可以使得整个数组是有序的。 123456789101112131415public class Shell { public static void sort(Comparable[] a) { // 将a[]按升序排列 int N = a.length; int h = 1; while (h &lt; N / 3) h = 3 * h + 1; // 1, 4, 13, 40, 121, 364, 1093, ... while (h &gt;= 1) { // 将数组变为h有序 for (int i = h; i &lt; N; i++) { // 将a[i]插入到a[i-h], a[i-2*h], a[i-3*h]... 之中 for (int j = i; j &gt;= h &amp;&amp; less(a[j], a[j - h]); j -= h) exch(a, j, j - h); } h = h / 3; } } // less()、exch()、isSorted()和main()方法见“排序算法类模板”} 希尔排序的运行时间达不到平方级别，使用递增序列 1, 4, 13, 40, … 的希尔排序所需要的比较次数不会超过 N 的若干倍乘于递增序列的长度。后面介绍的高级排序算法只会比希尔排序快两倍左右。 归并排序要将一个数组排序，可以先（递归地）将它分成两半分别排序，然后将结果归并起来。 归并排序最吸引人的性质是它能够保证将任意长度为 N 的数组排序所需时间和 NlogN 成正比；它的主要缺点则是它所需的额外空间和 N 成正比。 原地归并的抽象方法 merge(a, lo, mid, hi)，它会将子数组 a[lo..mid] 和 a[mid+1..hi] 归并成一个有序的数组并将结果存放在a[lo..hi] 中。 12345678910public static void merge(Comparable[] a, int lo, int mid, int hi) { // 将a[lo..mid] 和 a[mid+1..hi] 归并 int i = lo, j = mid + 1; for (int k = lo; k &lt;= hi; k++) // 将a[lo..hi]复制到aux[lo..hi] aux[k] = a[k]; for (int k = lo; k &lt;= hi; k++) // 归并回到a[lo..hi] if (i &gt; mid) a[k] = aux[j++]; else if (j &gt; hi) a[k] = aux[i++]; else if (less(aux[j], aux[i])) a[k] = aux[j++]; else a[k] = aux[i++];} 该方法先将所有元素复制到 aux[] 中，然后再归并回 a[] 中。方法在归并时（第二个 for 循环）进行了 4 个条件判断：左半边用尽（取右半边的元素）、右半边用尽（取左半边的元素）、右半边的当前元素小于左半边的当前元素（取右半边的元素）以及右半边的当前元素大于等于左半边的当前元素（取左半边的元素）。 自顶向下的归并排序 1234567891011121314151617public class Merge { private static Comparable[] aux; // 归并所需的辅助数组 public static void sort(Comparable[] a) { aux = new Comparable[a.length]; // 一次性分配空间 sort(a, 0, a.length - 1); } private static void sort(Comparable[] a, int lo, int hi) { // 将数组a[lo..hi]排序 if (hi &lt;= lo) return; int mid = lo + (hi - lo) / 2; // 防止数组太大越界 sort(a, lo, mid); // 将左半边排序 sort(a, mid + 1, hi); // 将右半边排序 merge(a, lo, mid, hi); // 归并结果（代码见“原地归并的抽象方法”） }} 对于长度为 N 的任意数组，自顶向下的归并排序需要 ½NlgN 至 NlgN 次比较。 对于长度为 N 的任意数组，自顶向下的归并排序最多需要访问数组 6NlgN 次。 自底向上的归并排序 实现归并排序的另一种方法是先归并那些微型数组，然后再成对归并得到的子数组，如此这般，直到我们将整个数组归并在一起。 123456789101112public class MergeBU { private static Comparable[] aux; // 归并所需的辅助数组 // merge()方法的代码请见“原地归并的抽象方法” public static void sort(Comparable[] a) { // 进行lgN次两两归并 int N = a.length; aux = new Comparable[N]; for (int sz = 1; sz &lt; N; sz = sz + sz) // sz子数组大小 for (int lo = 0; lo &lt; N - sz; lo += sz + sz) // lo:子数组索引 merge(a, lo, lo + sz - 1, Math.min(lo + sz + sz - 1, N - 1)); }} 对于长度为 N 的任意数组，自底向上的归并排序需要 1/2NlgN 至 NlgN 次比较，最多访问数组 6NlgN 次。 排序算法的复杂度 没有任何基于比较的算法能够保证使用少于 lg（N!）～ NlgN 次比较将长度为 N 的数组排序。 归并排序是一种渐进最优的基于比较排序的算法。 快速排序12345678910111213public class Quick { public static void sort(Comparable[] a) { StdRandom.shuffle(a); // 消除对输入的依赖 sort(a, 0, a.length - 1); } private static void sort(Comparable[] a, int lo, int hi) { if (hi &lt;= lo) return; int j = partition(a, lo, hi); // 切分（请见“快速排序的切分”） sort(a, lo, j - 1); // 将左半部分a[lo .. j-1]排序 sort(a, j + 1, hi); // 将右半部分a[j+1 .. hi]排序 }} 12345678910111213private static int partition(Comparable[] a, int lo, int hi) { // 将数组切分为a[lo..i-1], a[i], a[i+1..hi] int i = lo, j = hi + 1; // 左右扫描指针 Comparable v = a[lo]; // 切分元素 while (true) { // 扫描左右，检查扫描是否结束并交换元素 while (less(a[++i], v)) if (i == hi) break; while (less(v, a[--j])) if (j == lo) break; if (i &gt;= j) break; exch(a, i, j); } exch(a, lo, j); // 将v = a[j]放入正确的位置 return j; // a[lo..j-1] &lt;= a[j] &lt;= a[j+1..hi] 达成 } 将长度为 N 的无重复数组排序，快速排序平均需要 ~2NlnN 次比较（以及 1/6 的交换）。 快速排序最多需要约$N^2 / 2 $次比较，但随机打乱数组能够预防这种情况。 不存在任何基于比较的排序算法能够保证在 NH-N 次比较之内将 N 个元素排序，其中H 为由主键值出现频率定义的香农信息量。 对于大小为 N 的数组，三向切分的快速排序需要 ~(2ln2)NH 次比较。其中 H 为由主键值出现频率定义的香农信息量。 优先队列一个合适的数据结构应该支持两种操作：删除最大元素和插入元素。这种数据类型叫做优先队列。 堆排序数据结构二叉堆能够很好地实现优先队列的基本操作。在二叉堆的数组中，每个元素都要保证大于等于另两个特定位置的元素。 当一棵二叉树的每个结点都大于等于它的两个子结点时，它被称为堆有序。 根结点是堆有序的二叉树中的最大结点。 二叉堆是一组能够用堆有序的完全二叉树排序的元素，并在数组中按照层级储存（不使用数组的第一个位置）。 一棵大小为 N 的完全二叉树的高度为 $\\lfloor lgN \\rfloor$。 有关堆的相关操作 123456789101112131415161718192021222324252627282930313233343536private boolean less(int i, int j) { return pq[i].compareTo(pq[j]) &lt; 0;}private void exch(int i, int j) { Key t = pq[i]; pq[i] = pq[j]; pq[j] = t;}//上浮操作private void swim(int k) { while (k &gt; 1 &amp;&amp; less(k / 2, k)) { exch(k / 2, k); k = k / 2; }}//下沉操作private void sink(int k) { // 当该节点的左子节点小于元素个数时循环 while (2 * k &lt;= N) { // 将左子节点赋值给j int j = 2 * k; // 判断左右子节点大小，如果左子节点小于右子节点，j++ if (j &lt; N &amp;&amp; less(j, j + 1)) j++; // 若k的左子节点大于k的右子节点，则上面if不成立，k比左子节点小就下沉，否则跳出循环 if (!less(k, j)) break; // 若k左子节点大于右子节点且k小于左子节点，直接下沉 // 若k左子节点小于右子节点，则第一个if成立，k和右子节点比较大小，满足条件则下沉 exch(k, j); k = j; } //这里不考虑左右子节点的大小排序问题（理论上说堆有序情况下左子节点应该小于右子节点），我们要做的只是下沉k节点即可} 对于一个含有N个元素的基于堆的优先队列，插入元素操作只需不超过（lgN+1）次比较，删除最大元素的操作需要不超过 2lgN 次比较。 在一个大小为 N 的索引优先队列中，插入元素（insert）、改变优先级（change）、删除（delete）和删除最小元素（remove the minimum）操作所需的比较次数和 logN 成正比。 用下沉操作由 N 个元素构造堆只需少于 2N 次比较以及少于 N 次交换。 堆排序 123456789public static void sort(Comparable[] a) { int N = a.length; for (int k = N / 2; k &gt;= 1; k--) sink(a, k, N); while (N &gt; 1) { exch(a, 1, N--); sink(a, 1, N); }} 将 N 个元素排序，堆排序只需少于（2NlgN +2N）次比较（以及一半次数的交换）。 快速排序是最快的通用排序算法。","link":"/2020/05/14/%E7%AE%97%E6%B3%954%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"title":"LeetCode&#x2F;二叉树&#x2F;104. 二叉树的最大深度","text":"104. 二叉树的最大深度给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例：给定二叉树 [3,9,20,null,null,15,7]， 3 / \\ 9 20 / \\ 15 7 返回它的最大深度 3 。 作者：力扣 (LeetCode)链接：https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xefh1i/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 题解：本题就是简单的DFS的应用，没有什么特殊的技巧，通过递归，循环遍历整棵树。 具体代码如下： 12345678910111213class Solution { public int maxDepth(TreeNode root) { return tranverse(root); } public static int tranverse(TreeNode treeNode) { if (treeNode == null) return 0; int left = tranverse(treeNode.left); int right = tranverse(treeNode.right); return Math.max(left, right) + 1; }} 本题也可用BFS做，但是时间复杂度不如深度优先搜索遍历。 具体代码如下： 12345678910111213141516171819202122232425class Solution { public int maxDepth(TreeNode root) { int depth = 0; if (root == null) { return 0; } Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while (!queue.isEmpty()) { int len = queue.size(); for (int i = 0; i &lt; len; i++) { TreeNode node = queue.poll(); if (node.left != null) { queue.add(node.left); } if (node.right != null) { queue.add(node.right); } } depth++; } return depth; }}","link":"/2020/09/01/LeetCode/%E4%BA%8C%E5%8F%89%E6%A0%91/104.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"},{"title":"LeetCode&#x2F;二叉树&#x2F;102. 二叉树的层序遍历","text":"102. 二叉树的层序遍历给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。 示例：二叉树：[3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 返回其层次遍历结果： 12345[ [3], [9,20], [15,7]] 作者：力扣 (LeetCode)链接：https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xefh1i/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 题解：具体代码如下： 1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) { if (root == null) return new ArrayList&lt;List&lt;Integer&gt;&gt;(); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); queue.add(root); while (!queue.isEmpty()) { int len = queue.size(); ArrayList&lt;Integer&gt; temp = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; len; i++) { TreeNode node = queue.poll(); temp.add(node.val); if (node.left != null) { queue.add(node.left); } if (node.right != null) { queue.add(node.right); } } result.add(temp); } return result; }}","link":"/2020/09/01/LeetCode/%E4%BA%8C%E5%8F%89%E6%A0%91/102.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"title":"LeetCode&#x2F;二叉树&#x2F;111. 二叉树的最小深度","text":"111. 二叉树的最小深度给定一个二叉树，找出其最小深度。 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 说明: 叶子节点是指没有子节点的节点。 示例: 给定二叉树 [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 返回它的最小深度 2. 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/path-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解： 如果做过二叉树的层序遍历的话想这道题其实很简单，需要改变的地方就是我们不再维护一个ArrayList来存储遍历的每一层的数值，而是直接用一个Double变量将每层值加起来然后除以每层的size。 具体代码如下： 12","link":"/2020/09/01/LeetCode/%E4%BA%8C%E5%8F%89%E6%A0%91/111.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/"},{"title":"LeetCode&#x2F;二叉树&#x2F;105. 从前序与中序遍历序列构造二叉树","text":"105. 从前序与中序遍历序列构造二叉树根据一棵树的前序遍历与中序遍历构造二叉树。 注意:你可以假设树中没有重复的元素。 例如，给出 12前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7] 返回如下的二叉树： 3 / \\ 9 20 / \\ 15 7 题解： 本题和106. 从中序与后序遍历序列构造二叉树如出一辙，就是通过前序遍历数组确定根结点，然后通过中序遍历数组构造二叉树。 具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.util.HashMap;/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { //存放当前子树根结点在inorder数组中的索引 int root_index; int[] preorder; int[] inorder; //用来存放inorder中元素和索引的映射关系（方便划分子树中左右子树的位置） HashMap&lt;Integer, Integer&gt; index_map = new HashMap&lt;&gt;(); public TreeNode buildTree(int[] preorder, int[] inorder) { // 获取根结点索引 root_index = 0; this.preorder = preorder; this.inorder = inorder; //将inorder数组全部存放在HashMap中方便后续查找 for (int i = 0; i &lt; inorder.length; i++) { index_map.put(inorder[i], i); } return helper(0, inorder.length - 1); } public TreeNode helper(int left_index, int right_index) { if (left_index &gt; right_index) { return null; } //创建根结点 int root_value = preorder[root_index]; TreeNode treeNode = new TreeNode(root_value); //获取root结点在中序遍历数组中的位置 int index = index_map.get(root_value); //递归生成左右子树 root_index++; treeNode.left = helper(left_index, index - 1); treeNode.right = helper(index + 1, right_index); return treeNode; }}","link":"/2020/09/01/LeetCode/%E4%BA%8C%E5%8F%89%E6%A0%91/105.%20%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"title":"LeetCode&#x2F;二叉树&#x2F;103. 二叉树的锯齿形层次遍历","text":"103. 二叉树的锯齿形层次遍历给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。 示例：给定二叉树 [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 返回锯齿形层次遍历如下： 12345[ [3], [20,9], [15,7]] 作者：力扣 (LeetCode)链接：https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xefh1i/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 题解：本题还是基于层序遍历的框架，题目所说的锯齿遍历，就是一行是正序，一行是反序，这种情况设置一个count变量，来隔行判断本行应该正序还是反序存储。 具体代码如下： 12345678910111213141516171819202122232425262728293031323334class Solution { public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) { List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;(); if (root == null) { return result; } Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); int count = 0; while (!queue.isEmpty()) { LinkedList&lt;Integer&gt; temp = new LinkedList&lt;&gt;(); int len = queue.size(); for (int i = 0; i &lt; len; i++) { TreeNode node = queue.poll(); if (count % 2 != 0) { //头插元素，即逆序 temp.add(0, node.val); } else { temp.add(node.val); } if (node.left != null) { queue.add(node.left); } if (node.right != null) { queue.add(node.right); } } count++; result.add(temp); } return result; }}","link":"/2020/09/01/LeetCode/%E4%BA%8C%E5%8F%89%E6%A0%91/103.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/"},{"title":"LeetCode&#x2F;二叉树&#x2F;106. 从中序与后序遍历序列构造二叉树","text":"106. 从中序与后序遍历序列构造二叉树根据一棵树的中序遍历与后序遍历构造二叉树。 注意:你可以假设树中没有重复的元素。 例如，给出 中序遍历 inorder = [9,3,15,20,7]后序遍历 postorder = [9,15,7,20,3]返回如下的二叉树： 3 / \\ 9 20 / \\ 15 7 题解： 本题先要明确，中序遍历和后序遍历是可以唯一确定一颗二叉树的。后序遍历数组中的最后一个元素，就是该二叉树的根结点元素，通过根结点元素，我们可以在中序遍历数组中找到该元素，该元素左边的元素是左子树元素，右边的元素是右子树元素。通过从后往前遍历后序遍历数组，不断的递归，我们最终可以生成一颗完整的二叉树。 具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.util.HashMap;/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { //存放当前子树根结点在inorder数组中的索引 int root_index; int[] postoder; int[] inorder; //用来存放inorder中元素和索引的映射关系（方便划分子树中左右子树的位置） HashMap&lt;Integer, Integer&gt; index_map = new HashMap&lt;&gt;(); public TreeNode buildTree(int[] inorder, int[] postorder) { // 获取根结点索引 root_index = postorder.length - 1; this.postoder = postorder; this.inorder = inorder; //将inorder数组全部存放在HashMap中方便后续查找 for (int i = 0; i &lt; inorder.length; i++) { index_map.put(inorder[i], i); } return helper(0, inorder.length - 1); } public TreeNode helper(int left_index, int right_index) { if (left_index &gt; right_index) { return null; } //创建根结点 int root_value = postoder[root_index]; TreeNode treeNode = new TreeNode(root_value); //获取root结点在中序遍历数组中的位置 int index = index_map.get(root_value); //递归生成左右子树 root_index--; treeNode.right = helper(index + 1, right_index); treeNode.left = helper(left_index, index - 1); return treeNode; }}","link":"/2020/09/01/LeetCode/%E4%BA%8C%E5%8F%89%E6%A0%91/106.%20%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"title":"LeetCode&#x2F;二叉树&#x2F;501. 二叉搜索树中的众数","text":"501. 二叉搜索树中的众数给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。 假定 BST 有如下定义： 结点左子树中所含结点的值小于等于当前结点的值 结点右子树中所含结点的值大于等于当前结点的值 左子树和右子树都是二叉搜索树 例如：给定 BST [1,null,2,2], 123451 \\ 2 /2 返回[2]. 提示：如果众数超过1个，不需考虑输出顺序 进阶：你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内） 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/find-mode-in-binary-search-tree著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：二叉搜索树有一个很重要的特性，就是如果按照中序遍历二叉搜索树，我们会得到一个值依次递增的序列，所以只需要判断当前结点和父结点出现的次数，就可以得到结果数组。具体来说我们中序遍历一棵树，如果当前结点的值和父结点值相等，那我们就给currTime自增，如果当前结点是root结点，那么将currTime初始化为1。如果当前值出现次数比maxTime还大，那么将currTime的值赋给maxTime，并且将结果数组中的值清空，将当前结点的值加入到结果数组中；如果两者相等，即为两个不同的值出现次数相同的情况，我们将它们一并加入到结果数组中。 具体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution { List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); int maxTime = 0; int currTime = 0; TreeNode preNode = null; public int[] findMode(TreeNode root) { inOrder(root); int len = result.size(); int[] current = new int[len]; //将结果数组中的值取出以int[]形式返回 for (int i = 0; i &lt; len; i++) { current[i] = result.get(i); } return current; } //中序遍历树 void inOrder(TreeNode node) { if (node == null) { return; } inOrder(node.left); //判断当前出现次数是否为第一次，若是第一次初始化出现次数为1，否则自增加一 if (preNode != null &amp;&amp; preNode.val == node.val) { currTime++; } else { currTime = 1; } //判断当前出现次数是否比最大次数还大 if (currTime == maxTime) { result.add(node.val); } else if (currTime &gt; maxTime) { maxTime = currTime; //清掉以前存放的结果 result.clear(); result.add(node.val); } //很关键，别忘了向下递归的时候将当前结点赋给preNode preNode = node; inOrder(node.right); }}","link":"/2020/09/01/LeetCode/%E4%BA%8C%E5%8F%89%E6%A0%91/501.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0/"},{"title":"LeetCode&#x2F;二叉树&#x2F;107. 二叉树的层次遍历 II","text":"107. 二叉树的层次遍历 II给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历） 例如：给定二叉树 [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 返回其自底向上的层次遍历为： 12345[ [15,7], [9,20], [3]] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/path-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解： 本题很好想，就是先对二叉树进行层次遍历，然后将结果逆序即可。 具体代码如下： 123456789101112131415161718192021222324252627282930313233343536class Solution { public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) { if (root == null) return new ArrayList&lt;&gt;(); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); queue.add(root); while (!queue.isEmpty()) { ArrayList&lt;Integer&gt; temp = new ArrayList&lt;&gt;(); int len = queue.size(); for (int i = 0; i &lt; len; i++) { TreeNode node = queue.poll(); temp.add(node.val); if (node.left != null) { queue.add(node.left); } if (node.right != null) { queue.add(node.right); } } result.add(temp); } return reverse(result); } //反转结果列表 public List&lt;List&lt;Integer&gt;&gt; reverse(List&lt;List&lt;Integer&gt;&gt; list) { List&lt;List&lt;Integer&gt;&gt; temp = new ArrayList&lt;&gt;(); for (int i = list.size() - 1; i &gt;= 0; i--) { temp.add(list.get(i)); } return temp; }}","link":"/2020/09/01/LeetCode/%E4%BA%8C%E5%8F%89%E6%A0%91/107.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%20II/"},{"title":"LeetCode&#x2F;二叉树&#x2F;145. 二叉树的后序遍历","text":"145. 二叉树的后序遍历给定一个二叉树，返回它的 后序 遍历。 示例: 12345678输入: [1,null,2,3] 1 \\ 2 / 3 输出: [3,2,1] 题解：具体代码如下： 12345678910111213141516171819202122232425/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public List&lt;Integer&gt; postorderTraversal(TreeNode root) { ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;(); tranverse(root, arrayList); return arrayList; } public static ArrayList&lt;Integer&gt; tranverse(TreeNode treeNode, ArrayList&lt;Integer&gt; result){ if (treeNode != null) { tranverse(treeNode.left, result); tranverse(treeNode.right, result); result.add(treeNode.val); } return result; }}","link":"/2020/09/01/LeetCode/%E4%BA%8C%E5%8F%89%E6%A0%91/145.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"title":"LeetCode&#x2F;二叉树&#x2F;95. 不同的二叉搜索树 II","text":"95. 不同的二叉搜索树 II给定一个整数 n，生成所有由 1 … n 为节点所组成的 二叉搜索树 。 示例 ： 1234567891011121314151617输入：3输出：[ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3]]解释：以上的输出对应以下 5 种不同结构的二叉搜索树： 1 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\ 2 1 2 3 提示： 0 &lt;= n &lt;= 8 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/path-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：这道题目前没有想出太好的思路，就是参考官方题解。首先要明确二叉搜索树的结构，二叉搜索树就是每一个结点的左子树都小于该根结点的值，右子树都大于每个根结点的值。我们可以将输入的n分为两个集合，以每次遍历到的i结点为根结点，递归构建1~i-1的左子树，递归构建i+1~n的右子树。最后我们要遍历所有的结果，一共会有 leftTreeNodes.size()*rightTreeNodes.size()种情况，我们固定左子树，遍历右子树，将所有的可能情况都遍历完全。 具体代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class Solution { public List&lt;TreeNode&gt; generateTrees(int n) { //如果给定数为0，则返回空，否则进行递归调用 if (n == 0) { return new LinkedList&lt;TreeNode&gt;(); } return buildTrees(1, n); } public List&lt;TreeNode&gt; buildTrees(int begin, int end) { //用于存放所有树结果 List&lt;TreeNode&gt; resultNode = new LinkedList&lt;TreeNode&gt;(); //如果begin &gt; end，当前二叉树为空，即为跳出条件 if (begin &gt; end) { resultNode.add(null); return resultNode; } for (int i = begin; i &lt; end; i++) { //递归生成左子树和右子树 List&lt;TreeNode&gt; leftTreeNodes = buildTrees(begin, i - 1); List&lt;TreeNode&gt; rightTreeNodes = buildTrees(i + 1, end); //一共会有leftTreeNodes.size()*rightTreeNodes.size()种情况 //固定左子树，然后和不同的右子树搭配，将所有的情况加入resultNode中返回 for (TreeNode leftTreeNode : leftTreeNodes) { for (TreeNode rightTreeNode : rightTreeNodes) { TreeNode treeNode = new TreeNode(i); treeNode.left = leftTreeNode; treeNode.right = rightTreeNode; resultNode.add(treeNode); } } } return resultNode; }}class TreeNode { int val; TreeNode left; TreeNode right; TreeNode() { } TreeNode(int val) { this.val = val; } TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left = left; this.right = right; }}","link":"/2020/07/21/LeetCode/%E4%BA%8C%E5%8F%89%E6%A0%91/95.%20%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%20II/"},{"title":"LeetCode&#x2F;二叉树&#x2F;993. 二叉树的堂兄弟节点","text":"993. 二叉树的堂兄弟节点在二叉树中，根节点位于深度 0 处，每个深度为 k 的节点的子节点位于深度 k+1 处。 如果二叉树的两个节点深度相同，但父节点不同，则它们是一对堂兄弟节点。 我们给出了具有唯一值的二叉树的根节点 root，以及树中两个不同节点的值 x 和 y。 只有与值 x 和 y 对应的节点是堂兄弟节点时，才返回 true。否则，返回 false。 示例1： 输入：root = [1,2,3,4], x = 4, y = 3 输出：false 示例2: 12输入：root = [1,2,3,null,4,null,5], x = 5, y = 4输出：true 示例3: 12输入：root = [1,2,3,null,4], x = 2, y = 3输出：false 提示： 二叉树的节点数介于 2 到 100 之间。 每个节点的值都是唯一的、范围为 1 到 100 的整数。 作者：力扣 (LeetCode)链接：https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xefh1i/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 题解：本题让寻找堂兄弟结点，说的直白一点就是寻找二叉树每一层中，是否包含所给的x和y。这里需要注意的一点就是因为是堂兄弟，所以x和y不能是同一个父结点两个子结点，我们通过设置一个标记flag，如果同父则将flag置为true，最后返回即可。 具体代码如下： 123456789101112131415161718192021222324252627282930public boolean isCousins(TreeNode root, int x, int y) { Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); boolean flags = false; while (!queue.isEmpty()) { ArrayList&lt;Integer&gt; temp = new ArrayList&lt;&gt;(); int len = queue.size(); for (int i = 0; i &lt; len; i++) { TreeNode node = queue.poll(); temp.add(node.val); if (node.left != null) { queue.add(node.left); } if (node.right != null) { queue.add(node.right); } if (node.left != null &amp;&amp; node.right != null) { if ((node.left.val == x &amp;&amp; node.right.val == y) || (node.left.val == y &amp;&amp; node.right.val == x)) { flags = true; } } } if (temp.contains(x) &amp;&amp; temp.contains(y) &amp;&amp; !flags) { return true; } } return false;}","link":"/2020/09/01/LeetCode/%E4%BA%8C%E5%8F%89%E6%A0%91/993.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%A0%82%E5%85%84%E5%BC%9F%E8%8A%82%E7%82%B9/"},{"title":"LeetCode&#x2F;二叉树&#x2F;637. 二叉树的层平均值","text":"637. 二叉树的层平均值给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。 示例1: 输入： 3 / \\ 9 20 / \\ 15 7 输出：[3, 14.5, 11] 解释： 第 0 层的平均值是 3 , 第1层是 14.5 , 第2层是 11 。因此返回 [3, 14.5, 11] 。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/path-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解： 如果做过二叉树的层序遍历的话想这道题其实很简单，需要改变的地方就是我们不再维护一个ArrayList来存储遍历的每一层的数值，而是直接用一个Double变量将每层值加起来然后除以每层的size。 具体代码如下： 123456789101112131415161718192021222324class Solution { public List&lt;Double&gt; averageOfLevels(TreeNode root) { List&lt;Double&gt; result = new ArrayList&lt;&gt;(); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while (!queue.isEmpty()) { Double temp = 0.0; int len = queue.size(); for (int i = 0; i &lt; len; i++) { TreeNode node = queue.poll(); temp += node.val; if (node.left != null) { queue.add(node.left); } if (node.right != null) { queue.add(node.right); } } result.add(temp / len); } return result; }}","link":"/2020/09/01/LeetCode/%E4%BA%8C%E5%8F%89%E6%A0%91/637.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC/"},{"title":"LeetCode&#x2F;二叉树&#x2F;94. 二叉树的中序遍历","text":"94. 二叉树的中序遍历 示例: 12345678输入: [1,null,2,3] 1 \\ 2 / 3输出: [1,3,2] 题解：具体代码如下： 12345678910111213141516171819202122232425/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public List&lt;Integer&gt; inorderTraversal(TreeNode root) { ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;(); tranverse(root, arrayList); return arrayList; } public static ArrayList&lt;Integer&gt; tranverse(TreeNode treeNode, ArrayList&lt;Integer&gt; result){ if (treeNode != null) { tranverse(treeNode.left, result); result.add(treeNode.val); tranverse(treeNode.right, result); } return result; }}","link":"/2020/09/01/LeetCode/%E4%BA%8C%E5%8F%89%E6%A0%91/94.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"title":"LeetCode&#x2F;二叉树&#x2F;144. 二叉树的前序遍历","text":"144. 二叉树的前序遍历给定一个二叉树，返回它的 前序 遍历。 示例: 12345678输入: [1,null,2,3] 1 \\ 2 / 3 输出: [1,2,3] 题解：具体代码如下： 12345678910111213141516171819202122232425/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public List&lt;Integer&gt; preorderTraversal(TreeNode root) { ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;(); tranverse(root, arrayList); return arrayList; } public static ArrayList&lt;Integer&gt; tranverse(TreeNode treeNode, ArrayList&lt;Integer&gt; result){ if (treeNode != null) { result.add(treeNode.val); tranverse(treeNode.left, result); tranverse(treeNode.right, result); } return result; }}","link":"/2020/09/01/LeetCode/%E4%BA%8C%E5%8F%89%E6%A0%91/144.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"title":"LeetCode&#x2F;二叉树&#x2F;98. 验证二叉搜索树","text":"98. 验证二叉搜索树给定一个二叉树，判断其是否是一个有效的二叉搜索树。 假设一个二叉搜索树具有如下特征： 节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 示例 1: 12345输入: 2 / \\ 1 3输出: true 示例 2: 123456789输入: 5 / \\ 1 4 / \\ 3 6输出: false解释: 输入为: [5,1,4,null,null,3,6]。 根节点的值为 5 ，但是其右子节点值为 4 。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/path-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题我们依然可以利用二叉搜索树的性质来解题，二叉搜索树的中序遍历是一个升序的数组，我们可以判断相邻两个数组是否为升序关系从而判断该树是否为二叉搜索树。 具体代码如下： 12345678910111213141516171819202122class Solution { List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); public boolean isValidBST(TreeNode root) { inOrder(root); for (int i = 0; i &lt; result.size() - 1; i++) { if (result.get(i) &gt;= result.get(i + 1)) { return false; } } return true; } void inOrder(TreeNode node) { if (node == null) { return; } inOrder(node.left); result.add(node.val); inOrder(node.right); }} 当然了，这样做时间复杂度很爆炸，我们可以不用递归完成后再遍历数组判断是否合法，可以直接在递归的过程中判断。 具体代码如下： 123456789101112131415161718class Solution { long temp = Long.MIN_VALUE; public boolean isValidBST(TreeNode root) { if (root == null) { return true; } if (!isValidBST(root.left)) { return false; } if (root.val &lt;= temp) { return false; } temp = root.val; return isValidBST(root.right); }}","link":"/2020/07/15/LeetCode/%E4%BA%8C%E5%8F%89%E6%A0%91/98.%20%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"},{"title":"LeetCode&#x2F;二叉树&#x2F;二叉树的最大深度","text":"104. 二叉树的最大深度给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例：给定二叉树 [3,9,20,null,null,15,7]， 3 / \\ 9 20 / \\ 15 7返回它的最大深度 3 。 作者：力扣 (LeetCode)链接：https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xoh1zg/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 题解：具体代码如下： 12345678910111213141516171819202122/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public int maxDepth(TreeNode root) { return tranverse(root); } public static int tranverse(TreeNode treeNode) { if (treeNode == null) return 0; int left = tranverse(treeNode.left); int right = tranverse(treeNode.right); return Math.max(left, right) + 1; }}","link":"/2020/09/01/LeetCode/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"},{"title":"LeetCode&#x2F;二叉树&#x2F;路经总和","text":"112. 路径总和给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。 说明: 叶子节点是指没有子节点的节点。 示例:给定如下二叉树，以及目标和 sum = 22， 5 / \\ 4 8 / / \\ 11 13 4 / \\ \\ 7 2 1 返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。 题解： 具体代码如下： 12345678910111213141516171819/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public boolean hasPathSum(TreeNode root, int sum) { if (root == null) return false; if (root.left == null &amp;&amp; root.right == null) return sum - root.val == 0; return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val); }}","link":"/2020/09/01/LeetCode/%E4%BA%8C%E5%8F%89%E6%A0%91/%E8%B7%AF%E7%BB%8F%E6%80%BB%E5%92%8C/"},{"title":"LeetCode&#x2F;二叉树&#x2F;96. 不同的二叉搜索树","text":"96. 不同的二叉搜索树给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？ 示例 ： 12345678910输入: 3输出: 5解释:给定 n = 3, 一共有 5 种不同结构的二叉搜索树: 1 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\ 2 1 2 3 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/path-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：学过数据结构的小伙伴应该都知道，计算n个结点的二叉树的形态数，其实个数就是Catalan数，与其吭哧吭哧一步一步推导动态规划的状态转移方程，不如我们来学习一下Catlan数。 首先我们要知道什么是Catalan数，这里我引用维基百科的定义： 卡塔兰数是组合数学中一个常在各种计数问题中出现的数列。以比利时的数学家欧仁·查理·卡特兰（1814–1894）命名。历史上，清朝数学家明安图（1692年－1763年）在其《割圜密率捷法》中最先发明这种计数方式，远远早于卡塔兰[。有中国学者建议将此数命名为“明安图数”或“明安图-卡塔兰数”。 Catalan的一般项为： C_n = \\frac{1}{n+1} \\left(\\begin{matrix}2n \\\\ n \\end{matrix} \\right) = \\frac{(2n)!}{(n+1)!n!}Catalan数基于一定的实际意义。在一个n * n的方格中，从(0,0)到(n,n)的路径数，这个路径个数其实就是从2n个路径中挑出n条，所以就是$\\left(\\begin{matrix}2n \\ n \\end{matrix} \\right)$，但是Catalan还有一定的要求，就是在每次移动过程中不能越过对角线，那么我们就可以得出Catalan数的计算公式$C_n = \\left(\\begin{matrix}2n \\ n \\end{matrix} \\right)-\\left(\\begin{matrix}2n \\ n+1 \\end{matrix} \\right)$。 根据维基百科的内容可以知道，Catalan的递推关系为： C_0 = 1 \\quad and \\quad C_{n+1}=\\sum_{i=0}^nC_i C_{n-i} \\quad for \\quad n \\ge 0 \\\\ C_0 = 1 \\quad and \\quad C_{n+1}=\\frac{2(2n+1)}{n+2}C_n这个对应到我们这道题上，令f(i)为以第i个结点为根结点的二叉树的个数，那么有 Catalan(n) = f(1)+f(2)...+f(n)其中当i为根结点时，左子树有i-1个结点，右子树有n-i个结点，即$f(i)=Catalan(i-1)*Catalan(n-i)$，这样代入进去，我们就可以得到Catalan数的递推公式了。 具体代码如下： 123456789class Solution { public int numTrees(int n) { long catalan = 1; //这里需要用long,否则可能因为数组太大造成结果溢出 for (int i = 0; i &lt; n; i++) { catalan = catalan * 2 * (2 * i + 1) / (i + 2); } return (int) catalan; }} 本文参考： 维基百科 LZM的博客","link":"/2020/07/15/LeetCode/%E4%BA%8C%E5%8F%89%E6%A0%91/96.%20%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"},{"title":"LeetCode&#x2F;二叉树&#x2F;剑指 Offer 28. 对称的二叉树","text":"剑指 Offer 28. 对称的二叉树给定一个二叉树，检查它是否是镜像对称的。 例如，二叉树[1,2,2,3,4,4,3]是对称的。 1 / \\ 2 2 / \\ / \\ 3 4 4 3 但是下面这个 [1,2,2,null,3,null,3]则不是镜像对称的: 1 / \\ 2 2 \\ \\ 3 3 题解：具体代码如下： 123456789101112131415161718192021/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public boolean isSymmetric(TreeNode root) { if (root == null) return true; return tranverse(root.left, root.right); } public static boolean tranverse(TreeNode leftNode, TreeNode rightNode) { if (leftNode == null &amp;&amp; rightNode == null) return true; if (leftNode == null || rightNode == null || leftNode.val != rightNode.val) return false; return tranverse(leftNode.left, rightNode.right) &amp;&amp; tranverse(leftNode.right, rightNode.left); }}","link":"/2020/09/01/LeetCode/%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%89%91%E6%8C%87%20Offer%2028.%20%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"title":"数据库&#x2F;数据库链接报错解决&#x2F;DataGrip-serverTimezone报错解决","text":"在每次链接DataGrip时执行SQL语句都会报错，具体报错信息如下： 主要原因就是数据库时区设置错误，解决方法就是在你所在的数据库上右键，点击Properties，如图所示； 点击Advanced，将serverTimezone的Value设置为CST(中国标准时间)； 再次尝试执行SQL语句，执行成功。","link":"/2020/05/27/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%93%BE%E6%8E%A5%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/DataGrip-serverTimezone%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/"},{"title":"数据库&#x2F;数据库链接报错解决&#x2F;JDBC踩坑集合","text":"JDBC向MySQL中添加字段时利用JUnit测试报错:java.lang.Exception: Method getConnection2() should be void，源码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import org.junit.Test;import java.io.InputStream;import java.sql.*;import java.util.Properties;public class JDBCTest { @Test public Connection getConnection2() throws Exception { Properties properties = new Properties(); InputStream in = this.getClass().getClassLoader().getResourceAsStream(\"JDBC.properties\"); properties.load(in); String driverClass = properties.getProperty(\"driver\"); String jdbcUrl = properties.getProperty(\"jdbcUrl\"); String user = properties.getProperty(\"user\"); String password = properties.getProperty(\"password\"); Class.forName(driverClass); return DriverManager.getConnection(jdbcUrl, user, password); } /** * 通过JDBC向指定的数据表中插入一条记录 */ @Test public void testStatement() throws Exception{ //1.获取数据库链接 Connection conn = getConnection2(); //2.准备插入的SQL语句 String sql = \"INSERT INTO customers(`Name`,Email,Birth) VALUES('xiaoming','456@sina.com','2001-1-2');\"; //3.执行插入 //(1)获取操作SQL语句的Statement对象：调用Connection的createStatement()方法来获取 Statement statement = conn.createStatement(); //(2)调用Statement对象的executeUpdate(sql)执行SQL语句进行插入 statement.executeUpdate(sql); //(3)关闭Statement对象 statement.close(); //4.关闭连接 conn.close(); }} 根据提示可以看到getConnection2()在测试单元里返回值必须是void，解决方法是注释掉getConnection2()方法上面的@Test语句 问题二：JDBC向表中添加字段时，使用中文出现乱码问题在Navicat中右键表选择设计表，在选项中修改表的默认字符集将默认的gb2321字符集改为utf8并保存然后在添加代码url中加入?useUnicode=true&amp;characterEncoding=utf8重新添加数据，显示正常","link":"/2020/05/27/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%93%BE%E6%8E%A5%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/JDBC%E8%B8%A9%E5%9D%91%E9%9B%86%E5%90%88/"},{"title":"数据库&#x2F;数据库链接报错解决&#x2F;IDEA2019.2链接MySQL数据库以及问题解决","text":"使用IDEA链接MySQL 首先介绍一下我所使用的版本：IDEA Ultimate 2019.02、MySQL用的是5.7的版本 启动IDEA完成后，在View-&gt;ToolWindows中点击Database 在出现的Database界面中选择加号，点击你要链接的数据库，这里我选择MySQL 在Data Sources and Drivers中输入你数据库的基本信息，重要的是Host、Port、User以及Password这几项内容，填写完毕后点击Test Connection测试，如果出现绿色对勾则配置正确 在Drivers中选择MySQL，点击加号安装对应的Connector即可 如果报错你可不填写User和Password然后测试，在出现的对话框中填写信息，然后确定进行配置 配置完成后在Database界面就会出现你刚才的数据库信息，这时你可以查看MySQL中存储的表 配置完成后我们进行一个简单的测试来看看是否配置成功 需要去MySQL官网下载jar包，我这里下载的是mysql-connector-java-8.0.17最新的版本:官网下载链接) 在你的工程中创建lib文件夹，将解压缩的jar包导入 编写程序进行测试 1234567891011121314151617181920212223242526import org.junit.Test;import java.sql.Connection;import java.sql.Driver;import java.sql.SQLException;import java.util.Properties;public class JDBCTest { @Test public void testDriver() throws SQLException { //1.创建一个Driver实现类的对象 Driver driver = new com.mysql.cj.jdbc.Driver(); //2.准备链接数据库基本信息：url,user,password String url = \"jdbc:mysql://localhost:3306/myemployees\"; Properties info = new Properties(); info.put(\"user\", \"root\"); info.put(\"password\", \"3570\"); //3.调用Driver接口的connect(url,info)获取数据库链接 Connection connect = driver.connect(url, info); System.out.println(connect); } } 若能出现如图结果则证明链接成功 解决java.sql.SQLException问题 首次运行可能会出现时区不对的问题，具体报错如下The server time zone value ‘�й���׼ʱ��’ is unrecognized or represents more than one time zone. You must configure either the server or JDBC driver (via the serverTimezone configuration property) to use a more specifc time zone 解决方法就是重新设置时区信息 1234//修改mysql全局时区为北京时间set global time_zone = '+8:00'; 修改mysql全局时区为北京时间//修改当前会话时区set time_zone = '+8:00'; 这种方法有个缺陷，就是每次都需要进行上述修改，所以我们直接修改my.ini文件 找到MySQL数据目录C:\\ProgramData\\MySQL\\MySQL Server 8.0，修改my.ini配置文件，添加default-time-zone='+08:00'如下图所示，保存退出。 至此，关于IDEA链接MySQL配置过程全部结束","link":"/2020/05/31/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%93%BE%E6%8E%A5%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/IDEA2019.2%E9%93%BE%E6%8E%A5MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BB%A5%E5%8F%8A%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"}],"tags":[{"name":"乱码","slug":"乱码","link":"/tags/%E4%B9%B1%E7%A0%81/"},{"name":"每日一题","slug":"每日一题","link":"/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"热部署","slug":"热部署","link":"/tags/%E7%83%AD%E9%83%A8%E7%BD%B2/"},{"name":"SSM整合","slug":"SSM整合","link":"/tags/SSM%E6%95%B4%E5%90%88/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"JDK","slug":"JDK","link":"/tags/JDK/"},{"name":"Maven","slug":"Maven","link":"/tags/Maven/"},{"name":"Nginx","slug":"Nginx","link":"/tags/Nginx/"},{"name":"配置静态IP","slug":"配置静态IP","link":"/tags/%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP/"},{"name":"Tomcat","slug":"Tomcat","link":"/tags/Tomcat/"},{"name":"最小二乘法","slug":"最小二乘法","link":"/tags/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95/"},{"name":"最小二乘分类","slug":"最小二乘分类","link":"/tags/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E5%88%86%E7%B1%BB/"},{"name":"集成分类","slug":"集成分类","link":"/tags/%E9%9B%86%E6%88%90%E5%88%86%E7%B1%BB/"},{"name":"学习模型","slug":"学习模型","link":"/tags/%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B/"},{"name":"稀疏学习","slug":"稀疏学习","link":"/tags/%E7%A8%80%E7%96%8F%E5%AD%A6%E4%B9%A0/"},{"name":"支持向量机","slug":"支持向量机","link":"/tags/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"},{"name":"鲁棒学习","slug":"鲁棒学习","link":"/tags/%E9%B2%81%E6%A3%92%E5%AD%A6%E4%B9%A0/"},{"name":"序列分类","slug":"序列分类","link":"/tags/%E5%BA%8F%E5%88%97%E5%88%86%E7%B1%BB/"},{"name":"监督降维","slug":"监督降维","link":"/tags/%E7%9B%91%E7%9D%A3%E9%99%8D%E7%BB%B4/"},{"name":"多任务学习","slug":"多任务学习","link":"/tags/%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%AD%A6%E4%B9%A0/"},{"name":"半监督学习","slug":"半监督学习","link":"/tags/%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/"},{"name":"无监督降维","slug":"无监督降维","link":"/tags/%E6%97%A0%E7%9B%91%E7%9D%A3%E9%99%8D%E7%BB%B4/"},{"name":"异常检测","slug":"异常检测","link":"/tags/%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B/"},{"name":"迁移学习","slug":"迁移学习","link":"/tags/%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0/"},{"name":"聚类","slug":"聚类","link":"/tags/%E8%81%9A%E7%B1%BB/"},{"name":"在线学习","slug":"在线学习","link":"/tags/%E5%9C%A8%E7%BA%BF%E5%AD%A6%E4%B9%A0/"},{"name":"概率分类法","slug":"概率分类法","link":"/tags/%E6%A6%82%E7%8E%87%E5%88%86%E7%B1%BB%E6%B3%95/"},{"name":"MyBatis官方文档学习笔记","slug":"MyBatis官方文档学习笔记","link":"/tags/MyBatis%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"带约束","slug":"带约束","link":"/tags/%E5%B8%A6%E7%BA%A6%E6%9D%9F/"},{"name":"排序算法","slug":"排序算法","link":"/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"name":"二叉树","slug":"二叉树","link":"/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"JDBC","slug":"JDBC","link":"/tags/JDBC/"}],"categories":[{"name":"并发编程","slug":"并发编程","link":"/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"name":"服务器","slug":"服务器","link":"/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"设计模式","slug":"并发编程/设计模式","link":"/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Tomcat","slug":"服务器/Tomcat","link":"/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/Tomcat/"},{"name":"LeetCode","slug":"LeetCode","link":"/categories/LeetCode/"},{"name":"IDEA使用技巧","slug":"IDEA使用技巧","link":"/categories/IDEA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"name":"Spring框架","slug":"Spring框架","link":"/categories/Spring%E6%A1%86%E6%9E%B6/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"项目热部署","slug":"IDEA使用技巧/项目热部署","link":"/categories/IDEA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/%E9%A1%B9%E7%9B%AE%E7%83%AD%E9%83%A8%E7%BD%B2/"},{"name":"SSM整合","slug":"Spring框架/SSM整合","link":"/categories/Spring%E6%A1%86%E6%9E%B6/SSM%E6%95%B4%E5%90%88/"},{"name":"安装Maven","slug":"Linux/安装Maven","link":"/categories/Linux/%E5%AE%89%E8%A3%85Maven/"},{"name":"MySQL安装","slug":"Linux/MySQL安装","link":"/categories/Linux/MySQL%E5%AE%89%E8%A3%85/"},{"name":"Nginx安装","slug":"Linux/Nginx安装","link":"/categories/Linux/Nginx%E5%AE%89%E8%A3%85/"},{"name":"虚拟机配置","slug":"Linux/虚拟机配置","link":"/categories/Linux/%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%85%8D%E7%BD%AE/"},{"name":"安装Tomcat","slug":"Linux/安装Tomcat","link":"/categories/Linux/%E5%AE%89%E8%A3%85Tomcat/"},{"name":"机器学习","slug":"机器学习","link":"/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"Git安装","slug":"Linux/Git安装","link":"/categories/Linux/Git%E5%AE%89%E8%A3%85/"},{"name":"安装Oracle JDK","slug":"Linux/安装Oracle-JDK","link":"/categories/Linux/%E5%AE%89%E8%A3%85Oracle-JDK/"},{"name":"Java框架","slug":"Java框架","link":"/categories/Java%E6%A1%86%E6%9E%B6/"},{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"},{"name":"图解机器学习笔记","slug":"机器学习/图解机器学习笔记","link":"/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%9B%BE%E8%A7%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"MyBatis","slug":"Java框架/MyBatis","link":"/categories/Java%E6%A1%86%E6%9E%B6/MyBatis/"},{"name":"算法4笔记","slug":"Algorithm/算法4笔记","link":"/categories/Algorithm/%E7%AE%97%E6%B3%954%E7%AC%94%E8%AE%B0/"},{"name":"数据库","slug":"数据库","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL","slug":"数据库/MySQL","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"}]}