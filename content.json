{"pages":[],"posts":[{"title":"常用设计模式","text":"单例设计模式单例设计模式一种对象创建模式，用于产生一个对象的具体实例，它可以确保系统中一个类只产生一个实例，其优势主要有以下两点： 可以节省new操作的时间花费 由于减少了new操作的频率，因此降低了内存使用频率，从而减轻了垃圾回收器的压力 1234567891011public class Singleton { //将构造函数设置为private，如果不是private，则instance安全性无法保障 private Singleton(){ System.out.println(\"Singleton is created\"); } private static Singleton instance = new Singleton(); public static Singleton getInstance(){ return instance; }} 上述方法有个问题就是在Singleton构造函数中，Singleton实例的创建是不受控制的，对于静态成员instance，它会在类第一次初始化的时候被创建。这个时刻并不一定是getInstance()方法第一次被调用的时候。要解决上述问题，就需要利用一种延迟加载策略，它只会在instance第一次使用时创建对象。 123456789101112public class LazySingleton(){ private LazySingleton(){ System.out.println(\"LazySingleton is created\"); } private static LazySingleton instance = null; public static synchronized LazySingleton getInstance(){ if (instance == null){ instance = new LazySingleton(); } return instance; }} 还有一种方式结合了上述两种方式的优势，既可以去掉锁使得性能提升，又只会在getInstance()方法第一次调用的时候创建实例。 12345678910111213pulibc class StaticSingleton{ private StaticSingleton(){ System.out.println(\"StaticSingleton is created\"); } private static class SingletonHolder{ private static StaticSingleton instance = new StaticSingleton(); } public static StaticSingleton getInstance(){ return SingletonHolder.instance; }} 常见的懒汉式（线程安全与不安全）、饿汉式和静态内部类的写法 懒汉式（线程不安全） 1234567891011121314public class Singleton { private static Singleton singleton; private Singleton() { } public static Singleton getInstance() { if (singleton == null) { singleton = new Singleton(); } return singleton; }} 懒汉式（线程安全） 12345678910public class Singleton { private static Singleton instance; private Singleton (){} public static synchronized Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; }} 饿汉式 1234567public class Singleton { private static Singleton instance = new Singleton(); private Singleton (){} public static Singleton getInstance() { return instance; }} 静态内部类 123456789public class Singleton { private static class SingletonHolder { private static final Singleton INSTANCE = new Singleton(); } private Singleton (){} public static final Singleton getInstance() { return SingletonHolder.INSTANCE; }} 不变模式在并发编程过程中，需要进行同步操作保证数据的一致性，但是使用同步操作又会降低性能，不变模式利用对象的不变性，可以在没有同步操作的情况下依然保证数据的一致性和正确性。不变模式主要有以下两个特点： 当对象被创建后，其内部状态和数据不再发生任何变化 对象需要被共享，被多线程频繁访问 123456789101112131415161718192021222324public final class Product { private final String no; private final String name; private final double price; public Product(String no, String name, double price) { super(); this.no = no; this.name = name; this.price = price; } public String getNo() { return no; } public String getName() { return name; } public double getPrice() { return price; }} 生产者-消费者模式在生产者-消费者模式中，通常有两类线程，即若干个生产者线程和若干个消费者线程。生产者线程负责提交用户请求，消费者线程则负责具体处理生产者提交的任务。生产者和消费者之间则通过共享内存缓冲区进行通信。 生产者： 12345678910111213141516171819202122232425262728293031323334public class Producer implements Runnable { private volatile boolean isRunning = true; private BlockingQueue&lt;PCData&gt; queue; private static AtomicInteger count = new AtomicInteger(); private static final int SLEEPTIME = 1000; public Producer(BlockingQueue&lt;PCData&gt; queue) { this.queue = queue; } @Override public void run() { PCData data = null; Random r = new Random(); System.out.println(\"start producer id = \" + Thread.currentThread().getId()); try { while (isRunning) { Thread.sleep(r.nextInt(SLEEPTIME)); data = new PCData(count.incrementAndGet()); System.out.println(data + \" is put into queue\"); if (!queue.offer(data, 2, TimeUnit.SECONDS)) { System.out.println(\"failed to put data: \" + data); } } } catch (InterruptedException e) { e.printStackTrace(); Thread.currentThread().interrupt(); } } public void stop() { isRunning = false; }} 消费者： 123456789101112131415161718192021222324252627public class Consumer implements Runnable { private BlockingQueue&lt;PCData&gt; queue; private static final int SLEEPTIME = 1000; public Consumer(BlockingQueue&lt;PCData&gt; queue) { this.queue = queue; } @Override public void run() { System.out.println(\"start Consumer id = \" + Thread.currentThread().getId()); Random r = new Random(); try { while (true) { PCData data = queue.take(); if (null != data) { int re = data.getData() * data.getData(); System.out.println(MessageFormat.format(\"{0}*{1}={2}\", data.getData(), data.getData(), re)); Thread.sleep(r.nextInt(SLEEPTIME)); } } } catch (InterruptedException e) { e.printStackTrace(); Thread.currentThread().interrupt(); } }} 资源(共享数据模型)： 12345678910111213141516171819public final class PCData { private final int intData; public PCData(int d){ intData = d; } public PCData(String d){ intData = Integer.valueOf(d); } public int getData(){ return intData; } @Override public String toString() { return \"data: \" + intData; }} 由于使用BlockingQueue导致性能不佳，提出了另一种改进措施：使用Disruptor框架，Disruptor框架利用环形队列实现高效的无锁内存队列。队列是环形的，则只需要对外提供一个当前位置cursor，利用这个指针既可以进行入队操作，也可以进行出队操作。由于环形队列的缘故，队列的总大小必须事先指定，不能动态扩展。这种固定大小的环形队列的另外一个好处就是可以做到完全的内存复用。在系统的运行过程中，不会有新的空间需要分配或者老的空间需要回收，大大减少系统分配空间及回收空间的额外开销。 资源： 1234567891011public class PCData { private long value; public void set(long value) { this.value = value; } public long get() { return value; }} 工厂类： 123456//它会在Disruptor框架系统初始化时，构造所有的缓冲区中的对象实例public class PCDataFactory implements EventFactory&lt;PCData&gt; { public PCData newInstance(){ return new PCData(); }} 消费者： 1234567public class Consumer implements WorkHandler&lt;PCData&gt; { //回调方法 @Override public void onEvent(PCData pcData) throws Exception { System.out.println(Thread.currentThread().getId() + \":Event: -- \" + pcData.get() * pcData.get() + \"--\"); }} 生产者： 1234567891011121314151617public class Producer { private final RingBuffer&lt;PCData&gt; ringBuffer; public Producer(RingBuffer&lt;PCData&gt; ringBuffer) { this.ringBuffer = ringBuffer; } public void pushData(ByteBuffer bb) { long sequence = ringBuffer.next(); try { PCData event = ringBuffer.get(sequence); event.set(bb.getLong(0)); } finally { ringBuffer.publish(sequence); } }} Future模式当我们需要调用一个函数方法时，如果这个函数执行得很慢，那么我们就要进行等待。但有时候，我们可能并不急着要结果。因此，我们可以让被调者立即返回，让它在后台慢慢处理这个请求。对于调用者来说，则可以先处理一些其他任务，在真正需要数据的场合再去尝试获得需要的数据。 Data接口： 1234//该接口有两个重要的实现，一个是RealData表示真实数据，另一个是FutureData用来立即返回结果（RealData虚拟实现）public interface Data { String getResult();} FutureData： 12345678910111213141516171819202122232425public class FutureData implements Data { protected RealData realdata = null; protected boolean isReady = false; public synchronized void setRealdata(RealData realdata) { if (isReady) { return; } this.realdata = realdata; isReady = true; notifyAll(); } @Override public synchronized String getResult() { while (!isReady) { try { wait(); } catch (InterruptedException e) { } } return realdata.result; }} RealData： 1234567891011121314151617181920public class RealData implements Data { protected final String result; public RealData(String para) { StringBuffer sb = new StringBuffer(); for (int i = 0; i &lt; 10; i++) { sb.append(para); try { Thread.sleep(100); } catch (InterruptedException e) { } } result = sb.toString(); } @Override public synchronized String getResult() { return result; }} Client： 12345678910public class Client { public Data request(final String queryStr) { final FutureData future = new FutureData(); new Thread(() -&gt; { RealData realData = new RealData(queryStr); future.setRealdata(realData); }).start(); return future; }} Main方法： 12345678910111213public class Main { public static void main(String[] args) { Client client = new Client(); Data data = client.request(\"name\"); System.out.println(\"请求完毕\"); try { Thread.sleep(2000); } catch (InterruptedException e) { } System.out.println(\"数据 = \" + data.getResult()); }} 观察者模式(Observer Pattern)一般有一个被观察者和多个观察者，一旦被观察者状态发生改变，就会通知到多个观察者，即当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。 装饰者模式适配器模式工厂模式","link":"/2020/06/01/%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"title":"解决IDEA中Tomcat9.X控制台输出乱码问题","text":"IDEA版本为2019.3.2，Tomcat版本为9.0.31 使用文本编辑器打开Tomcat安装目录下的conf/logging.properties文件，删除java.util.logging.ConsoleHandler.encoding = UTF-8行，保存退出。","link":"/2020/05/27/%E8%A7%A3%E5%86%B3IDEA%E4%B8%ADTomcat9.X%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BA%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/"},{"title":"Linux&#x2F;Maven安装","text":"本文将介绍Maven3.6.3在Centos 7下的安装使用。 在Maven官网下载apache-maven-3.6.3-bin.tar.gz，并将压缩包上传到/opt目录下 使用tar -zxvf apache-maven-3.6.3-bin.tar.gz命令解压缩文件 使用vim /etc/profile配置环境变量，在profile配置文件中添加如下语句： 12#Maven环境变量配置export MAVEN_HOME=/opt/apache-maven-3.6.3 #该路径为安装Maven路径 将$MAVEN_HOME/bin添加到PATH中 1export PATH=$PATH:$JAVA_HOME/bin:$MAVEN_HOME/bin 使用 source /etc/profile生效 使用mvn -version查看配置生效，配置成功后如下图所示","link":"/2020/07/15/Linux/Maven%E5%AE%89%E8%A3%85/"},{"title":"Linux&#x2F;Git安装","text":"本文将介绍Git在Centos 7下的安装使用。 安装Git 去Git下载页面下载对应版本的Git 执行yum -y install zlib-devel openssl-devel cpio expat-devel gettext-devel curl-devel perl-ExtUtils-CBuilder perl-ExtUtils-MakeMaker安装所需要的依赖 使用tar -zxvf git-2.9.5.tar.gz命令解压缩 使用make prefix=/usr/local all、make prefix=/usr/local install进行编译 使用git --vserion验证安装是否成功 ​ 基础配置 配置用户名 1git config --global user.name \"yourname\" 配置邮箱 1config --global user.email \"youemail@xxxx.com\" 忽略换行符转换 1git config --global core.autocrlf false 避免git gui中的中文乱码 1git config --global gui.encoding utf-8 避免git status显示的中文文件名乱码 1git config --global core.quotepath off git ssh key pair配置 12ssh-keygen -t rsa -C \"youemail@xxxx.com\"ssh-add ~/.ssh/id_rsa 执行ssh-add ~/.ssh/id_rsa可能会报错，如下图所示，我们需要先执行 1eval `ssh-agent` 去gitee上添加公钥即可进行git clone操作","link":"/2020/07/21/Linux/Git%E5%AE%89%E8%A3%85/"},{"title":"Linux&#x2F;MySQL安装","text":"本文将介绍MySQL8.0在Centos 7下的安装使用。 安装MySQL 将自带的MySQL数据删除干净 查看是否安装过MySQL 1rpm -qa | grep -i mysql 删除MySQL 1yum -y remove MySQL-* 找出所有的目录使用rm -rf命令删除 1find / -name mysql 删除my.cnf配置文件 1rm -rf /etc/my.cnf 删除MySQL默认密码 1rm -rf /root/.mysql_sercret 配置MySQL安装源 1sudo rpm -Uvh https://dev.mysql.com/get/mysql80-community-release-el7-3.noarch.rpm 安装MySQL 8.0 1sudo yum --enablerepo=mysql80-community install mysql-community-server 配置MySQL 启动MySQL服务 1systemctl start mysqld.service 查看MySQL运行状态 1systemctl status mysqld.service 通过vim /etc/my.cnf修改字符集配置，在[mysqld]节点下添加，并保存退出 12default-character-set=utf8character-set-server=utf8 开放3306端口，并重启防火墙 12firewall-cmd --zone=public --add-port=3306/tcp --permanentfirewall-cmd --reload 查看root临时密码 1grep \"A temporary password\" /var/log/mysqld.log 更改临时密码 1ALTER USER 'root'@'localhost' IDENTIFIED BY 'new password'; 使用select user,host from mysql.user;查看是否有匿名用户，使用delete from mysql.user where user='';删除所有的匿名用户 插入新用户，为新用户赋予所有权限 12CREATE USER myuser IDENTIFIED BY 'mypass';grant all privileges on databasename.tablename to 'user'@'host'； 创建新的数据库 1create database `mmall` default character set utf8 collate utf8_general_ci; 给账号开通所有外网权限 1grant all privileges on mmall.* to 'myuser'@'%'; 使用Navicat就可以进行远程连接了 ​ ​","link":"/2020/07/21/Linux/MySQL%E5%AE%89%E8%A3%85/"},{"title":"Linux&#x2F;JDK安装","text":"本文将介绍JDK 1.8在Centos 7下的安装使用。 我们需要卸载干净Centos本身携带的OpenJDK，使用命令rpm -qa | grep jdk查看当前安装的JDK，如下图所示 ​ 使用yum remove+名称命令将其卸载干净。 我们在 Oracle官网下载Linux对应的JDK rpm包，Oracle官网 将我们下载好的安装包放在/opt目录下，使用chmod 777 jdk-8u261-linux-x64.rpm命令将所有权限全部打开，使用rpm -ivh jdk-8u261-linux-x64.rpm命令安装JDK， 进行环境变量的配置，使用vim /etc/proflie编辑配置文件，在最下面添加三句配置 1234#这里使用你的JDK安装路径，使用rpm安装默认安装在/user目录下 export JAVA_HOME=/usr/java/jdk1.8.0_261-amd64 export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt/jar:$JAVA_HOME/lib/tools/jarexport PATH=$PATH:$JAVA_HOME/bin 最后使用source /ect/profile命令更新配置文件，通过java -version命令可以看到JDK已经安装成功 ​","link":"/2020/07/15/Linux/JDK%E5%AE%89%E8%A3%85/"},{"title":"Linux&#x2F;Tomcat安装","text":"本文将介绍Tomcat9.0.37在Centos 7下的安装使用。 在Tomcat官网下载apache-tomcat-9.0.37.tar.gz压缩包，并上传到Centos /opt文件夹中 ​ 使用tar -zxvf apache-tomcat-9.0.37.tar.gz命令解压安装包 使用vim /etc/profile配置环境变量，并使用source /etc/profile命令使配置生效 12#Tomcat环境变量配置export CATALINA_HOME=/opt/apache-tomcat-9.0.37 #这里是你Tomcat解压缩路径 进入con文件夹，编辑server.xml配置UTF-8字符集，添加URIEncoding=&quot;UTF-8&quot; 123&lt;Connector port=\"8080\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\" URIEncoding=\"UTF-8\"/&gt; 验证Tomcat是否安装成功，进入Tomcat目录中的bin文件夹，执行命令./startup.sh ，执行成功如下图所示","link":"/2020/07/15/Linux/Tomcat%E5%AE%89%E8%A3%85/"},{"title":"Linux&#x2F;Nginx安装","text":"本文将介绍Nginx1.18.0在Centos 7下的安装使用。 安装Nginx 在Nginx官网下载最新版本的Nginx1.18.0版本，并放在服务器的/opt目录下 使用yum install gcc命令安装gcc 使用yum install pcre-devel安装pcre-devel 使用yum install zlib zlib-devel安装zlib 使用yum install openssl openssl-devel安装openssl 使用tar -zxvf nginx-1.18.0.tar.gz解压缩 进入nginx目录执行./configure，完成后执行make命令，最后执行make install命令 配置Nginx 使用systemctl status firewalld.service查看防火墙运行状态 使用firewall-cmd --list-ports查看已经开放的端口 使用firewall-cmd --zone=public --add-port=80/tcp --permanent打开80端口 使用firewall-cmd --reload重启防火墙 进入/usr/local/nginx/conf，使用mkdir vhost创建vhost文件夹 使用vim nginx.conf进入配置文件添加include vhost/*.conf; 问题解决 出现503报错，这个问题是没有启动Tomcat，我们启动Tomcat后就可以解决 出现403报错，这个问题是权限不足，我们需要修改nginx.conf文件里面，将uer改为root，如下图所示：","link":"/2020/07/20/Linux/Nginx%E5%AE%89%E8%A3%85/"},{"title":"Linux&#x2F;vsftpd安装","text":"本文将介绍vsftp 3.0.2在Centos 7下的安装使用。 安装vsftp 使用yum -y install vsftpd安装vsftpd 默认配置文件在/etc/vsftpd/vsftpd.conf 创建虚拟用户 使用mkdir ftpfile创建用户文件夹(上传文件夹) 添加匿名用户：useradd ftpuser -d /ftpfile -s /sbin/nologin 修改ftpfile权限：chown -R ftpuser.ftpuser /ftpfile 重设ftpuser密码：passwd ftpuser 配置vsftpd 进入vsftpd根目录cd /etc/vsftpd 编辑配置文件vim vsftpd.conf 12345678ftpd_banner=Welcome to mmall FTP service.local_root=/ftpfileuse_localtime=yeschroot_list_enable=YESchroot_list_file=/etc/vsftpd/chroot_listanonymous_enable=NOpasv_min_port=61001pasv_max_port=62000 创建chroot_list文件，输入ftpuser 使用vim /etc/selinux/config，修改如下配置 1SELINUX=disabled 使用firewall-cmd --zone=public --add-port=61001-62000/tcp --permanent开启防火墙端口 打开ftp://192.168.111.105，输入用户名密码就可以访问了 注意：这里很可能会出现输入了正确的用户名和密码后，循环登录的问题。这个问题网上众说纷纭，但是我遇到的问题是这样的，我们进入user_list文件，如下图所示， ​ 可以看到，userlist_deny默认设置为YES，也就是说，不允许该文件里面的用户访问，我们只要删除ftpuser就可以正常访问了。 ​","link":"/2020/07/16/Linux/vsftpd%E5%AE%89%E8%A3%85/"},{"title":"Linux&#x2F;配置静态IP","text":"由于近期学习docker，需要两台CentOS 7 虚拟机，由于刚配置好的虚拟机使用动态IP，是没有办法上网的，所以顺手写下配置静态IP的方法。 配置虚拟网络编辑器首先，我们在 VMware 的选项卡中找到 “编辑” -&gt; “虚拟网络编辑器”，在弹出的窗口中点击 “更改设置” 在该界面配置子网IP和子网掩码 在NAT设置中配置配置网关 IP 然后在 Windows 中 “网络与Internet” -&gt; “以太网” -&gt; “更改适配器选项” 中配置虚拟机网络 在属性中”网络”选项卡下双击IPv4协议，对 IP地址、子网掩码、和默认网关进行配置，这里的配置要和 VMware 中保持一致 最后，还有一步非常关键，就是将当前 Windows 环境下的网络适配器共享给虚拟机网络 至此，虚拟机网络配置已经完成了。 配置Linux网络IP和网关在 Linux 系统中，我们此时是无法上网的，如下图所示 首先，我们需要通过修改 ifcfg-ens33 来修改IP配置，使用vim /etc/sysconfig/network-scripts/ifcfg-ens33 来修改配置文件 这里需要改动的地方如下： BOOTPROTO = static ONBOOT = yes IPADDR = 192.168.111.102 GATEWAY = 192.168.111.2 DNS1 = 114.114.114.114 DNS2 = 8.8.8.8 修改完如下图所示 至此，静态IP配置已经完成。 配置主机名称使用hostname命令可以查看当前主机的主机名称 通过vim /etc/hostname来配置主机名称，这里配置为 docker1 通过vim /etc/hosts来添加所有主机名和IP地址 最后，我们进入C:\\Windows\\System32\\drivers\\etc路径来修改host文件 以上就是静态IP配置的全部内容，重启机器后，就可以正常访问网络了。","link":"/2020/06/29/Linux/%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP/"},{"title":"LeetCode&#x2F;1. 两数之和","text":"1. 两数之和给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 示例 ： 1234给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题一开始很容易进入一个误区，就是先将数组排序，然后通过双指针解题(我不会告诉你我一开始就是这么想的)，最后发现返回的索引不正确。所以本题用了HashMap结构，Key为当前位置数值，Value为当前位置索引，遍历整个数组，先将temp = target - nums[i]计算出来，如果HashMap中已经存在temp的值，直接返回两者的索引即可，如果不存在，则将当前值存到HashMap中。 具体代码如下： 1234567891011121314class Solution { public int[] twoSum(int[] nums, int target) { Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); int temp = 0; for (int i = 0; i &lt; nums.length; i++) { temp = target - nums[i]; if (map.containsKey(temp)) { return new int[]{map.get(temp), i}; } map.put(nums[i], i); } return new int[]{}; }}","link":"/2020/09/18/LeetCode/1.%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"title":"LeetCode&#x2F;100. 相同的树","text":"100. 相同的树给定两个二叉树，编写一个函数来检验它们是否相同。 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。 示例1: 1234567输入: 1 1 / \\ / \\ 2 3 2 3 [1,2,3], [1,2,3]输出: true 示例 2: 1234567输入: 1 1 / \\ 2 2 [1,2], [1,null,2]输出: false 示例 3: 1234567输入: 1 1 / \\ / \\ 2 1 1 2 [1,2,1], [1,1,2]输出: false 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题思路也很简单，用到递归思想的时候，我们先想一个结点的情况应该怎么做。这道题让判断两个树是不是一样的树，那无非就是比较当前两个结点的值是不是相等的，是就递归遍历左子树、右子树。 具体代码如下： 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { public boolean isSameTree(TreeNode p, TreeNode q) { if (p == null &amp;&amp; q == null){ return true; } if (p == null || q == null){ return false; } if (p.val != q.val){ return false; } return isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right); }}","link":"/2020/09/16/LeetCode/100.%20%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/"},{"title":"LeetCode&#x2F;1002. 查找常用字符","text":"1002. 查找常用字符给定仅有小写字母组成的字符串数组 A，返回列表中的每个字符串中都显示的全部字符（包括重复字符）组成的列表。例如，如果一个字符在每个字符串中出现 3 次，但不是 4 次，则需要在最终答案中包含该字符 3 次。 你可以按任意顺序返回答案。 示例1: 12输入：[&quot;bella&quot;,&quot;label&quot;,&quot;roller&quot;]输出：[&quot;e&quot;,&quot;l&quot;,&quot;l&quot;] 示例 2： 12输入：[&quot;cool&quot;,&quot;lock&quot;,&quot;cook&quot;]输出：[&quot;c&quot;,&quot;o&quot;] 提示： 1 &lt;= A.length &lt;= 100 1 &lt;= A[i].length &lt;= 100 A[i][j] 是小写字母 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题没有什么奇淫巧技，就老老实实遍历就行了。我们遍历A数组中的每个字符串，然后遍历每个字符串的每个字符，如果当前字符出现了，就在计数数组相应位置的值加一，接着和chars[]数组中对应字母出现次数进行比较，取较小的，这样比较下来，就会获得列表中的每个字符串中都显示的全部字符（有点最大公约数的意味），最后将结果加入链表返回即可，这里注意chars[]数组的索引即为当期字母 - 'a'的值，值为该字母出现的次数。 具体实现代码如下： 123456789101112131415161718192021222324252627282930313233343536class Solution { public List&lt;String&gt; commonChars(String[] A) { if (A == null) return new ArrayList&lt;&gt;(); //创建两个数组，一个存放总的出现次数最小的数组，一个存放当前字符串各个字母出现次数 int[] chars = new int[26]; int[] count = new int[26]; Arrays.fill(chars, Integer.MAX_VALUE); for (int i = 0; i &lt; A.length; i++) { //记录当前字符串中各个字母出现次数 for (char c : A[i].toCharArray()) { count[c - 'a']++; } //取chars和count中次数最小的那个，有点类似于最大公约数的感觉 for (int j = 0; j &lt; 26; j++) { chars[j] = Math.min(chars[j], count[j]); } Arrays.fill(count, 0); } //将结果存入result并返回 List&lt;String&gt; result = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; chars.length; i++) { if (chars[i] != 0) { int temp = chars[i]; for (int j = 0; j &lt; temp; j++) { result.add(String.valueOf(Character.toChars(i + 'a'))); } } } return result; }}","link":"/2020/10/14/LeetCode/1002.%20%E6%9F%A5%E6%89%BE%E5%B8%B8%E7%94%A8%E5%AD%97%E7%AC%A6/"},{"title":"LeetCode&#x2F;1025. 除数博弈","text":"1025. 除数博弈爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。 最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作： 选出任一 x，满足 0 &lt; x &lt; N 且 N % x == 0 。 用 N - x 替换黑板上的数字 N 。 如果玩家无法执行这些操作，就会输掉游戏。 只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 false。假设两个玩家都以最佳状态参与游戏。 示例1: 123输入：2输出：true解释：爱丽丝选择 1，鲍勃无法进行操作。 示例 2： 123输入：3输出：false解释：爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。 提示： 1 &lt;= N &lt;= 1000 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：刚拿到题我是懵逼的，如何将实际的场景转化为数学情景，需要思考一番。参考了官方题解，其实这就是一道数学归纳的题型，我们可以列举前几项的情况，从中找出规律： 12345N = 1 的时候，区间 (0, 1) 中没有整数是 n 的因数，所以此时 Alice 败。N = 2 的时候，Alice 只能拿 1，N 变成 1，Bob 无法继续操作，故 Alice 胜。N = 3 的时候，Alice 只能拿 1，N 变成 2，根据 N = 2 的结论，我们知道此时 Bob 会获胜，Alice 败。N = 4 的时候，Alice 能拿 1 或 2，如果 Alice 拿 1，根据 N = 3 的结论，Bob 会失败，Alice 会获胜。N = 5 的时候，Alice 只能拿 1，根据 N = 4 的结论，Alice 会失败。 我们可以看到N为奇数的时候 Alice必败，N为偶数的时候 Alice 必胜，该 在N = 1和N = 2时结论成立，假设N = k时成立，则N = k+1时， 若k+1为奇数，则x为奇数，奇减奇得偶，故Bob拿偶，Alice拿奇必败 若k+1为偶数，x可奇可偶，Alice减去一个奇数，则剩下的数为奇数，Alice必胜 具体实现代码如下： 12345class Solution { public boolean divisorGame(int N) { return N % 2 == 0; }}","link":"/2020/07/24/LeetCode/1025.%20%E9%99%A4%E6%95%B0%E5%8D%9A%E5%BC%88/"},{"title":"LeetCode&#x2F;102. 二叉树的层序遍历","text":"102. 二叉树的层序遍历给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。 示例：二叉树：[3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 返回其层次遍历结果： 12345[ [3], [9,20], [15,7]] 来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 题解：具体代码如下： 1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) { if (root == null) return new ArrayList&lt;List&lt;Integer&gt;&gt;(); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); queue.add(root); while (!queue.isEmpty()) { int len = queue.size(); ArrayList&lt;Integer&gt; temp = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; len; i++) { TreeNode node = queue.poll(); temp.add(node.val); if (node.left != null) { queue.add(node.left); } if (node.right != null) { queue.add(node.right); } } result.add(temp); } return result; }}","link":"/2020/09/09/LeetCode/102.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"title":"LeetCode&#x2F;103. 二叉树的锯齿形层次遍历","text":"103. 二叉树的锯齿形层次遍历给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。 示例：给定二叉树 [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 返回锯齿形层次遍历如下： 12345[ [3], [20,9], [15,7]] 来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 题解：本题还是基于层序遍历的框架，题目所说的锯齿遍历，就是一行是正序，一行是反序，这种情况设置一个count变量，来隔行判断本行应该正序还是反序存储。 具体代码如下： 12345678910111213141516171819202122232425262728293031323334class Solution { public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) { List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;(); if (root == null) { return result; } Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); int count = 0; while (!queue.isEmpty()) { LinkedList&lt;Integer&gt; temp = new LinkedList&lt;&gt;(); int len = queue.size(); for (int i = 0; i &lt; len; i++) { TreeNode node = queue.poll(); if (count % 2 != 0) { //头插元素，即逆序 temp.add(0, node.val); } else { temp.add(node.val); } if (node.left != null) { queue.add(node.left); } if (node.right != null) { queue.add(node.right); } } count++; result.add(temp); } return result; }}","link":"/2020/09/12/LeetCode/103.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/"},{"title":"LeetCode&#x2F;104. 二叉树的最大深度","text":"104. 二叉树的最大深度给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例：给定二叉树 [3,9,20,null,null,15,7]， 3 / \\ 9 20 / \\ 15 7 返回它的最大深度 3 。 来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 题解：本题就是简单的DFS的应用，没有什么特殊的技巧，通过递归，循环遍历整棵树。 具体代码如下： 12345678class Solution { public int maxDepth(TreeNode root) { if (root == null) return 0; int left = maxDepth(root.left); int right = maxDepth(root.right); return Math.max(left, right) + 1; }} 本题也可用BFS做，但是时间复杂度不如深度优先搜索遍历。 具体代码如下： 12345678910111213141516171819202122232425class Solution { public int maxDepth(TreeNode root) { int depth = 0; if (root == null) { return 0; } Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while (!queue.isEmpty()) { int len = queue.size(); for (int i = 0; i &lt; len; i++) { TreeNode node = queue.poll(); if (node.left != null) { queue.add(node.left); } if (node.right != null) { queue.add(node.right); } } depth++; } return depth; }}","link":"/2020/09/12/LeetCode/104.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"},{"title":"LeetCode&#x2F;105. 从前序与中序遍历序列构造二叉树","text":"105. 从前序与中序遍历序列构造二叉树根据一棵树的前序遍历与中序遍历构造二叉树。 注意:你可以假设树中没有重复的元素。 例如，给出 12前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7] 返回如下的二叉树： 3 / \\ 9 20 / \\ 15 7 来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 题解：本题还是构造二叉树，基本思想就是根据preorder数组确定当前根节点的值，然后在inorder中寻找当前根节点值的位置，其左边为左子树，右边为右子树。这里需要注意的就是preorder递归区间的生成，我们可以依据inorder中根节点的索引来判断，左子树就是[preLeft + 1, preLeft + leftSize]，右子树就是[preLeft + leftSize + 1, preRight]，最终返回node即可。 具体代码如下： 1234567891011121314151617181920212223242526272829class Solution { public TreeNode buildTree(int[] preorder, int[] inorder) { return build(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1); } TreeNode build(int[] preorder, int preLeft, int preRight, int[] inorder, int inLeft, int inRight) { if (preLeft &gt; preRight) return null; int rootVal = preorder[preLeft]; int index = -1; for (int i = inRight; i &gt;= inLeft; i--) { if (inorder[i] == rootVal) { index = i; break; } } //用以确定区间 int leftSize = index - inLeft; TreeNode node = new TreeNode(rootVal); node.left = build(preorder, preLeft + 1, preLeft + leftSize, inorder, inLeft, index - 1); node.right = build(preorder, preLeft + leftSize + 1, preRight, inorder, index + 1, inRight); return node; }}","link":"/2020/11/13/LeetCode/105.%20%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"title":"LeetCode&#x2F;106. 从中序与后序遍历序列构造二叉树","text":"106. 从中序与后序遍历序列构造二叉树根据一棵树的中序遍历与后序遍历构造二叉树。 注意:你可以假设树中没有重复的元素。 例如，给出 中序遍历 inorder = [9,3,15,20,7]后序遍历 postorder = [9,15,7,20,3]返回如下的二叉树： 3 / \\ 9 20 / \\ 15 7 来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 题解：本题和105. 从前序与中序遍历序列构造二叉树思路基本一致略有不同。因为后序遍历是前序遍历的逆序，所以我们需要从后往前遍历postorder数组，然后从inorder找到这个根节点的索引，将inorder划分为左右子树，递归遍历即可生成整棵树。 具体代码如下： 12345678910111213141516171819202122232425262728class Solution { public TreeNode buildTree(int[] inorder, int[] postorder) { return build(inorder, 0, inorder.length - 1, postorder, 0, postorder.length - 1); } TreeNode build(int[] inorder, int inLeft, int inRight, int[] postorder, int postLeft, int postRight) { if (inLeft &gt; inRight) return null; int rootValue = postorder[postRight]; int index = -1; for (int i = inRight; i &gt;= inLeft; i--) { if (rootValue == inorder[i]) { index = i; break; } } int partition = index - inLeft; TreeNode node = new TreeNode(rootValue); node.right = build(inorder, index + 1, inRight, postorder, postLeft + partition, postRight - 1); node.left = build(inorder, inLeft, index - 1, postorder, postLeft, postLeft + partition - 1); return node; }}","link":"/2020/09/09/LeetCode/106.%20%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"title":"LeetCode&#x2F;107. 二叉树的层次遍历 II","text":"107. 二叉树的层次遍历 II给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历） 例如：给定二叉树 [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 返回其自底向上的层次遍历为： 12345[ [15,7], [9,20], [3]] 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题很好想，就是先对二叉树进行层次遍历，然后将结果逆序即可。 具体代码如下： 123456789101112131415161718192021222324252627282930313233343536class Solution { public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) { if (root == null) return new ArrayList&lt;&gt;(); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); queue.add(root); while (!queue.isEmpty()) { ArrayList&lt;Integer&gt; temp = new ArrayList&lt;&gt;(); int len = queue.size(); for (int i = 0; i &lt; len; i++) { TreeNode node = queue.poll(); temp.add(node.val); if (node.left != null) { queue.add(node.left); } if (node.right != null) { queue.add(node.right); } } result.add(temp); } return reverse(result); } //反转结果列表 public List&lt;List&lt;Integer&gt;&gt; reverse(List&lt;List&lt;Integer&gt;&gt; list) { List&lt;List&lt;Integer&gt;&gt; temp = new ArrayList&lt;&gt;(); for (int i = list.size() - 1; i &gt;= 0; i--) { temp.add(list.get(i)); } return temp; }}","link":"/2020/09/09/LeetCode/107.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%20II/"},{"title":"LeetCode&#x2F;11. 盛最多水的容器","text":"11. 盛最多水的容器给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。 图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 示例 ： 12输入：[1,8,6,2,5,4,8,3,7]输出：49 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题可以利用木桶原理来思考，即木桶能装多少水取决于最短的木板有多长。在本体中，我们定义两个指针，一个指向数组的头，另一个指向数组的尾，我们每次移动较短一侧的指针，比较盛水容量并获得最大值。 具体代码如下： 123456789101112131415161718class Solution { public int maxArea(int[] height) { int i = 0; int j = height.length - 1; int max = 0; while (i &lt;= j) { if (height[i] &lt; height[j]) { max = Math.max(max, (j - i) * Math.min(height[i], height[j])); i++; } else { max = Math.max(max, (j - i) * Math.min(height[i], height[j])); j--; } } return max; }} 123456789101112131415class Solution { public int maxArea(int[] height) { int i = 0; int j = height.length - 1; int max = 0; while (i &lt; j) { max = Math.max(max, (j - i) * Math.min(height[i], height[j])); if (height[i] &lt; height[j]) i++; else j--; } return max; }}","link":"/2020/07/17/LeetCode/11.%20%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"},{"title":"LeetCode&#x2F;111. 二叉树的最小深度","text":"111. 二叉树的最小深度给定一个二叉树，找出其最小深度。 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 说明: 叶子节点是指没有子节点的节点。 示例: 给定二叉树 [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 返回它的最小深度 2. 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题只需要找到左子树高度和右子树高度的最小值加一即可。具体来说进行递归调用，如果左子树为空，对右子树进行递归加一，如果右子树为空，对左子树进行递归加一，如果左右子树都存在，那么返回相对较小的高度加一的值。 具体代码如下： 1234567891011class Solution { public int minDepth(TreeNode root) { if (root == null) return 0; if (root.left == null) return minDepth(root.right) + 1; if (root.right == null) return minDepth(root.left) + 1; return Math.min(minDepth(root.left), minDepth(root.right)) + 1; }}","link":"/2020/10/12/LeetCode/111.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/"},{"title":"LeetCode&#x2F;112. 路经总和","text":"112. 路径总和给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。 说明: 叶子节点是指没有子节点的节点。 示例:给定如下二叉树，以及目标和sum = 22， 1234567 5 / \\ 4 8 / / \\ 11 13 4 / \\ \\7 2 1 返回 true, 因为存在目标和为22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题思想就是递归调用左右子树，观察树节点的值加起来是不是sum的值，具体代码如下： 1234567891011121314151617181920212223public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; }}class Solution { public boolean hasPathSum(TreeNode root, int sum) { //判断树是否为空，若为空直接返回false if (root == null) return false; //判断根的左右节点是否为空，若左右节点都为空，则返回sum - root.val的值与0作比较 //若根节点的值等于sum的值，则返回true，否则返回false if (root.left == null &amp;&amp; root.right == null) return sum - root.val == 0; //递归调用左子树，或上递归调用右子树，若左子树中或右子树中满足条件则返回true，否则返回false return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val); }}","link":"/2020/10/01/LeetCode/112.%20%E8%B7%AF%E7%BB%8F%E6%80%BB%E5%92%8C/"},{"title":"LeetCode&#x2F;114. 二叉树展开为链表","text":"114. 二叉树展开为链表给定一个二叉树，原地将它展开为一个单链表。 例如，给定二叉树 12345 1 / \\ 2 5 / \\ \\3 4 6 将其展开为： 12345678910111 \\ 2 \\ 3 \\ 4 \\ 5 \\ 6 来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 题解：本题分享一种最直观的思路，我们通过观察，可以发现该链表的顺序就是前序遍历，直接先进行前序遍历，然后原地组成链表即可。 具体代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.LinkedList;import java.util.List;/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { List&lt;TreeNode&gt; result = new LinkedList&lt;&gt;(); public void flatten(TreeNode root) { preOrder(root); for (int i = 1; i &lt; result.size(); i++) { TreeNode pre = result.get(i - 1); TreeNode curr = result.get(i); pre.left = null; pre.right = curr; } } void preOrder(TreeNode root) { if (root == null) { return; } result.add(root); preOrder(root.left); preOrder(root.right); }} 还有一种方法可以大幅度提高时间复杂度，但是不太好想，要用到递归的思想。我们思考每一个结点都需要做什么，基本上就是先将root的左右结点保存起来，然后将root.left赋值给root.right，并将root.left置为空，最后将原先保存的root.right接到新形成的树的后面即可。不需要考虑如何递归，只需要把每一个结点需要干什么想清楚就行。我们只需要对每个结点做上述操作，自然而然的进行递归后，左右子树就会被拉成链表。 具体代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.LinkedList;import java.util.List;/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { public void flatten(TreeNode root) { if (root == null) return; //将左右子树拉平成链表 flatten(root.left); flatten(root.right); //将根结点的左右子树保存 TreeNode left = root.left; TreeNode right = root.right; //左子树置空，原先的左子树接到root的右子树上 root.left = null; root.right = left; //将原来右子树续到新子树后面 TreeNode p = root; while (p.right != null) { p = p.right; } p.right = right; }}","link":"/2020/09/16/LeetCode/114.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/"},{"title":"LeetCode&#x2F;116. 填充每个节点的下一个右侧节点指针","text":"116. 填充每个节点的下一个右侧节点指针给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下： 123456struct Node { int val; Node *left; Node *right; Node *next;} 填充它的每个 next指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next指针设置为 NULL。 初始状态下，所有 next指针都被设置为 NULL。 示例: 12345输入：{&quot;$id&quot;:&quot;1&quot;,&quot;left&quot;:{&quot;$id&quot;:&quot;2&quot;,&quot;left&quot;:{&quot;$id&quot;:&quot;3&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:4},&quot;next&quot;:null,&quot;right&quot;:{&quot;$id&quot;:&quot;4&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:5},&quot;val&quot;:2},&quot;next&quot;:null,&quot;right&quot;:{&quot;$id&quot;:&quot;5&quot;,&quot;left&quot;:{&quot;$id&quot;:&quot;6&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:6},&quot;next&quot;:null,&quot;right&quot;:{&quot;$id&quot;:&quot;7&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:7},&quot;val&quot;:3},&quot;val&quot;:1}输出：{&quot;$id&quot;:&quot;1&quot;,&quot;left&quot;:{&quot;$id&quot;:&quot;2&quot;,&quot;left&quot;:{&quot;$id&quot;:&quot;3&quot;,&quot;left&quot;:null,&quot;next&quot;:{&quot;$id&quot;:&quot;4&quot;,&quot;left&quot;:null,&quot;next&quot;:{&quot;$id&quot;:&quot;5&quot;,&quot;left&quot;:null,&quot;next&quot;:{&quot;$id&quot;:&quot;6&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:7},&quot;right&quot;:null,&quot;val&quot;:6},&quot;right&quot;:null,&quot;val&quot;:5},&quot;right&quot;:null,&quot;val&quot;:4},&quot;next&quot;:{&quot;$id&quot;:&quot;7&quot;,&quot;left&quot;:{&quot;$ref&quot;:&quot;5&quot;},&quot;next&quot;:null,&quot;right&quot;:{&quot;$ref&quot;:&quot;6&quot;},&quot;val&quot;:3},&quot;right&quot;:{&quot;$ref&quot;:&quot;4&quot;},&quot;val&quot;:2},&quot;next&quot;:null,&quot;right&quot;:{&quot;$ref&quot;:&quot;7&quot;},&quot;val&quot;:1}解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。 提示： 你只能使用常量级额外空间。 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。 来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 题解：本题想法很简单，就是将左结点的next与右结点相连即可，但是有一种情况我们需要考虑，就是不同父结点的两个结点怎么连接的问题，这时其实就是让左父结点的右孩子结点连接右父结点的左孩子结点连接即可。我们可以用前序遍历的思想来做。 具体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344/*// Definition for a Node.class Node { public int val; public Node left; public Node right; public Node next; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, Node _left, Node _right, Node _next) { val = _val; left = _left; right = _right; next = _next; }};*/class Solution { public Node connect(Node root) { if (root == null || root.left == null) { return root; } connectPass(root.left, root.right); return root; } void connectPass(Node node1, Node node2) { if (node1 == null || node2 == null) { return; } node1.next = node2; connectPass(node1.left, node1.right); connectPass(node2.left, node2.right); connectPass(node1.right, node2.left); }} 还有一种方法可以进一步压缩时间复杂度，和上面的思路大同小异，直接看代码 具体代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940/*// Definition for a Node.class Node { public int val; public Node left; public Node right; public Node next; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, Node _left, Node _right, Node _next) { val = _val; left = _left; right = _right; next = _next; }};*/class Solution { public Node connect(Node root) { if (root == null) return null; dfs(root, null); return root; } private void dfs(Node curr, Node next) { if (curr == null) return; curr.next = next; dfs(curr.left, curr.right); dfs(curr.right, curr.next == null ? null : curr.next.left); }} 另一种方法很直观就能想到，每一层的各个左结点和右结点连接，其实就是层序遍历。 具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/*// Definition for a Node.class Node { public int val; public Node left; public Node right; public Node next; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, Node _left, Node _right, Node _next) { val = _val; left = _left; right = _right; next = _next; }};*/import java.util.LinkedList;import java.util.Queue;class Solution { public Node connect(Node root) { if (root == null) { return root; } Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while (!queue.isEmpty()) { int len = queue.size(); for (int i = 0; i &lt; len; i++) { Node temp = queue.poll(); //这里控制不越界 if (i &lt; len - 1) { //连接当前节点和下一个节点 temp.next = queue.peek(); } if (temp.left != null) { queue.add(temp.left); } if (temp.right != null) { queue.add(temp.right); } } } return root; }}","link":"/2020/10/15/LeetCode/116.%20%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88/"},{"title":"LeetCode&#x2F;113. 路径总和 II","text":"113. 路径总和 II给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。 说明: 叶子节点是指没有子节点的节点。 示例:给定如下二叉树，以及目标和sum = 22， 1234567 5 / \\ 4 8 / / \\ 11 13 4 / \\ \\7 2 1 返回： 1234[ [5,4,11,2], [5,8,4,5]] 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题思想就是深度优先搜索遍历，只不过在遍历的时候需要判断当前路径上的结点数值之和是否等于sum。 具体代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { //存放结果 List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) { //临时链表，用来存放满足条件的一条路径 LinkedList&lt;Integer&gt; temp = new LinkedList&lt;&gt;(); dfs(root, sum, temp); return result; } void dfs(TreeNode node, int sum, LinkedList&lt;Integer&gt; temp) { //当结点为空时返回 if (node == null) return; //如果不为空，将当前结点的值添加到临时链表中，同时sum减去当前结点的值 temp.add(node.val); sum = sum - node.val; //如果当前结点时叶子结点且该路径数值之和等于sum，那么将该条满足条件的路径添加到result数组中 if (node.left == null &amp;&amp; node.right == null &amp;&amp; sum == 0) { result.add(new LinkedList&lt;&gt;(temp)); temp.pollLast(); return; } //递归遍历左右子树 dfs(node.left, sum, temp); dfs(node.right, sum, temp); //最后需要将当前结点弹出以进行下条路径的遍历 temp.pollLast(); }}","link":"/2020/11/23/LeetCode/113.%20%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%20II/"},{"title":"LeetCode&#x2F;117. 填充每个节点的下一个右侧节点指针 II","text":"117. 填充每个节点的下一个右侧节点指针 II给定一个二叉树 123456struct Node { int val; Node *left; Node *right; Node *next;} 填充它的每个 next指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next指针设置为 NULL。 初始状态下，所有 next指针都被设置为 NULL。 示例: 123输入：root = [1,2,3,4,5,null,7]输出：[1,#,2,3,#,4,5,7,#]解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。 提示： 树中的节点数小于 6000 -100 &lt;= node.val &lt;= 100 来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 题解：本题和116. 填充每个节点的下一个右侧节点指针一毛一样，就是层序遍历。 具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/*// Definition for a Node.class Node { public int val; public Node left; public Node right; public Node next; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, Node _left, Node _right, Node _next) { val = _val; left = _left; right = _right; next = _next; }};*/import java.util.LinkedList;import java.util.Queue;class Solution { public Node connect(Node root) { if (root == null) { return root; } Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while (!queue.isEmpty()) { int len = queue.size(); for (int i = 0; i &lt; len; i++) { Node temp = queue.poll(); if (i &lt; len - 1) { temp.next = queue.peek(); } if (temp.left != null) queue.add(temp.left); if (temp.right != null) queue.add(temp.right); } } return root; }}","link":"/2020/09/15/LeetCode/117.%20%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88%20II/"},{"title":"LeetCode&#x2F;120. 三角形最小路径和","text":"120. 三角形最小路径和给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。 相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。 例如，给定三角形： 123456[ [2], [3,4], [6,5,7], [4,1,8,3]] 自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。 说明： 如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题若是不考虑说明中的优化空间，思路很清晰，就是动态规划。首先能想到的就是，第i个位置的路径和，与上一行相邻的元素有关，由于要求最短的路径和，所以就是在第i-1行相邻元素中选择一个最小的累加，即$dp[i][j]=min(dp[i-1][j-1],dp[i-1][j])+triangle[i][j]$，这就是状态转移方程。下面我们需要考虑一些细节，比如每行的第一个元素，它没有左邻居，所以状态转移方程为$dp[i][0]=dp[i-1][0]+triangle[i][0]$，同样要考虑的还有每行最后一个元素，它没有右邻居，所以状态转移方程为$dp[i][i]=dp[i-1][i-1]+triangle[i][i]$，最后，dp数组的最后一行就是所有路径结果和，我们只需要遍历最后一行，找出最小的值即为结果值。 具体代码如下： 12345678910111213141516171819202122232425class Solution { public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) { int n = triangle.size(); int[][] dp = new int[n][n]; //创建一个二维数组来存放最短路径和 dp[0][0] = triangle.get(0).get(0); //三角形第一行只有一个元素，所以dp[0][0]就为第一行元素值 for (int i = 1; i &lt; n; i++) { dp[i][0] = dp[i - 1][0] + triangle.get(i).get(0); //每行第一个元素只与上一个第一个元素有关 dp[i][i] = dp[i - 1][i - 1] + triangle.get(i).get(i); //每行最后一个元素只与斜对角线上的上一行元素有关 for (int j = 1; j &lt; i; j++) { //普通位置元素与上一行j-1和j的元素值有关 dp[i][j] = Math.min(dp[i - 1][j - 1], dp[i - 1][j]) + triangle.get(i).get(j); } } //结果数组的最后一行存放着各个情况的路径和，只需要遍历找出最小的即可 int result = dp[n - 1][0]; for (int i = 0; i &lt; n; i++) { result = Math.min(result, dp[n - 1][i]); } return result; }} 当然，这种做法空间复杂度都比较惨烈，我们来思考一下空间还有没有更进一步优化的空间。 通常，动态规划优化空间复杂度都是去除存储的无关值，在本题中，可以看到dp[i][j]只与上一层的dp[i-1][j-1]和dp[i-1][j]有关，所以我们只需要记录这些值即可，具体的思想这里参考了官方题解。要想优化到O(n)的空间复杂度，就需要使用一维数组存储结果。从 i 到0递减地枚举j，这样我们只需要一个长度为n的一维数组f，就可以完成状态转移，即$dp[j]=min(dp[j-1],dp[j])+triangle[i][j]$ 具体代码如下： 1234567891011121314151617181920212223242526class Solution { public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) { int n = triangle.size(); int[] dp = new int[n]; //创建一个二维数组来存放最短路径和 dp[0] = triangle.get(0).get(0); //三角形第一行只有一个元素，所以dp[0][0]就为第一行元素值 for (int i = 1; i &lt; n; i++) { //这里由于使用逆序遍历，所以三条语句的顺序不能打乱，不然会使得结果出错 dp[i] = dp[i - 1] + triangle.get(i).get(i); for (int j = i - 1; j &gt; 0; j--) { dp[j] = Math.min(dp[j - 1], dp[j]) + triangle.get(i).get(j); } dp[0] = dp[0] + triangle.get(i).get(0); } int result = dp[0]; for (int i = 1; i &lt; n; i++) { result = Math.min(result, dp[i]); } return result; }}","link":"/2020/07/14/LeetCode/120.%20%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"},{"title":"LeetCode&#x2F;121. 买卖股票的最佳时机","text":"121. 买卖股票的最佳时机给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。 注意：你不能在买入股票前卖出股票。 示例 1: 1234输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。 示例 2: 123输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题思想其实很简单，就是低买高卖。具体来说，我们只需要在股票价格最低时买入，在高价时卖出，但是这里需要注意一点就是，低价购入的时机必须出现在高价卖出之前，不然没有意义。基于以上的思路，我们很容易就能写出代码。 具体代码如下： 123456789101112131415161718class Solution { public int maxProfit(int[] prices) { int maxProfit = 0; int minProfit = Integer.MAX_VALUE; for (int i = 0; i &lt; prices.length; i++) { //如果当前价格比卖出的最小利润还小，则将当前价格赋值给最小利润 if (prices[i] &lt; minProfit) { minProfit = prices[i]; } //找出最大利润 if (prices[i] - minProfit &gt; maxProfit) { maxProfit = prices[i] - minProfit; } } return maxProfit; }} 记录一下动态规划的解法，每天(除了第一天之外)只有三种状态，即买入、休息、卖出，那么限制只能持有一只股票，那么每天的状态就分为两种， 第一种状态是当天持有股票，这种又分为两种： 一是前一天持有一支股票 二是当天买入了一支股票。 所以此时的最大利润就是前一天持有股票时的最大利润和当前买入一支股票后获得的最大利润中的较大值。状态转移方程为： T[i][0]=Math.max(T[i-1][0],T[i-1][1]+prices[i]) 第二种状态是当天没有持有股票获得的最大利润，这种也分为两种： 一是今天休息，即前一天也没有持有股票 二是今天卖出了一支股票，获取了利润 所以此时的最大利润就是前一天没有持有股票的最大利润和当天卖出一支股票后获得的最大利润中的较大值。状态转移方程为： T[i][1] = Math.max(T[i-1][1],-prices[i])那么我们可以用一个二维数组来记录每天是否持有股票时获得的最大利润，这里注意边界条件，即T[0][0]表示第一天没有持有股票能获取的最大利润，此时自然为0，T[0][1]表示第一天就买入了一支股票能获取的最大利润， 此时就是第一天股票的价格的负数，即亏损。 具体代码如下： 123456789101112131415class Solution { public int maxProfit(int[] prices) { if (prices.length == 0) return 0; int[][] T = new int[prices.length][2]; T[0][0] = 0; T[0][1] = -prices[0]; for (int i = 1; i &lt; prices.length; i++) { T[i][0] = Math.max(T[i - 1][0], T[i - 1][1] + prices[i]); T[i][1] = Math.max(T[i - 1][1], - prices[i]); } return T[prices.length - 1][0]; }} 由于当天状态之和前一天状态有关，那么我们可以将空间复杂度降到常量范围，即用两个整型变量保存是否持有股票的两种收益。 具体代码如下： 1234567891011121314class Solution { public int maxProfit(int[] prices) { if (prices.length == 0) return 0; int notHave = 0; int have = -prices[0]; for (int i = 1; i &lt; prices.length; i++) { notHave = Math.max(notHave, have + prices[i]); have = Math.max(have, -prices[i]); } return notHave; }}","link":"/2020/11/04/LeetCode/121.%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/"},{"title":"LeetCode&#x2F;122. 买卖股票的最佳时机 II","text":"122. 买卖股票的最佳时机 II给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 1234输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例 2: 12345输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3: 123输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 提示： 1 &lt;= prices.length &lt;= 3 * 10 ^ 4 0 &lt;= prices[i] &lt;= 10 ^ 4 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题和121. 买卖股票的最佳时机大同小异，只不过此次不限制股票购买次数，我们依旧可以用动态规划的思想来解决问题，依旧分为三种情况，买入、休息和卖出，此题的状态转移方程与121. 买卖股票的最佳时机唯一的不同就是在当天持有股票时最大利润的状态转移方程为T[i][1] = Math.max(T[i - 1][1], T[i - 1][0] - prices[i])。 具体代码如下： 1234567891011121314class Solution { public int maxProfit(int[] prices) { if (prices.length == 0) return 0; int[][] T = new int[prices.length][2]; T[0][0] = 0; T[0][1] = -prices[0]; for (int i = 1; i &lt; prices.length; i++) { T[i][0] = Math.max(T[i - 1][0], T[i - 1][1] + prices[i]); T[i][1] = Math.max(T[i - 1][1], T[i - 1][0] - prices[i]); } return T[prices.length - 1][0]; }} 同样我们可以优化空间复杂度。 具体代码如下： 12345678910111213class Solution { public int maxProfit(int[] prices) { if (prices.length == 0) return 0; int notHave = 0; int have = -prices[0]; for (int i = 1; i &lt; prices.length; i++) { notHave = Math.max(notHave, have + prices[i]); have = Math.max(have, notHave - prices[i]); } return notHave; }} 官方给的一次遍历的方法也很棒，具体来说就是，总利润是每个价格上升区间累计值之和，我们只需要遍历一次，将所有利润累计值加起来即可得到结果。 具体代码如下： 12345678910class Solution { public int maxProfit(int[] prices) { int maxprofit = 0; for (int i = 1; i &lt; prices.length; i++) { if (prices[i] &gt; prices[i - 1]) maxprofit += prices[i] - prices[i - 1]; } return maxprofit; }}","link":"/2020/11/04/LeetCode/122.%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%20II/"},{"title":"LeetCode&#x2F;123. 买卖股票的最佳时机 III","text":"123. 买卖股票的最佳时机 III给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。 注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 1234输入: [3,3,5,0,0,3,1,4]输出: 6解释: 在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。 随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。 示例 2: 12345输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3: 123输入: [7,6,4,3,1] 输出: 0 解释: 在这个情况下, 没有交易完成, 所以最大利润为 0。 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题和121. 买卖股票的最佳时机有异曲同工之处，121. 买卖股票的最佳时机只能买卖一次，而本题可以买卖两次，套用121. 买卖股票的最佳时机的状态转移方程有 T[i][2][0] = Math.max(T[i-1][2][0],T[i-1][2][1]+prices[i]) \\\\ T[i][2][1] = Math.max(T[i-1][2][1],T[i-1][1][0] - prices[i]) \\\\ T[i][1][0] = Math.max(T[i-1][1][0],T[i-1][1][1]+prices[i]) \\\\ T[i][1][1] = Math.max(T[i-1][1][1],T[i-1][0][0] - prices[i]) \\\\其中第二维代表可买卖股票数目。 具体代码如下： 12345678910111213141516171819class Solution { public int maxProfit(int[] prices) { if (prices.length == 0) return 0; int[][][] T = new int[prices.length][3][2]; T[0][2][0] = 0; T[0][2][1] = -prices[0]; T[0][1][0] = 0; T[0][1][1] = -prices[0]; for (int i = 1; i &lt; prices.length; i++) { T[i][2][0] = Math.max(T[i - 1][2][0], T[i - 1][2][1] + prices[i]); T[i][2][1] = Math.max(T[i - 1][2][1], T[i - 1][1][0] - prices[i]); T[i][1][0] = Math.max(T[i - 1][1][0], T[i - 1][1][1] + prices[i]); T[i][1][1] = Math.max(T[i - 1][1][1], -prices[i]); } return T[prices.length - 1][2][0]; }} 同样我们可以优化空间复杂度。 具体代码如下： 12345678910111213141516171819class Solution { public int maxProfit(int[] prices) { if (prices.length == 0) return 0; int[][][] T = new int[prices.length][3][2]; int profitTwo0 = 0; int profitTwo1 = -prices[0]; int profitOne0 = 0; int profitOne1 = -prices[0]; for (int i = 1; i &lt; prices.length; i++) { profitTwo0 = Math.max(profitTwo0, profitTwo1 + prices[i]); profitTwo1 = Math.max(profitTwo1, profitOne0 - prices[i]); profitOne0 = Math.max(profitOne0, profitOne1 + prices[i]); profitOne1 = Math.max(profitOne1, -prices[i]); } return profitTwo0; }}","link":"/2020/11/04/LeetCode/123.%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%20III/"},{"title":"LeetCode&#x2F;125. 验证回文串","text":"125. 验证回文串给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 说明：本题中，我们将空字符串定义为有效的回文串。 示例1: 12输入: &quot;A man, a plan, a canal: Panama&quot;输出: true 示例2： 12输入: &quot;race a car&quot;输出: false 来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 题解：本题思想就是双指针，一个指向头，一个指向尾，然后向彼此方向靠近。但是本题有个需要注意的点就是字符串中有可能出现标点符号和空格，我们调用Java API Character.isLetterOrDigit()来判断是不是字符串(自己手写判断方法也很简单，就是根据ASCII码判断)，我们越过所有的标点符号，然后判断是不是回文字符串就行。 具体代码如下： 1234567891011121314151617class Solution { public boolean isPalindrome(String s) { int left = 0, right = s.length() - 1; while (left &lt; right) { while (left &lt; right &amp;&amp; !Character.isLetterOrDigit(s.charAt(left))) left++; while (left &lt; right &amp;&amp; !Character.isLetterOrDigit(s.charAt(right))) right--; if (Character.toLowerCase(s.charAt(left)) != Character.toLowerCase(s.charAt(right))) { return false; } left++; right--; } return true; }}","link":"/2020/09/22/LeetCode/125.%20%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2/"},{"title":"LeetCode&#x2F;1288. 删除被覆盖区间","text":"1288. 删除被覆盖区间给你一个区间列表，请你删除列表中被其他区间所覆盖的区间。 只有当 c &lt;= a 且 b &lt;= d 时，我们才认为区间 [a,b) 被区间 [c,d) 覆盖。 在完成所有删除操作后，请你返回列表中剩余区间的数目。 示例： 123输入：intervals = [[1,4],[3,6],[2,8]]输出：2解释：区间 [3,6] 被区间 [2,8] 覆盖，所以它被删除了。 提示： 1 &lt;= intervals.length &lt;= 1000 0 &lt;= intervals[i][0] &lt; intervals[i][1] &lt;= 10^5 对于所有的i != j：intervals[i] != intervals[j] 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：遇到区间问题，先排序。对于本题，按照第一个元素升序，第二个元素降序排列，这样排列过后就会出现三种情况：1. 前一个区间完全覆盖当前区间，那么就可以将当前区间删除；2. 两个区间相交，这时候取两个区间的并集，合并成一个大区间；3. 两个区间没有交集，这时候由于数组已经排过序，所以直接将临时比较的区间[left, right]赋值成当前区间即可。 具体代码如下： 12345678910111213141516171819202122232425262728293031323334class Solution { public int removeCoveredIntervals(int[][] intervals) { //对数组进行排序，要求第一个位置升序，第二个位置降序排列 Arrays.sort(intervals, (a, b) -&gt; { if (a[0] == b[0]) return b[1] - a[1]; return a[0] - b[0]; }); int left = intervals[0][0]; int right = intervals[0][1]; int result = 0; for (int i = 1; i &lt; intervals.length; i++) { int[] temp = intervals[i]; //第一种情况，[left, right]完全覆盖当前区间 if (left &lt;= temp[0] &amp;&amp; right &gt;= temp[1]) { //记录被覆盖区间个数 result++; } //第二种情况，[left, right]与temp区间交叉 if (right &gt;= temp[0] &amp;&amp; right &lt;= temp[1]) right = temp[1]; //第三种情况，两个区间没有任何交叉 if (temp[0] &gt;= right) { left = temp[0]; right = temp[1]; } } //由于记录的是被覆盖数组个数，题目要求剩余个数 return intervals.length - result; }}","link":"/2020/10/06/LeetCode/1288.%20%E5%88%A0%E9%99%A4%E8%A2%AB%E8%A6%86%E7%9B%96%E5%8C%BA%E9%97%B4/"},{"title":"LeetCode&#x2F;129. 求根到叶子节点数字之和","text":"129. 求根到叶子节点数字之和给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。 例如，从根到叶子节点路径 1-&gt;2-&gt;3 代表数字 123。 计算从根到叶子节点生成的所有数字之和。 说明: 叶子节点是指没有子节点的节点。 示例1: 123456789输入: [1,2,3] 1 / \\ 2 3输出: 25解释:从根到叶子节点路径 1-&gt;2 代表数字 12.从根到叶子节点路径 1-&gt;3 代表数字 13.因此，数字总和 = 12 + 13 = 25. 示例 2: 123456789101112输入: [4,9,0,5,1] 4 / \\ 9 0 / \\5 1输出: 1026解释:从根到叶子节点路径 4-&gt;9-&gt;5 代表数字 495.从根到叶子节点路径 4-&gt;9-&gt;1 代表数字 491.从根到叶子节点路径 4-&gt;0 代表数字 40.因此，数字总和 = 495 + 491 + 40 = 1026. 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题肯定是树的遍历，需要将每一条路径组成一个数字，可以观察到父节点的数值和子节点的数值是十倍关系，叶节点的特征就是左右子孩子都是空的，那么返回条件就是当遍历到一个节点，左右子孩子都为空的时候(也就是叶节点)，返回这条路径所组成的数字，如果是非叶节点那么就用result的值乘以十加上当前值，最后将所有路径组成的数字结果加起来就是最终要的结果 具体代码如下： 12345678910111213141516171819202122232425/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public int sumNumbers(TreeNode root) { int result = 0; return dfs(root, result); } private int dfs(TreeNode node, int result) { if (node == null) return 0; result = result * 10 + node.val; if (node.left == null &amp; node.right == null) { return result; } return dfs(node.left, result) + dfs(node.right, result); }}","link":"/2020/07/17/LeetCode/129.%20%E6%B1%82%E6%A0%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/"},{"title":"LeetCode&#x2F;134. 加油站","text":"134. 加油站在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。 你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。 如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。 说明: 如果题目有解，该答案即为唯一答案。 输入数组均为非空数组，且长度相同。 输入数组中的元素均为非负数。 示例1： 1234567891011121314输入: gas = [1,2,3,4,5]cost = [3,4,5,1,2]输出: 3解释:从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。因此，3 可为起始索引。 示例2: 12345678910111213输入: gas = [2,3,4]cost = [3,4,3]输出: -1解释:你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。因此，无论怎样，你都不可能绕环路行驶一周。 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题官方题解实属拉胯，这里参考了https://leetcode-cn.com/problems/gas-station/solution/shi-yong-tu-de-si-xiang-fen-xi-gai-wen-ti-by-cyayc/。 具体代码如下： 1234567891011121314151617class Solution { public int canCompleteCircuit(int[] gas, int[] cost) { int totalCost = 0; int minCost = Integer.MAX_VALUE; int minIndex = 0; for (int i = 0; i &lt; gas.length; i++) { totalCost = totalCost + gas[i] - cost[i]; if (totalCost &lt; minCost) { minCost = totalCost; minIndex = i; } } return totalCost &lt; 0 ? -1 : (minIndex + 1) % gas.length; }}","link":"/2020/09/01/LeetCode/134.%20%E5%8A%A0%E6%B2%B9%E7%AB%99/"},{"title":"LeetCode&#x2F;1356. 根据数字二进制下 1 的数目排序","text":"1356. 根据数字二进制下 1 的数目排序给你一个整数数组 arr 。请你将数组中的元素按照其二进制表示中数字 1 的数目升序排序。 如果存在多个数字二进制中 1 的数目相同，则必须将它们按照数值大小升序排列。 请你返回排序后的数组。 示例1： 1234567输入：arr = [0,1,2,3,4,5,6,7,8]输出：[0,1,2,4,8,3,5,6,7]解释：[0] 是唯一一个有 0 个 1 的数。[1,2,4,8] 都有 1 个 1 。[3,5,6] 有 2 个 1 。[7] 有 3 个 1 。按照 1 的个数排序得到的结果数组为 [0,1,2,4,8,3,5,6,7] 示例 2： 123输入：arr = [1024,512,256,128,64,32,16,8,4,2,1]输出：[1,2,4,8,16,32,64,128,256,512,1024]解释：数组中所有整数二进制下都只有 1 个 1 ，所以你需要按照数值大小将它们排序。 示例 3： 12输入：arr = [10000,10000]输出：[10000,10000] 示例 4： 12输入：arr = [2,3,5,7,11,13,17,19]输出：[2,3,5,17,7,11,13,19] 示例 5： 12输入：arr = [10,100,1000,10000]输出：[10,100,10000,1000] 提示： 1 &lt;= arr.length &lt;= 500 0 &lt;= arr[i] &lt;= 10^4 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题有个取巧的地方，就是提示告诉我们每个元素大小不会超过$10^4$，那么就可以调用Java 的 API，将每个元素的二进制形式的1的个数计算出来，然后乘以 100000，然后对其进行排序，最后再将元素还原即可。 具体代码如下： 123456789101112class Solution { public int[] sortByBits(int[] arr) { for (int i = 0; i &lt; arr.length; i++) { arr[i] += Integer.bitCount(arr[i]) * 100000; } Arrays.sort(arr); for (int i = 0; i &lt; arr.length; i++) { arr[i] %= 100000; } return arr; }}","link":"/2020/10/06/LeetCode/1356.%20%E6%A0%B9%E6%8D%AE%E6%95%B0%E5%AD%97%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%8B%201%20%E7%9A%84%E6%95%B0%E7%9B%AE%E6%8E%92%E5%BA%8F/"},{"title":"LeetCode&#x2F;138. 复制带随机指针的链表","text":"138. 复制带随机指针的链表给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。 要求返回这个链表的 深拷贝。 我们用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示： val：一个表示 Node.val 的整数。random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为 null 。 示例1： 12输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]输出：[[7,null],[13,0],[11,4],[10,2],[1,0]] 示例2： 12输入：head = [[1,1],[2,1]]输出：[[1,1],[2,1]] 示例3： 12输入：head = [[3,null],[3,0],[3,null]]输出：[[3,null],[3,0],[3,null]] 示例4： 123输入：head = []输出：[]解释：给定的链表为空（空指针），因此返回 null。 提示： -10000 &lt;= Node.val &lt;= 10000 Node.random 为空（null）或指向链表中的节点。 节点数目不超过 1000 。 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题解法五花八门，我在这里提供一种思路最简单的方法，就是利用HashMap。我们首先遍历一次链表，将每个结点复制一个相同的新结点并存入HashMap中，其中Key为原结点，Value为原结点的复制结点，第一遍遍历不用管每个结点的next和random指针。第二遍遍历链表，我们要利用每个原结点的next和random指针信息来完善新的复制链表，其中，新结点的next指向的就是原始结点next指向的结点对应的复制结点，即map.get(p).next = map.get(p.next);，新结点的random指向的就是原始结点的random所对应的复制结点，即map.get(p).random = map.get(p.random);最后我们返回HashMap中head对应的Value，即新的复制链表的头结点。 具体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041/*// Definition for a Node.class Node { int val; Node next; Node random; public Node(int val) { this.val = val; this.next = null; this.random = null; }}*/class Solution { public Node copyRandomList(Node head) { if (head == null) return head; Node p = head; //创建HashMap用来存放原始链表和新链表的对应关系 Map&lt;Node, Node&gt; map = new HashMap&lt;&gt;(); while (p != null) { Node temp = new Node(p.val); //将每个原始结点拷贝一份，其中原始结点作为Key，复制结点作为Value map.put(p, temp); p = p.next; } p = head; while (p != null) { //新结点的next就是原结点next指向的结点的复制结点 map.get(p).next = map.get(p.next); //新结点的random结点就是原始结点random指向的结点的复制结点 map.get(p).random = map.get(p.random); p = p.next; } //返回新链表的头结点即可 return map.get(head); }}","link":"/2020/11/23/LeetCode/138.%20%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/"},{"title":"LeetCode&#x2F;141. 环形链表","text":"141. 环形链表给定一个链表，判断链表中是否有环。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。 如果链表中存在环，则返回 true 。 否则，返回 false 。 进阶： 你能用 O(1)（即，常量）内存解决此问题吗？ 示例1: 123输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。 示例2： 123输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。 示例3： 123输入：head = [1], pos = -1输出：false解释：链表中没有环。 提示： 链表中节点的数目范围是 [0, 104] -105 &lt;= Node.val &lt;= 105 pos 为 -1 或者链表中的一个 有效索引 。 来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 题解：本题我们可以这样想，我一个指针走在前面，一个指针走在后面，前面的走得快，后面的走的慢，如果前面的和后面的能够相遇，那么就存在环，如果前面指针下个节点为空，说明没有环。 具体代码如下： 12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */public class Solution { public boolean hasCycle(ListNode head) { if (head == null) return false; ListNode slow = head, fast = head; while(fast != null &amp;&amp; fast.next != null){ fast = fast.next.next; slow = slow.next; if (fast == slow){ return true; } } return false; }}","link":"/2020/11/05/LeetCode/141.%20%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"},{"title":"LeetCode&#x2F;144. 二叉树的前序遍历","text":"144. 二叉树的前序遍历给定一个二叉树，返回它的 前序 遍历。 示例: 12345678输入: [1,null,2,3] 1 \\ 2 / 3 输出: [1,2,3] 进阶: 递归算法很简单，你可以通过迭代算法完成吗？ 来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 题解：本题递归的思想非常简单，直接套用模板即可 具体代码如下： 1234567891011121314151617181920/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); public List&lt;Integer&gt; preorderTraversal(TreeNode root) { if (root == null) return result; result.add(root.val); preorderTraversal(root.left); preorderTraversal(root.right); return result; }} 进阶要求使用迭代方式进行遍历，其实就是用栈结构来模拟DFS，我们用一个栈结构，因为前序遍历是中左右的结构，所以压栈的顺序应该为中右左，一次迭代就可以得到结果 具体代码如下： 12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); public List&lt;Integer&gt; preorderTraversal(TreeNode root) { if (root == null) return result; Deque&lt;TreeNode&gt; stack = new ArrayDeque&lt;&gt;(); stack.push(root); while (!stack.isEmpty()) { TreeNode temp = stack.pop(); result.add(temp.val); if (temp.right != null) stack.push(temp.right); if (temp.left != null) stack.push(temp.left); } return result; }}","link":"/2020/10/27/LeetCode/144.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"title":"LeetCode&#x2F;145. 二叉树的后序遍历","text":"145. 二叉树的后序遍历给定一个二叉树，返回它的 后序 遍历。 示例: 12345678输入: [1,null,2,3] 1 \\ 2 / 3 输出: [3,2,1] 来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 题解：具体代码如下： 12345678910111213141516171819202122232425/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public List&lt;Integer&gt; postorderTraversal(TreeNode root) { ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;(); tranverse(root, arrayList); return arrayList; } public static ArrayList&lt;Integer&gt; tranverse(TreeNode treeNode, ArrayList&lt;Integer&gt; result){ if (treeNode != null) { tranverse(treeNode.left, result); tranverse(treeNode.right, result); result.add(treeNode.val); } return result; }}","link":"/2020/09/09/LeetCode/145.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"title":"LeetCode&#x2F;15. 三数之和","text":"15. 三数之和给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 示例 ： 1234567给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题解法时间复杂度有点爆炸，但是思路比较好理解。我们创建三个指针，分别为p、left、right，这三个指针分别指向当前位置，以及当前位置后面的数组区间。通过观察可以发现，如果要满足三数之和为零，那么其中任意两数之和一定与第三个数是相反数。这样，首先对原数组进行排序，我们固定p，寻找nums[left] + nums[right] == -nums[p]的三个数，如果存在，就添加进result中，如果两数之和大于第三数，那么右指针向左移动，如果两数之和小于第三数，那么左指针向右移动，找到所有满足条件的三个数即可。 具体代码如下： 123456789101112131415161718192021222324252627282930class Solution { public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) { Arrays.sort(nums); //这里使用Set是为了去重 Set&lt;List&lt;Integer&gt;&gt; result = new HashSet&lt;&gt;(); int p = 0, left, right; while (p &lt; nums.length) { left = p + 1; right = nums.length - 1; while (left &lt; right) { if (nums[left] + nums[right] == -nums[p]) { ArrayList&lt;Integer&gt; temp = new ArrayList&lt;&gt;(); temp.add(nums[p]); temp.add(nums[left]); temp.add(nums[right]); result.add(temp); left++; right--; } else if (nums[left] + nums[right] &gt; -nums[p]) { right--; } else { left++; } } p++; } return new ArrayList&lt;&gt;(result); }}","link":"/2020/09/08/LeetCode/15.%20%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"title":"LeetCode&#x2F;1541. 平衡括号字符串的最少插入次数","text":"1541. 平衡括号字符串的最少插入次数给你一个括号字符串 s ，它只包含字符 '(' 和 ')'。一个括号字符串被称为平衡的当它满足： 任何左括号 '(' 必须对应两个连续的右括号 '))' 。左括号'('必须在对应的连续两个右括号'))'之前。比方说 &quot;())&quot;， &quot;())(())))&quot; 和 &quot;(())())))&quot; 都是平衡的，&quot;)()&quot;，&quot;()))&quot; 和 &quot;(()))&quot;都是不平衡的。 你可以在任意位置插入字符'('和')'使字符串平衡。 请你返回让s平衡的最少插入次数。 示例 1： 123输入：s = &quot;(()))&quot;输出：1解释：第二个左括号有与之匹配的两个右括号，但是第一个左括号只有一个右括号。我们需要在字符串结尾额外增加一个 ')' 使字符串变成平衡字符串 &quot;(())))&quot; 。 示例 2： 123输入：s = &quot;())&quot;输出：0解释：字符串已经平衡了。 示例 3： 123输入：s = &quot;))())(&quot;输出：3解释：添加 '(' 去匹配最开头的 '))' ，然后添加 '))' 去匹配最后一个 '(' 。 示例 4： 123输入：s = &quot;((((((&quot;输出：12解释：添加 12 个 ')' 得到平衡字符串。 示例 5： 123输入：s = &quot;)))))))&quot;输出：5解释：在字符串开头添加 4 个 '(' 并在结尾添加 1 个 ')' ，字符串变成平衡字符串 &quot;(((())))))))&quot; 。 提示： 1 &lt;= s.length &lt;= 10^5 s 只包含 '(' 和 ')' 。 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题还是括号匹配问题，但需要注意两个点。第一点就是遇到一个左括号后，对右括号的需求量增加2，第二点就是碰到一个左括号后，如果右括号的数量是奇数个，那么我们需要添加一个左括号，并对右括号的需求减一以保证一个左括号对应两个右括号。 具体代码如下： 12345678910111213141516171819202122232425class Solution { public int minInsertions(String s) { int insertCount = 0; int needNums = 0; for (int i = 0; i &lt; s.length(); i++) { if (s.charAt(i) == '(') { needNums += 2; if (needNums % 2 == 1) { insertCount++; needNums--; } } if (s.charAt(i) == ')') { needNums--; if (needNums == -1) { needNums = 1; insertCount++; } } } return insertCount + needNums; }}","link":"/2020/10/06/LeetCode/1541.%20%E5%B9%B3%E8%A1%A1%E6%8B%AC%E5%8F%B7%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%B0%91%E6%8F%92%E5%85%A5%E6%AC%A1%E6%95%B0/"},{"title":"LeetCode&#x2F;155. 最小栈","text":"155. 最小栈设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。 push(x) —— 将元素 x 推入栈中。pop() —— 删除栈顶的元素。top() —— 获取栈顶元素。getMin() —— 检索栈中的最小元素。 示例： 12345678910111213141516输入：[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;][[],[-2],[0],[-3],[],[],[],[]]输出：[null,null,null,null,-3,null,0,-2]解释：MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); --&gt; 返回 -3.minStack.pop();minStack.top(); --&gt; 返回 0.minStack.getMin(); --&gt; 返回 -2. 提示： pop、top 和 getMin 操作总是在 非空栈 上调用。 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题可能一看到题目，有可能会想到利用PriorityQueue来解决问题，但是PriorityQueue无法同时满足返回最小和栈结构。本题可以创建一个辅助栈专门存放当前最小的元素，返回栈中最小的元素直接操作最小栈中的元素即可，其他的操作按照正常的栈来操作。用不同的集合类可能会造成时间复杂度上的差异，这里使用Deque。 具体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041class MinStack { /** * initialize your data structure here. */ Deque&lt;Integer&gt; stack; Deque&lt;Integer&gt; minStack; public MinStack() { stack = new ArrayDeque(); minStack = new ArrayDeque(); minStack.push(Integer.MAX_VALUE); } public void push(int x) { stack.push(x); minStack.push(Math.min(minStack.peek(), x)); } public void pop() { stack.pop(); minStack.pop(); } public int top() { return stack.peek(); } public int getMin() { return minStack.peek(); }}/** * Your MinStack object will be instantiated and called as such: * MinStack obj = new MinStack(); * obj.push(x); * obj.pop(); * int param_3 = obj.top(); * int param_4 = obj.getMin(); */","link":"/2020/11/17/LeetCode/155.%20%E6%9C%80%E5%B0%8F%E6%A0%88/"},{"title":"LeetCode&#x2F;160. 相交链表","text":"160. 相交链表编写一个程序，找到两个单链表相交的起始节点。 如下面的两个链表： 在节点 c1 开始相交。 示例 1： 123输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3输出：Reference of the node with value = 8输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 示例 2： 123输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1输出：Reference of the node with value = 2输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 示例 3： 1234输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2输出：null输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。解释：这两个链表不相交，因此返回 null。 注意： 如果两个链表没有交点，返回 null. 在返回结果后，两个链表仍须保持原有的结构。 可假定整个链表结构中没有循环。 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题是左神讲过的原题，要判断两个链表是否相交，就需要消除两个链表的长度差(如果两链表长度相等可以忽略这一步)，具体做法就是定义两个指针分别指向两个链表，如果两个指针所指的当前结点不想等，则向后遍历。如果其中一个指针指向了链表的尾部，这时候另一个指针一定指向的是较长链表，我们把指向空的指针重新指向长链表的头结点(注意这里是指向长链表的头结点，即现在两个指针指向同一个链表)，然后再让两个指针一次一步继续向后走，当最开始指向长链表的指针到链表尾部的时候，将它指向短链表的头结点。此刻，两个指针交换了最初指向的链表，而且从此刻开始出发的话，两个指针距离链表尾部的距离是一样的，然后两个指针都向后遍历，如果遇到相等的结点，则证明两个链表相交，如果不相等则不相交。 具体代码如下： 1234567891011121314151617181920212223/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { ListNode p1 = headA, p2 = headB; while (p1 != p2) { p1 = p1 == null ? headB : p1.next; p2 = p2 == null ? headA : p2.next; } return p1; }}","link":"/2020/12/03/LeetCode/160.%20%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/"},{"title":"LeetCode&#x2F;167. 两数之和 II - 输入有序数组","text":"167. 两数之和 II - 输入有序数组给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。 函数应该返回这两个下标值 index1和 index2，其中 index1必须小于 index2。 说明: 返回的下标值（index1和 index2）不是从零开始的。 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。 示例1 ： 123输入: numbers = [2, 7, 11, 15], target = 9输出: [1,2]解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题首先想到就应该是双指针法，思路也很简单，就是一个指针指向开头，另一个指针指向结尾，然后判断指针所指向的两数之和是否等于target，如果相等就返回相应的index；如果不等判断两数之和和target的大小，如果和大于target，则需要index2向左移动以此来缩小和，如果和小于target，则需要index1向右移动以此来增大和。 具体代码如下： 1234567891011121314151617181920212223242526class Solution { public int searchInsert(int[] nums, int target) { if (nums.length == 0) return -1; int left = 0; //这里用right = nums.length，下面的while循环条件就用left &lt; right //这里如果是right = nums.length - 1，下面的循环条件就是left &lt;= right //这是因为使用right = nums.length循环判等的话会出现越界 int right = nums.length; while (left &lt; right) { int mid = left + (right - left) / 2; //防止left和right太大导致相加除二溢出 if (nums[mid] == target) { //如果target就是nums[mid]的值的话就直接返回 return mid; } if (target &gt; nums[mid]) { //如果target比nums[mid]大，我们向右子区间收缩，所以这里需要left = mid + 1 left = mid + 1; } if (target &lt; nums[mid]) { //因为我们上面的right = nums.length，并且循环条件为left &lt; right //所以这里不能使用right = mid - 1，具体的大家可以debug观察结果 right = mid; } } return left; }} 官方提示中还提到了二分查找，由于二分查找不能同时进行两个数的查找，我们最先能想到的就是固定一个数，然后去剩下的元素中找，看能不能找到一个值和target - numbers[i]的值相等，如果能，则返回两者索引，如果不能，则返回-1。 具体代码如下： 12345678910111213141516171819202122232425262728293031323334public class Solution { public int[] twoSum(int[] numbers, int target) { int right = numbers.length - 1; //固定一个值，在剩下的元素中找一个数是否等于target - numbers[i]的值 for (int i = 0; i &lt; numbers.length; i++) { if (numbers[i] + numbers[right] == target) { return new int[]{i + 1, right + 1}; } int index2 = binarySearch(numbers, i + 1, right, target - numbers[i]); if (index2 != -1) { return new int[]{i + 1, index2 + 1}; } } return new int[]{-1, -1}; } //手写binarySearch()方法，当然也可以直接调用Arrays.binarySearch()方法 public int binarySearch(int[] nums, int fromIndex, int toIndex, int target) { int left = fromIndex; int right = toIndex - 1; while (left &lt;= right) { int mid = left + (right - left) / 2; if (nums[mid] == target) return mid; else if (nums[mid] &gt; target) { right = mid - 1; } else if (nums[mid] &lt; target) { left = mid + 1; } } return -1; }}","link":"/2020/07/20/LeetCode/167.%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%20II%20-%20%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"},{"title":"LeetCode&#x2F;169. 多数元素","text":"169. 多数元素给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在多数元素。 示例1： 12输入: [3,2,3]输出: 3 示例2： 12输入: [2,2,1,1,1,2,2]输出: 2 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题利用HashMap和经过排序后返回的中位数就是众数其实都比较好像，这个摩尔投票法真的秀的人头皮发麻，这里依次记录三种解法。 具体代码如下： 利用HashMap： 12345678910111213141516171819202122class Solution { public int majorityElement(int[] nums) { int num = nums.length / 2; int result = 0; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); //先遍历一边数组，将元素作为Key，元素出现次数作为Value for (int i = 0; i &lt; nums.length; i++) { map.put(nums[i], map.getOrDefault(nums[i], 0) + 1); } //题目说明只有一个数出现次数大于数组长度一半，找到直接返回即可 Set&lt;Map.Entry&lt;Integer, Integer&gt;&gt; entries = map.entrySet(); for (Map.Entry&lt;Integer, Integer&gt; entry : entries) { if (entry.getValue() &gt; num) { result = entry.getKey(); break; } } return result; }} 利用排序后中位数即是众树： 123456class Solution { public int majorityElement(int[] nums) { Arrays.sort(nums); return nums[nums.length / 2]; }} 利用摩尔投票法： 摩尔投票法有两个推论 若记 众数 的票数为 +1 ，非众数 的票数为 -1 ，则一定有所有数字的 票数和 &gt;0 若数组的前 $a$ 个数字的 票数和 =0 ，则 数组剩余 $(n-a)$ 个数字的 票数和一定仍 &gt;0 ，即后 $(n-a)$ 个数字的 众数仍为 $x$。 所以，我们可以从第一个元素开始，假定第一个元素就是众数，我们每次遇到这个元素就+1​，其他元素就-1，如果votes==0，利用推论可以弃掉前面的元素，重新以当前元素开始，假定当前元素为众数继续向后遍历，最后返回x即是该数组众数。 12345678910class Solution { public int majorityElement(int[] nums) { int x = 0, votes = 0; for (int num : nums) { if (votes == 0) x = num; votes += num == x ? 1 : -1; } return x; }}","link":"/2020/11/23/LeetCode/169.%20%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/"},{"title":"LeetCode&#x2F;17. 电话号码的字母组合","text":"17. 电话号码的字母组合给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 示例 ： 12输入：&quot;23&quot;输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;]. 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题我们都应该能想到回溯，但是由于每个数字对应多个字母，需要考虑到所有字母的排列组合。最直观能想到的就是for循环，比如digits为23，我们需要在第一层for循环里遍历2对应的abc，然后嵌套循环3对应的def，这是在我们知道digits情况下可以这么考虑。但题目给定的digits不定，此时我们就需要用到递归，每次先将数字对应的字母取出来，然后进行递归求解。 具体代码如下： 12345678910111213141516171819202122232425262728293031323334class Solution { //存放数字字母对应表 HashMap&lt;Character, String&gt; map = new HashMap&lt;&gt;(); List&lt;String&gt; result = new LinkedList&lt;&gt;(); public List&lt;String&gt; letterCombinations(String digits) { if (digits.length() == 0) return result; map.put('2', \"abc\"); map.put('3', \"def\"); map.put('4', \"ghi\"); map.put('5', \"jkl\"); map.put('6', \"mno\"); map.put('7', \"pqrs\"); map.put('8', \"tuv\"); map.put('9', \"wxyz\"); StringBuilder track = new StringBuilder(); backtrack(digits, track, 0, map); return result; } void backtrack(String digits, StringBuilder track, int start, Map&lt;Character, String&gt; map) { if (track.length() == digits.length()) { result.add(track.toString()); return; } //取出每个数字对应的字母 String value = map.get(digits.charAt(start)); for (int i = 0; i &lt; value.length(); i++) { backtrack(digits, track.append(value.charAt(i)), start + 1, map); track.deleteCharAt(track.length() - 1); } }}","link":"/2020/09/10/LeetCode/17.%20%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/"},{"title":"LeetCode&#x2F;18. 四数之和","text":"18. 四数之和给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。 注意：答案中不可以包含重复的四元组。 示例 ： 12345678给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。满足要求的四元组集合为：[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题参考15. 三数之和的解法，需要固定两个指针，然后让另外两个指针遍历剩下的区间，找到满足条件的四个数添加到结果数组即可。这里可以通过剪枝进行加速，有四种情况： 当nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] &gt; target时，由于nums已经排过序，如果相邻四个数之和大于target，则证明剩下后面的四数之和都大于target，直接跳出循环即可； 当nums[i] + nums[n - 3] + nums[n - 2] + nums[n - 1] &lt; target时，当前i所指向的数字和区间后三个最大的数字之和小于target，则需要进行下一轮循环； 当nums[i] + nums[j] + nums[j + 1] + nums[j + 2] &gt; target时，同理需要跳出循环； 当nums[i] + nums[j] + nums[n - 2] + nums[n - 1] &lt; target时，同理需要进行下一轮循环。 具体代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution { List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) { int n = nums.length; if (n &lt; 4) return result; Arrays.sort(nums); for (int i = 0; i &lt; n - 3; i++) { if (nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] &gt; target) break; if (nums[i] + nums[n - 3] + nums[n - 2] + nums[n - 1] &lt; target) continue; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue; for (int j = i + 1; j &lt; n - 2; j++) { if (nums[i] + nums[j] + nums[j + 1] + nums[j + 2] &gt; target) break; if (nums[i] + nums[j] + nums[n - 2] + nums[n - 1] &lt; target) continue; if (j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) continue; int left = j + 1, right = n - 1; while (left &lt; right) { ArrayList&lt;Integer&gt; temp = new ArrayList&lt;&gt;(); int num = nums[i] + nums[j] + nums[left] + nums[right]; if (num == target) { temp.add(nums[i]); temp.add(nums[j]); temp.add(nums[left]); temp.add(nums[right]); result.add(new ArrayList&lt;&gt;(temp)); while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) left++; left++; while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) right--; right--; } else if (num &lt; target) { left++; } else { right--; } } } } return result; }}","link":"/2020/09/08/LeetCode/18.%20%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"title":"LeetCode&#x2F;19. 删除链表的倒数第N个节点","text":"19. 删除链表的倒数第N个节点给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 示例： 123给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5. 说明： 给定的 n 保证是有效的。 进阶： 你能尝试使用一趟扫描实现吗？ 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题思路比较简单，就是创建两个指针，我们为了方便称其为快慢指针，让快指针先走n步，接着让两个指针一起走，这样当快指针走到头的时候，慢指针就在要删除元素的前一个元素位置上，最后删除即可。这里需要注意，题目说明了给定的n保证是有效的，所以不会出现快指针走了好几个空指针慢指针才开始走的情况。 具体代码如下： 12345678910111213141516171819202122232425262728293031323334/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { ListNode fast = head, slow = head; //让快指针先走n步 while (n &gt; 0) { fast = fast.next; n--; } //考虑快指针已经走到头，此时应该是删除头结点，所以直接返回头结点的下一个结点就是所求链表 if (fast == null) { return head.next; } while (fast != null &amp;&amp; fast.next != null) { fast = fast.next; slow = slow.next; } //删除链表 slow.next = slow.next.next; return head; }}","link":"/2020/11/05/LeetCode/19.%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/"},{"title":"LeetCode&#x2F;198. 打家劫舍","text":"198. 打家劫舍你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 示例1 ： 1234输入：[1,2,3,1]输出：4解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 示例2： 1234输入：[2,7,9,3,1]输出：12解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。 提示： 0 &lt;= nums.length &lt;= 100 0 &lt;= nums[i] &lt;= 400 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题一看到是要求受益最大，那肯定就是动态规划了，这里有一点比较难想，就是偷过第i-1家后不能再偷第i家，否则会触发报警。当前收益最大有两种情况，第一种情况是前一家偷过了，那么当前最大收益就是前一天的最大收益，第二种情况是前一家没有偷过，那么当前的最大收益就是前前天的最大收益，加上当前能偷得钱的金额。 同时边界条件为dp[0] = nums[0],dp[1] = Math.max(nums[0], nums[1])，我们写出状态转移方程： dp[i] = Math.max(dp[i-1] , dp[i-2]+nums[i])具体代码如下： 1234567891011121314151617181920class Solution { public int rob(int[] nums) { //进行判空处理，这道题LeetCode卡的比较严 if (nums.length == 0 || nums == null) { return 0; } if (nums.length == 1){ return nums[0]; } //创建最大收益数组 int[] dp = new int[nums.length]; dp[0] = nums[0]; dp[1] = Math.max(nums[0], nums[1]); for (int i = 2; i &lt; nums.length; i++) { dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]); } //最后返回最大收益结果 return dp[nums.length - 1]; }} 一到动态规划的问题，那我们一定可以想办法优化空间复杂度，这里我们发现最大收益只与dp[i],dp[i-1],dp[i-2]有关，那么我们可以将一维数组优化为三个变量，这三个变量分别存储当前收益，前一天收益和前前一天收益。具体代码如下： 12345678910111213141516171819class Solution { public int rob(int[] nums) { if (nums.length == 0 || nums == null) { return 0; } if (nums.length == 1) { return nums[0]; } int dp0 = nums[0]; int dp1 = Math.max(nums[0], nums[1]); int dp2 = Math.max(dp0, dp1); for (int i = 2; i &lt; nums.length; i++) { dp2 = Math.max(dp1, dp0 + nums[i]); dp0 = dp1; dp1 = dp2; } return dp2; }}","link":"/2020/08/05/LeetCode/198.%20%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/"},{"title":"LeetCode&#x2F;200. 岛屿数量","text":"200. 岛屿数量给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。 此外，你可以假设该网格的四条边均被水包围。 示例 1： 1234567输入：grid = [ [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;], [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;], [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;], [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]]输出：1 示例 2： 1234567输入：grid = [ [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;], [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;], [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;], [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]]输出：3 提示： m == grid.length n == grid[i].length 1 &lt;= m, n &lt;= 300 grid[i][j] 的值为 '0' 或 '1' 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题深度优先搜索遍历是首选，我们通过遍历二维数组，找到当前位置为一的元素，在该位置进行DFS，将当前元素置为'0'，然后向该元素的上下左右进行遍历。本题当然也可以用广度优先搜索和并查集，但是相对较为繁琐，此处不再给出详细代码。 具体代码如下： 12345678910111213141516171819202122232425262728class Solution { public int numIslands(char[][] grid) { if (grid == null || grid.length == 0) { return 0; } int result = 0, row = grid.length, column = grid[0].length; for (int i = 0; i &lt; row; i++) { for (int j = 0; j &lt; column; j++) { if (grid[i][j] == '1') { result++; dfs(grid, i, j); } } } return result; } private void dfs(char[][] grid, int i, int j) { if (i &lt; 0 || j &lt; 0 || i &gt;= grid.length || j &gt;= grid[0].length || grid[i][j] == '0') return; grid[i][j] = '0'; dfs(grid, i - 1, j); dfs(grid, i + 1, j); dfs(grid, i, j - 1); dfs(grid, i, j + 1); }} 并查集框架： 12345678910111213141516private void union(int x, int y) { int xParent = find(x); int yParent = find(y); if (xParent == yParent) return; parent[x] = y;}private int find(int x) { while (x != parent[x]) { parent[x] = parent[parent[x]]; x = parent[x]; } return x;}","link":"/2020/10/26/LeetCode/200.%20%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/"},{"title":"LeetCode&#x2F;204. 计数质数","text":"204. 计数质数统计所有小于非负整数 n 的质数的数量。 示例1： 123输入：n = 10输出：4解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。 示例2： 12输入：n = 0输出：0 示例3： 12输入：n = 1输出：0 提示： 0 &lt;= n &lt;= 5 * 106 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：我们从小就知道数学里面判断一个数是否为质数，只需要判断从2到$\\sqrt{num}$中是否有数能够被num整除，如果有，那该数就不是质数，如果没有则该数为质数，根据该理论可以很容易写出代码。 具体代码如下： 1234567891011121314151617class Solution { public int countPrimes(int n) { int result = 0; for (int i = 2; i &lt; n; i++) { result += isPrimes(i) ? 1 : 0; } return result; } private boolean isPrimes(int num) { for (int i = 2; i * i &lt;= num; i++) { if (num % i == 0) return false; } return true; }} 但是该方法时间复杂度很高。考虑到数与数之间的关系，一个数的整数倍必然不是质数，而且当前数前面的倍数肯定已经被判断过了，我们每次只需要从i * i开始即可。 具体代码如下： 12345678910111213141516171819class Solution { public int countPrimes(int n) { boolean[] isPrime = new boolean[n]; for (int i = 2; i * i &lt; n; i++) { if (!isPrime[i]) { for (int j = i * i; j &lt; n; j += i) { isPrime[j] = true; } } } int result = 0; for (int i = 2; i &lt; n; i++) { if (!isPrime[i]) result++; } return result; }}","link":"/2020/12/03/LeetCode/204.%20%E8%AE%A1%E6%95%B0%E8%B4%A8%E6%95%B0/"},{"title":"LeetCode&#x2F;206. 反转链表","text":"206. 反转链表反转一个单链表。 示例 ： 12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 进阶:你可以迭代或递归地反转链表。你能否用两种方法解决这道题？ 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题最直观的想法就是修改每个节点的指向，让后一个节点的next指针指向前一个节点，但是因为让后一个节点指向前一个节点会造成链表断掉，所以我们还需要一个临时节点存储当前节点。每次将curr和pre向后移动，将当前节点用临时节点存储起来，当前节点的next指向pre，依次遍历整个链表 具体代码如下： 123456789101112131415161718192021/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */class Solution { public ListNode reverseList(ListNode head) { ListNode pre = null; ListNode curr = head; while (curr != null) { ListNode temp = curr; curr = curr.next; temp.next = pre; pre = temp; } return pre; }} 递归方法的思想就是依次递归到链表的尾部，然后依次将当前节点的head.next.next = head，然后将head.next = null即可 具体代码如下： 12345678910111213141516171819/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */class Solution { public ListNode reverseList(ListNode head) { if (head == null || head.next == null) return head; ListNode temp = reverseList(head.next); head.next.next = head; head.next = null; return temp; }}","link":"/2020/10/26/LeetCode/206.%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"},{"title":"LeetCode&#x2F;207. 课程表","text":"207. 课程表你这个学期必须选修 numCourse 门课程，记为 0 到 numCourse - 1 。 在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：[0,1] 给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？ 示例1 ： 123输入: 2, [[1,0]] 输出: true解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。 示例2： 123输入: 2, [[1,0],[0,1]]输出: false解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。 提示: 输入的先决条件是由 边缘列表 表示的图形，而不是 邻接矩阵 。详情请参见图的表示法。 你可以假定输入的先决条件中没有重复的边。 1 &lt;= numCourses &lt;= 10^5 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：一看到这种题目，就知道是有向图的拓扑排序，而拓扑排序的思路和广度优先搜索遍历大同小异。 具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution { public boolean canFinish(int numCourses, int[][] prerequisites) { Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); Map&lt;Integer, ArrayList&lt;Integer&gt;&gt; graph = new HashMap&lt;&gt;(); int[] inDegree = new int[numCourses]; for (int i = 0; i &lt; numCourses; i++) { graph.put(i, new ArrayList&lt;&gt;()); } //遍历数组，建立有向图结构，初始化各节点入度 for (int[] prerequisite : prerequisites) { int u = prerequisite[0]; int v = prerequisite[1]; inDegree[u]++; graph.get(v).add(u); } //将入度为0的节点加入队列 for (int i = 0; i &lt; numCourses; i++) { if (inDegree[i] == 0) { queue.add(i); } } //广度优先搜索遍历 while (!queue.isEmpty()) { int temp = queue.poll(); if (graph.get(temp) == null) continue; ArrayList&lt;Integer&gt; list = graph.get(temp); for (Integer integer : list) { if (--inDegree[integer] == 0) { queue.add(integer); } } } //查看是否存在环 for (int i = 0; i &lt; numCourses; i++) { if (inDegree[i] != 0) return false; } return true; }}","link":"/2020/09/18/LeetCode/207.%20%E8%AF%BE%E7%A8%8B%E8%A1%A8/"},{"title":"LeetCode&#x2F;209. 长度最小的子数组","text":"209. 长度最小的子数组给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。 示例: 123输入：s = 7, nums = [2,3,1,2,4,3]输出：2解释：子数组 [4,3] 是该条件下的长度最小的子数组。 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：很直观想到的就是滑动窗口，用一个变长的框框来不断缩小区间范围，但是！暴力解法竟然也过了。前缀和+二分查找的思路其实也没啥难的，就是再创建一个前缀和数组，每次寻找前缀和大于s的区间，遍历整个前缀和数组，找到最小的区间即可 具体代码如下： 123456789101112131415161718class Solution { public int minSubArrayLen(int s, int[] nums) { if (nums.length == 0) return 0; int result = Integer.MAX_VALUE; for (int i = 0; i &lt; nums.length; i++) { int temp = s; for (int j = i; j &lt; nums.length; j++) { temp -= nums[j]; if (temp &lt;= 0) { result = Math.min(result, j - i + 1); continue; } } } return result == Integer.MAX_VALUE ? 0 : result; }} 本题提示在O(N)内运行，要么是两个指针从头尾开始向中间缩，要么就是滑动窗口，显然本题用滑动窗口更加合适，创建两个指针，一个指针不断后移，让该区间所有数字和大于s，此时另一个指针从头向后移，找到让区间所有数字和第一次小于s的区间，此即为一个满足条件区间，遍历整个数组，找到最小的区间即可 具体代码如下： 123456789101112131415161718192021class Solution { public int minSubArrayLen(int s, int[] nums) { if (nums.length == 0) return 0; int i = 0, j = 0, window = 0, result = Integer.MAX_VALUE; while (j &lt; nums.length) { //找到大于s的区间 while (window &lt; s &amp;&amp; j &lt; nums.length) { window += nums[j++]; } //找到小于s的区间 while (i &lt; j &amp;&amp; window &gt;= s) { //记录此区间长度，由于每次条件不成立跳出循环时，i、j还要自增 //所以区间长度为 j - i result = Math.min(result, j - i); window -= nums[i++]; } } return result == Integer.MAX_VALUE ? 0 : result; }}","link":"/2020/07/17/LeetCode/209.%20%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"},{"title":"LeetCode&#x2F;21. 合并两个有序链表","text":"21. 合并两个有序链表将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例 ： 12输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题想法比较简单，就是创建一个新链表，然后遍历两个链表结点，哪个结点值小就往新链表后面接。 具体代码如下： 1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */class Solution { public ListNode mergeTwoLists(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(0); ListNode temp = dummy; while (l1 != null &amp;&amp; l2 != null) { if (l1.val &gt; l2.val) { temp.next = l2; l2 = l2.next; } else { temp.next = l1; l1 = l1.next; } temp = temp.next; } temp.next = l1 == null ? l2 : l1; return dummy.next; }} 本题还有一种递归的思路，这里给出了详细解释https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/yi-kan-jiu-hui-yi-xie-jiu-fei-xiang-jie-di-gui-by-/ 具体代码如下： 12345678910111213141516171819202122232425/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */class Solution { public ListNode mergeTwoLists(ListNode l1, ListNode l2) { if (l1 == null) return l2; else if (l2 == null) return l1; else if (l1.val &lt; l2.val) { l1.next = mergeTwoLists(l1.next, l2); return l1; } else { l2.next = mergeTwoLists(l1, l2.next); return l2; } }}","link":"/2020/11/17/LeetCode/21.%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"},{"title":"LeetCode&#x2F;210. 课程表 II","text":"210. 课程表 II现在你总共有 n 门课需要选，记为 0 到 n-1。 在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1] 给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。 可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。 示例1 ： 123输入: 2, [[1,0]] 输出: [0,1]解释: 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。 示例2： 1234输入: 4, [[1,0],[2,0],[3,1],[3,2]]输出: [0,1,2,3] or [0,2,1,3]解释: 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。 因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。 说明: 输入的先决条件是由 边缘列表 表示的图形，而不是 邻接矩阵 。详情请参见图的表示法。 你可以假定输入的先决条件中没有重复的边。 提示: 这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。 通过 DFS 进行拓扑排序 - 一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。 拓扑排序也可以通过 BFS 完成。 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题还是使用拓扑排序和深度优先搜索遍历两种方式。本题是在207. 课程表基础上做了小幅度改动，我们需要将拓扑排序的路径记录下来。首先我们来看广度优先搜索遍历，主要是创建一个inDegree数组用来存放各个节点的入度，然后将入度为0的节点入队再出队，和出队节点相邻的各个节点入度减一后判断各节点入度是否为0，如果是则入队，如此循环直到队列为空，最后将结果返回即可。 具体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution { public int[] findOrder(int numCourses, int[][] prerequisites) { Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); Map&lt;Integer, ArrayList&lt;Integer&gt;&gt; graph = new HashMap&lt;&gt;(); //存放入度 int[] inDegree = new int[numCourses]; //存放结果 int[] result = new int[numCourses]; //构建图 for (int[] prerequisite : prerequisites) { int u = prerequisite[0]; int v = prerequisite[1]; inDegree[u]++; if (graph.get(v) == null) graph.put(v, new ArrayList&lt;&gt;()); graph.get(v).add(u); } //将入度为0的节点加入队列 for (int i = 0; i &lt; numCourses; i++) { if (inDegree[i] == 0) queue.add(i); } //count用于result数组索引存放元素，nums用于判断该图是否存在环 int count = 0; int nums = numCourses; while (!queue.isEmpty() &amp;&amp; (count &lt; numCourses)) { int temp = queue.poll(); nums--; result[count++] = temp; if (graph.get(temp) == null) continue; ArrayList&lt;Integer&gt; list = graph.get(temp); for (Integer integer : list) { if (--inDegree[integer] == 0) queue.add(integer); } } if (nums == 0) return result; else return new int[]{}; }} 还有一种深度优先搜索遍历的方法，其核心是要创建一个status数组用来存放当前节点的访问状态，0为未访问，1为正在访问，2为已经访问过。我们随机地从一个节点出发，通过DFS遍历当前节点所有相邻的点，如果当前节点状态为1，则证明遍历一圈回到了起始点，即存在环，我们直接返回true。否则我们依次遍历，当节点没有出度时，我们将节点入栈并回退，如此反复，当所有节点的status都为2时，循环结束。 具体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution { public int[] findOrder(int numCourses, int[][] prerequisites) { Map&lt;Integer, ArrayList&lt;Integer&gt;&gt; graph = new HashMap&lt;&gt;(); //status:unkonwn == 0, visiting == 1, visited == 2 int[] status = new int[numCourses]; Deque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;(); int[] result = new int[numCourses]; for (int[] prerequisite : prerequisites) { int u = prerequisite[0]; int v = prerequisite[1]; if (graph.get(v) == null) graph.put(v, new ArrayList&lt;&gt;()); graph.get(v).add(u); } for (int i = 0; i &lt; numCourses; i++) { //有环返回true if (dfs(i, graph, status, stack)) return new int[]{}; } //出栈的顺序即为访问顺序 for (int i = 0; i &lt; numCourses; i++) { result[i] = stack.pop(); } return result; } private boolean dfs(int curr, Map&lt;Integer, ArrayList&lt;Integer&gt;&gt; graph, int[] status, Deque&lt;Integer&gt; temp) { if (status[curr] == 1) return true;//有环存在 if (status[curr] == 2) return false;//已经访问过，没有必要再次访问 status[curr] = 1; ArrayList&lt;Integer&gt; list = graph.get(curr); if (list != null){ for (Integer t : list) { if (dfs(t, graph, status, temp)) return true; } } status[curr] = 2; temp.push(curr); return false; }}","link":"/2020/10/21/LeetCode/210.%20%E8%AF%BE%E7%A8%8B%E8%A1%A8%20II/"},{"title":"LeetCode&#x2F;213. 打家劫舍 II","text":"213. 打家劫舍 II你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。 示例1 ： 123输入: [2,3,2]输出: 3解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。 示例2： 1234输入: [1,2,3,1]输出: 4解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。 偷窃到的最高金额 = 1 + 3 = 4 。 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题是198. 打家劫舍的升级题目，难点在于环状结构，不能同时偷取首尾两家。当前收益最大有两种情况，第一种情况是前一家偷过了，那么当前最大收益就是前一天的最大收益，第二种情况是前一家没有偷过，那么当前的最大收益就是前前天的最大收益，加上当前能偷得钱的金额。 同时边界条件为dp[0] = nums[0],dp[1] = Math.max(nums[0], nums[1])，我们写出状态转移方程： dp[i] = Math.max(dp[i-1] , dp[i-2]+nums[i])解这道题有个取巧的方式就是将一个数组分为两个子数组，一个子数组为nums[0, nums.length - 1]，另一个子数组为nums[1, nums.length - 1]，分别求取两个子数组的最大收益，然后返回最大值即可。 具体代码如下： 123456789101112131415161718192021222324252627282930313233class Solution { public int rob(int[] nums) { if (nums.length == 0 || nums == null) { return 0; } if (nums.length == 1) { return nums[0]; } if (nums.length == 2){ return Math.max(nums[0], nums[1]); } int result1 = 0, result2 = 0; int dp0 = nums[0]; int dp1 = Math.max(nums[0], nums[1]); int dp2 = Math.max(dp0, dp1); for (int i = 2; i &lt; nums.length - 1; i++) { dp2 = Math.max(dp1, dp0 + nums[i]); dp0 = dp1; dp1 = dp2; } result1 = dp2; dp0 = nums[1]; dp1 = Math.max(nums[1], nums[2]); dp2 = Math.max(dp0, dp1); for (int i = 3; i &lt; nums.length; i++) { dp2 = Math.max(dp1, dp0 + nums[i]); dp0 = dp1; dp1 = dp2; } result2 = dp2; return Math.max(result1, result2); }}","link":"/2020/08/05/LeetCode/213.%20%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%20II/"},{"title":"LeetCode&#x2F;216. 组合总和 III","text":"216. 组合总和 III找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。 说明： 所有数字都是正整数。 解集不能包含重复的组合。 示例1 ： 12输入: k = 3, n = 7输出: [[1,2,4]] 示例2： 12输入: k = 3, n = 9输出: [[1,2,6], [1,3,5], [2,3,4]] 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题的思想就是回溯，非常标准的回溯，和组合问题相比没有改变多少 具体代码如下： 123456789101112131415161718192021222324class Solution { List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) { LinkedList&lt;Integer&gt; track = new LinkedList&lt;&gt;(); backtrack(k, n, 1, track); return result; } void backtrack(int k, int n, int start, LinkedList&lt;Integer&gt; track) { if (track.size() == k &amp;&amp; n == 0) { result.add(new LinkedList&lt;&gt;(track)); return; } if (n &lt; 0) return; for (int i = start; i &lt; 10; i++) { track.add(i); backtrack(k, n - i, i + 1, track); track.removeLast(); } }}","link":"/2020/09/10/LeetCode/216.%20%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%20III/"},{"title":"LeetCode&#x2F;226. 翻转二叉树","text":"226. 翻转二叉树翻转一棵二叉树。 示例: 输入： 12345 4 / \\ 2 7 / \\ / \\1 3 6 9 输出： 12345 4 / \\ 7 2 / \\ / \\9 6 3 1 来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 题解：碰到二叉树需要递归的，我们还是同样的思路。先思考一个结点应该怎么操作，然后递归进行就好了。拿根结点来说，我们要翻转二叉树，无非就是左右子结点交换，然后进行递归就好。 具体代码如下： 123456789101112131415161718192021222324/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public TreeNode invertTree(TreeNode root) { if (root == null){ return root; } TreeNode temp = root.left; root.left = root.right; root.right = temp; invertTree(root.left); invertTree(root.right); return root; }}","link":"/2020/09/16/LeetCode/226.%20%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"title":"LeetCode&#x2F;234. 回文链表","text":"234. 回文链表请判断一个链表是否为回文链表。 示例1: 12输入: 1-&gt;2输出: false 示例 2: 12输入: 1-&gt;2-&gt;2-&gt;1输出: true 进阶：你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？ 来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 题解：转换为数组本题是非常经典的链表的题目，通过多种方法可以很好地训练思维。一般判断字符串是不是回文的非常容易，就是双指针法，一个指向头，一个指向尾，同时向中间遍历，如果不等直接返回false即可，链表我们也可以用相同的思路，将链表转换为数组然后进行判断 具体代码如下： 1234567891011121314151617181920212223242526272829303132/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */class Solution { public boolean isPalindrome(ListNode head) { ListNode currNode = head; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); //将所有的节点存储到数组中 while (currNode != null) { list.add(currNode.val); currNode = currNode.next; } //两个指针，一个指向头，一个指向尾，然后向中间遍历 int i = 0, j = list.size() - 1; while (i &lt;= j) { //这里Integer不能直接比较// if (list.get(i) != list.get(j)) if (!list.get(i).equals(list.get(j))) { return false; } i++; j--; } return true; }} 栈当然，利用栈的后进先出的特点，我们也可以达到目的 具体代码如下： 12345678910111213141516171819202122232425262728293031/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */class Solution { public boolean isPalindrome(ListNode head) { if (head == null) return true; //创建一个栈将所有节点压入 Deque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;(); ListNode curr = head; while (curr != null) { stack.push(curr.val); curr = curr.next; } //一个从头节点开始，一个从尾节点开始，比较两个节点的值是否相同 //当然这里也可以设置一个变量记录链表的长度，这样只需要比较栈中一半的元素即可 while (head != null) { if (head.val != stack.pop()) return false; head = head.next; } return true; }} 递归一般的递归都可以改成栈的迭代方法，这里同样可以借助栈的思想来完成递归，具体思路大同小异。我们不断地递归直到链表的尾部停止，然后和另一个头节点进行比较，如果相等，则头节点后移，而递归栈中自然而然的返回尾节点的前一个节点，如果不等则返回false 具体代码如下： 123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */class Solution { ListNode temp; public boolean isPalindrome(ListNode head) { temp = head; return help(head); } private boolean help(ListNode node) { if (node == null) return true; //不断地递归直到链表的尾部 boolean flags = help(node.next) &amp;&amp; (temp.val == node.val); //从前往后遍历的指针后移 temp = temp.next; return flags; }} 快慢指针快慢指针思想很妙，但是本题中需要改变链表结构，而且官方也说了，实际工程中，如果多线程的话这种方法也不能使用。快慢指针的具体思想就是利用一快一慢指针找到链表的中点，然后将后半部分的链表翻转，这样一个指针从头开始，一个指针从尾开始进行遍历，遇到值不相同的就返回false 具体代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */class Solution { public boolean isPalindrome(ListNode head) { ListNode quick = head; ListNode slow = head; while (quick != null &amp;&amp; quick.next != null) { quick = quick.next.next; slow = slow.next; } //这里说明节点个数为偶数个，需要将slow指向中间两个节点的后一个节点 if (quick != null) { slow = slow.next; } ListNode tail = reverse(slow); //判断链表是否是回文链表 while (tail != null) { if (head.val != tail.val) return false; head = head.next; tail = tail.next; } return true; } //翻转链表，这里注意需要一个临时节点存放curr的下一个节点，不然链表会断开 private ListNode reverse(ListNode head) { ListNode pre = null; ListNode curr = head; while (curr != null) { ListNode temp = curr.next; curr.next = pre; pre = curr; curr = temp; } return pre; }}","link":"/2020/10/27/LeetCode/234.%20%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/"},{"title":"LeetCode&#x2F;24. 两两交换链表中的节点","text":"24. 两两交换链表中的节点给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 示例1 ： 12输入：head = [1,2,3,4]输出：[2,1,4,3] 示例 2： 12输入：head = []输出：[] 示例 3： 12输入：head = [1]输出：[1] 提示： 链表中节点的数目在范围 [0, 100] 内 0 &lt;= Node.val &lt;= 100 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题可以分为递归方法和迭代方法。首先来看递归方法，我们需要明确每一步做什么，无非就是两个节点颠倒顺序，假设当前节点为head，下一个节点为newNode = head.next，每次交换完成后，newNode成为队列的第一个节点，head成为队列的第二个节点。判断结束的条件就是当前节点为空或者当前节点的下一个节点为空。 具体代码如下： 123456789101112131415161718192021/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */class Solution { public ListNode swapPairs(ListNode head) { if (head == null || head.next == null) return head; ListNode newNode = head.next; head.next = swapPairs(newNode.next); newNode.next = head; return newNode; }} 这道题用递归有点绕，我们来看下迭代的方式如何操作。一看到题目最直观的想法就是两个指针指向当前节点和下一个节点，然后交换，指针指向下一对进行交换即可。这里我们需要用到一个哑结点和一个临时指针（如果不额外加入会造成链表连不上的情况）。让dummy.next = head; temp = dummy，首先temp.next.next = q，即让temp的下一个节点为交换元素中的第二个位置上的元素q，这样交换完成后q变到第一个位置，p变为第二个位置，而dummy指向了q，即将链表连接了起来，最后让temp指向p即可。 具体代码如下： 1234567891011121314151617181920212223242526272829303132/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */class Solution { public ListNode swapPairs(ListNode head) { if (head == null || head.next == null) return head; ListNode dummy = new ListNode(0); dummy.next = head; ListNode temp = dummy; while (temp.next != null &amp;&amp; temp.next.next != null) { ListNode p = temp.next; ListNode q = temp.next.next; temp.next = q; p.next = q.next; q.next = p; temp = p; } return dummy.next; }}","link":"/2020/10/13/LeetCode/24.%20%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"},{"title":"LeetCode&#x2F;257. 二叉树的所有路径","text":"257. 二叉树的所有路径给定一个二叉树，返回所有从根节点到叶子节点的路径。 说明: 叶子节点是指没有子节点的节点。 示例 ： 1234567891011输入: 1 / \\2 3 \\ 5输出: [&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]解释: 所有根节点到叶子节点的路径为: 1-&gt;2-&gt;5, 1-&gt;3 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题还是基于深度优先搜索遍历的框架，我们需要记录每次遍历的结点，一条路径的终止条件就是当前结点是叶结点，即当前的结点的左右子结点都为空。 具体代码如下： 1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { List&lt;String&gt; result = new LinkedList&lt;&gt;(); public List&lt;String&gt; binaryTreePaths(TreeNode root) { dfs(root, \"\"); return result; } private void dfs(TreeNode root, String temp) { if (root == null) return; StringBuilder sb = new StringBuilder(temp); sb.append(root.val); if (root.left == null &amp;&amp; root.right == null) { result.add(sb.toString()); } else { sb.append(\"-&gt;\"); dfs(root.left, sb.toString()); dfs(root.right, sb.toString()); } }}","link":"/2020/11/23/LeetCode/257.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84/"},{"title":"LeetCode&#x2F;26. 删除排序数组中的重复项","text":"26. 删除排序数组中的重复项给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用O(1) 额外空间的条件下完成。 示例1 ： 12345给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例2： 12345给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题基于双指针的思想，定义两个指针i、j，让j遍历数组，如果遇到nums[i] != nums[j]的情况，我们就把nums[j]的值赋值给nums[i+1]，并让变量i自增，当j遍历完nums数组后，当前i索引加一的值就是无重复数组的长度。 具体代码如下： 12345678910111213class Solution { public int removeDuplicates(int[] nums) { if (nums.length == 0) return 0; int i = 0; for (int j = 0; j &lt; nums.length; j++) { if (nums[i] != nums[j]) { nums[i + 1] = nums[j]; i++; } } return i + 1; }}","link":"/2020/07/17/LeetCode/26.%20%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"},{"title":"LeetCode&#x2F;263. 丑数","text":"263. 丑数编写一个程序判断给定的数是否为丑数。 丑数就是只包含质因数 2, 3, 5 的正整数。 示例 1: 123输入: 6输出: true解释: 6 = 2 × 3 示例 2: 123输入: 8输出: true解释: 8 = 2 × 2 × 2 示例 3: 123输入: 14输出: false 解释: 14 不是丑数，因为它包含了另外一个质因数 7。 说明： 1 是丑数。 输入不会超过 32 位有符号整数的范围: [−231, 231 − 1]。 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题我们对给定数字不断除以2、3、5，判断最后这个是否等于1，如果等于1，说明该数只包含2、3、5三个质因数，即为丑数，否则不是丑数。 具体代码如下： 123456789101112131415161718class Solution { public boolean isUgly(int num) { if (num &lt; 1) return false; while (num % 2 == 0) { num /= 2; } while (num % 3 == 0) { num /= 3; } while (num % 5 == 0) { num /= 5; } return num == 1; }}","link":"/2020/12/03/LeetCode/263.%20%E4%B8%91%E6%95%B0/"},{"title":"LeetCode&#x2F;264. 丑数 II","text":"264. 丑数 II编写一个程序，找出第 n 个丑数。 丑数就是质因数只包含 2, 3, 5 的正整数。 示例 : 123输入: n = 10输出: 12解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。 说明: 1 是丑数。 n 不超过1690。 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题说实话，没啥意思，就是先把可能结果全算出来然后返回需要的结果，美其名曰动态规划、堆，其实就是面向测试用例编程。这里用动态规划的思想构造结果数据，因为丑数是以2、3、5为质因子的，所以使用三个指针，分别是对应质数2、3、5，每次取三个指针之一乘以对应质数存入相应的位置。 具体代码如下： 1234567891011121314151617class Solution { public int nthUglyNumber(int n) { int[] nums = new int[1690]; nums[0] = 1; int p2 = 0, p3 = 0, p5 = 0, temp = 0; for (int i = 1; i &lt; 1690; i++) { temp = Math.min(Math.min(nums[p2] * 2, nums[p3] * 3), nums[p5] * 5); nums[i] = temp; if (temp == nums[p2] * 2) p2++; if (temp == nums[p3] * 3) p3++; if (temp == nums[p5] * 5) p5++; } return nums[n - 1]; }}","link":"/2020/12/03/LeetCode/264.%20%E4%B8%91%E6%95%B0%20II/"},{"title":"LeetCode&#x2F;275. H 指数 II","text":"275. H 指数 II给定一位研究者论文被引用次数的数组（被引用次数是非负整数），数组已经按照 升序排列 。编写一个方法，计算出研究者的 h 指数。 h 指数的定义: “h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （N 篇论文中）总共有 h 篇论文分别被引用了至少 h 次。（其余的 N - h 篇论文每篇被引用次数不多于 h 次。）” 示例 ： 1234输入: citations = [0,1,3,5,6]输出: 3 解释: 给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 0, 1, 3, 5, 6 次。 由于研究者有 3 篇论文每篇至少被引用了 3 次，其余两篇论文每篇被引用不多于 3 次，所以她的 h 指数是 3。 说明: 如果 h 有多有种可能的值 ，h 指数是其中最大的那个。 进阶： 这是 H 指数 的延伸题目，本题中的 citations 数组是保证有序的。 你可以优化你的算法到对数时间复杂度吗？ 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题线性遍历的想法很简单，就是找到第一个数，这个数大于等于该数后面的长度 具体代码如下： 12345678910class Solution { public int hIndex(int[] citations) { for (int i = 0; i &lt; citations.length; i++) { if (citations[i] &gt;= citations.length - i) { return citations.length - i; } } return 0; }} 进阶说要优化时间复杂度，对于有序数组优化时间复杂度基本上就是二分查找了，这里二分查找只需要改一点点，就是返回值要变成citations.length - 1 - mid + 1 具体代码如下： 123456789101112131415161718class Solution { public int hIndex(int[] citations) { int left = 0, right = citations.length - 1; while (left &lt;= right) { int mid = left + (right - left) / 2; if (citations[mid] == citations.length - mid) //citations.length - mid等价于citations.length - 1 - mid + 1 return citations.length - mid; else if (citations[mid] &gt; citations.length - mid) right = mid - 1; else left = mid + 1; } return citations.length - left; }}","link":"/2020/10/26/LeetCode/275.%20H%20%E6%8C%87%E6%95%B0%20II/"},{"title":"LeetCode&#x2F;283. 移动零","text":"283. 移动零给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 示例 ： 12输入: [0,1,0,3,12]输出: [1,3,12,0,0] 说明: 必须在原数组上操作，不能拷贝额外的数组。 尽量减少操作次数。 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题我一开始最先想到的就是利用冒泡排序的思路把0往后冒，虽然时间复杂度不行，但是也不失为一种解题思路。 具体代码如下： 12345678910111213141516class Solution { public void moveZeroes(int[] nums) { boolean flags = false; for (int i = nums.length - 1; i &gt; 0 &amp;&amp; !flags; i--) { flags = true; for (int j = 0; j &lt; i; j++) { if (nums[j] == 0) { flags = false; int temp = nums[j]; nums[j] = nums[j + 1]; nums[j + 1] = temp; } } } }} 另一种比较常规的解法就是双指针法，一个指针向后遍历，指向非零元素时和另一个指针指向的元素进行交换，同时两个指针向后移动，这样同样也能实现将0移到数组后面同时保持相对位置不变。 具体代码如下： 12345678910111213class Solution { public void moveZeroes(int[] nums) { int i = 0; for (int j = 0; j &lt; nums.length; j++) { if (nums[j] != 0) { int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; i++; } } }}","link":"/2020/11/05/LeetCode/283.%20%E7%A7%BB%E5%8A%A8%E9%9B%B6/"},{"title":"LeetCode&#x2F;3. 无重复字符的最长子串","text":"3. 无重复字符的最长子串给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 123输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例 2: 123输入: &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 示例 3: 1234输入: &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 提示： 0 &lt;= s.length &lt;= 5 * 104 s 由英文字母、数字、符号和空格组成 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题其实就是滑动窗口，但是每一步需要将当前字母存储在HashMap中，其中Key为当前字母，Value为当前字母的索引+1（这里加一是为了定位到重复字母的下一个位置），然后就是快指针不断后移，如果出现原先出现过的字母，就将慢指针移到最后一次出现重复字母位置的下一位，每次获取相对较大值，每次将当前字母索引加入HashMap中。 具体代码如下： 12345678910111213141516171819class Solution { public int lengthOfLongestSubstring(String s) { if (s.length() == 0) return 0; int n = s.length(); int left = 0, right = 0; int maxLength = 1; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); for (; right &lt; n; right++) { char temp = s.charAt(right); if (map.containsKey(temp)) { left = Math.max(left, map.get(temp)); } maxLength = Math.max(maxLength, right - left + 1); map.put(temp, right + 1); } return maxLength; }}","link":"/2020/12/03/LeetCode/3.%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"},{"title":"LeetCode&#x2F;300. 最长上升子序列","text":"300. 最长上升子序列给定一个无序的整数数组，找到其中最长上升子序列的长度。 示例 ： 123输入: [10,9,2,5,3,7,101,18]输出: 4 解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。 说明: 可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。 你算法的时间复杂度应该为 O(n2) 。 进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗? 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题每个当前位置所能获得的最长上升子序列必然和它之前位置的最长子序列有关，所以我们就可以想到用动态规划来解决问题。如何获取当前位置的最长上升子序列？遍历当前元素之前的所有元素，如果当前元素大于之前的某个元素，且当前最长上升子序列长度就是大于位置的索引加一，由此可以写出状态转移方程 dp[i]=Math.max(dp[i], dp[j]+1)具体代码如下： 123456789101112131415161718192021class Solution { public int lengthOfLIS(int[] nums) { if (nums.length == 0) return 0; int[] dp = new int[nums.length]; Arrays.fill(dp, 1); //最少肯定长度为1 int result = 1; for (int i = 1; i &lt; nums.length; i++) { for (int j = 0; j &lt; i; j++) { if (nums[i] &gt; nums[j]) { dp[i] = Math.max(dp[i], dp[j] + 1); } } if (dp[i] &gt; result) { result = dp[i]; } } return result; }}","link":"/2020/11/05/LeetCode/300.%20%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/"},{"title":"LeetCode&#x2F;309. 最佳买卖股票时机含冷冻期","text":"309. 最佳买卖股票时机含冷冻期给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。 示例: 123输入: [1,2,3,0,2]输出: 3 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出] 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题根据官方提示，是动态规划的思想。当天的收益与昨天的操作有关，让我们来找出状态转移方程。首先我们先考虑第一天的状态，在第一天有两种情况，(1) 我手上没有股票，就表示我没有买入，(2) 我手上有一只股票，表示我买入了一只股票，因为是第一天，我们不考虑冻结期的状态。 第 i 天一共有三种情况： 我们当天手里持有一张股票。这张股票有两种可能性，第一种是我在i 天没有购入，这种状态下我们在i-1天持有一只股票；第二种情况就是在i 天购入的，那么如果在i 天购入的话，就说明在 i-1天没有持有股票且在第i-1天不处在冷冻期。 我们当天没有持有股票，且处在冷冻期。这种状态下，说明在 i-1天的时候购入了一只股票。 我们当天没有持有股票，且不处在冷冻期，这也有两种可能性。第一种是i-1 属于第二种情况，就是处于冷冻期；第二种是i-1属于第三种情况，没有进行任何操作。 下面我们把上述三种情况符号化，我们将第一种情况记为 statusOne，第二种情况记为 statusTwo，第三种情况记为 statusThree，： 第一种情况的状态转移方程为： statusOne = max(statusOne, statusThree - prices[i]) 第二种情况的状态转移方程为： statusTwo = statusOne + prices[i] 第三种情况的状态转移方程为： statusThree = max(statusTwo, statusThree)这里使用三个变量而不是整个数组，是因为第i天的状态只与第 i-1天的状态有关，这样做会进一步优化空间复杂度。最后，我们只需要返回 statusOne、 statusTwo和 statusThree三者中的最大值就可以了，考虑到最后一天还持有股票肯定不会是最大收益，所以只需要返回 statusTwo和statusThree中的较大值即可。 具体代码实现如下： 1234567891011121314151617181920212223242526272829303132class Solution { public int maxProfit(int[] prices) { int len = prices.length; if (len == 0) return 0; //第一种情况是当天持有股票 //因为是第一天，所以就是当天购买的股票，所以收益需要花费prices[0] int statusOne = -prices[0]; int statusTwo = 0; int statusThree = 0; int temp1, temp2, temp3 = 0; for (int i = 1; i &lt; len; i++) { //根据状态转移方程更新股票收益 temp1 = Math.max(statusOne, statusThree - prices[i]); temp2 = statusOne + prices[i]; temp3 = Math.max(statusTwo, statusThree); statusOne = temp1; statusTwo = temp2; statusThree = temp3; //这里不能这样写，因为这样写的话在一个循环里，statusOne更新过后的值会影响statusTwo的值// statusOne = Math.max(statusOne, statusThree - prices[i]);// statusTwo = statusOne + prices[i];// statusThree = Math.max(statusTwo, statusThree); } //因为在最后一天还持有股票没有意义，会减少收益 //所以只考虑statusTwo和statusThree的情况 return Math.max(statusTwo, statusThree); }}","link":"/2020/10/13/LeetCode/309.%20%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F/"},{"title":"LeetCode&#x2F;31. 下一个排列","text":"31. 下一个排列实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。 必须原地修改，只允许使用额外常数空间。 以下是一些例子，输入位于左侧列，其相应输出位于右侧列。1,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题很绕，不好想。基本思路就是，由于我们我们要找到比当前结点大的最小排列，所以我们需要从后往前遍历，找到一对(i,j)，使(i,j)满足i&lt;j。此时的i就是我们要交换的元素的位置；然后，我们在(j, nums.length)范围内，找到比num[i]大的最小数字nums[j]和nums[i]交换；交换完成后，我们还需要使(j,nums.length)保持最小，即升序排列，这样才能保证找到的是比原排列大的，最小的排列。 具体代码如下： 123456789101112131415161718192021222324252627282930313233class Solution { public void nextPermutation(int[] nums) { if (nums.length == 0 || nums.length == 1) return; if (nums.length == 2) { int temp = nums[0]; nums[0] = nums[1]; nums[1] = temp; return; } int len = nums.length - 2; //寻找第一个升序队 while (len &gt; -1 &amp;&amp; nums[len + 1] &lt;= nums[len]) { len--; } //如果不存在下一个更大的排列，则将数字重新排列成最小的排列 if (len &lt; 0) { Arrays.sort(nums); return; } else { int j = nums.length - 1; //找到需要交换的位置 while (j &gt;= 0 &amp;&amp; nums[j] &lt;= nums[len]) { j--; } int temp = nums[j]; nums[j] = nums[len]; nums[len] = temp; //交换后让后面升序，保证最小 Arrays.sort(nums, len + 1, nums.length); return; } }}","link":"/2020/09/18/LeetCode/31.%20%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/"},{"title":"LeetCode&#x2F;328. 奇偶链表","text":"328. 奇偶链表给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。 请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes为节点总数。 示例1： 12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL 示例2： 12输入: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL 输出: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL 说明: 应当保持奇数节点和偶数节点的相对顺序。 链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。 来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 题解：本题先将题目翻译成比较直白的话就是，有一个链表，现在要把奇数位置的结点放一堆，偶数位置的结点放一堆，保证原有相对位置不变，奇数堆放在偶数堆前面，并且要求常数空间复杂度和线性时间复杂度。所以首先要把奇数位置的结点连在一起，同时把偶数位置的结点连在一起，最后将偶数链的头接在奇数链尾即可。 具体代码如下： 123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */class Solution { public ListNode oddEvenList(ListNode head) { //判空操作 if (head == null) return null; //创建三个指针，一个直线偶数结点，一个指向奇数结点，还有一个用来表示偶数链 ListNode oddNode = head, evenHeadNode = head.next, evenNode = evenHeadNode; //由于每次都是先接奇数链，再接偶数链，所以当偶数链当前所指结点为空时停止循环 while (evenNode != null &amp;&amp; evenNode.next != null) { //奇数位置接下一个奇数位置，偶数位置接下一个偶数位置 oddNode.next = evenNode.next; oddNode = oddNode.next; evenNode.next = oddNode.next; evenNode = evenNode.next; } //最后将偶数链头接到奇数链尾即可 oddNode.next = evenHeadNode; //因为head一直指向原始链表的头，即奇数链，所以直接返回head即可 return head; }}","link":"/2020/11/13/LeetCode/328.%20%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8/"},{"title":"LeetCode&#x2F;337. 打家劫舍 III","text":"337. 打家劫舍 III在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。 计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。 示例1 ： 12345678910输入: [3,2,3,null,3,null,1] 3 / \\ 2 3 \\ \\ 3 1输出: 7 解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7. 示例2： 12345678910输入: [3,4,5,1,3,null,1] 3 / \\ 4 5 / \\ \\ 1 3 1输出: 9解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9. 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题借鉴官方题解，根据该系列前两题，198. 打家劫舍和213. 打家劫舍 II的进阶版题型，将数组换成了二叉树。根据动态规划的思想，我们肯定要递归遍历这棵树。当我们遍历到该结点时，一共有两种情况，第一种是该结点被偷了，那么该结点的左右孩子结点都不应该再去偷，第二种是该结点没有被偷，那么它的左右孩子可能被偷，也可能没有被偷。我们设置两个HashMap结构存储，用selected表示当前结点被偷，unselected表示当前结点没有被偷，对第一种情况，我们需要将当前结点和当前结点孩子结点没有被偷的情况下的值存入，对第二种情况，我们需要保存的是当前结点左右孩子偷或者不偷后的最大值。通过后序遍历，我们就可以得到根结点的最大收益。 具体代码如下： 1234567891011121314151617181920212223242526272829class Solution { Map&lt;TreeNode, Integer&gt; selected = new HashMap&lt;&gt;(); Map&lt;TreeNode, Integer&gt; unselected = new HashMap&lt;&gt;(); public int rob(TreeNode root) { depthFirstSearch(root); return Math.max(selected.getOrDefault(root, 0), unselected.getOrDefault(root, 0)); } public void depthFirstSearch(TreeNode node) { if (node == null) { return; } depthFirstSearch(node.left); depthFirstSearch(node.right); selected.put(node, node.val + unselected.getOrDefault(node.left, 0) + unselected.getOrDefault(node.right, 0)); unselected.put(node, Math.max(selected.getOrDefault(node.left, 0), unselected.getOrDefault(node.left, 0)) + Math.max(selected.getOrDefault(node.right, 0), unselected.getOrDefault(node.right, 0))); }}class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; }}","link":"/2020/08/05/LeetCode/337.%20%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%20III/"},{"title":"LeetCode&#x2F;34. 在排序数组中查找元素的第一个和最后一个位置","text":"34. 在排序数组中查找元素的第一个和最后一个位置给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。 如果数组中不存在目标值 target，返回 [-1, -1]。 进阶： 你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？ 示例 1: 12输入：nums = [5,7,7,8,8,10], target = 8输出：[3,4] 示例 2: 12输入：nums = [5,7,7,8,8,10], target = 6输出：[-1,-1] 示例3: 12输入：nums = [], target = 0输出：[-1,-1] 提示： 0 &lt;= nums.length &lt;= 105 -109 &lt;= nums[i] &lt;= 109 nums 是一个非递减数组 -109 &lt;= target &lt;= 109 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题一看到排序数组四个大字，我啪的一下就站起来了，很快啊，直接二分查找，套用模板，这里唯一需要注意的一个细节就是，target有可能在nums数组中重复，只需要在找到目标值后，向前向后搜索，把所有满足要求的结果都找到。这里与剑指 Offer 53 - I. 在排序数组中查找数字 I不同的是返回满足条件的区间，而不是满足条件的数值个数。 具体代码如下： 1234567891011121314151617181920212223242526272829class Solution { public int search(int[] nums, int target) { if (nums.length == 0) return 0; int left = 0, right = nums.length, result = 0; int mid; while (left &lt; right) { mid = left + (right - left) / 2; if (nums[mid] == target) { result++; int temp = mid - 1; while (temp &gt;= 0 &amp;&amp; nums[temp] == target) { result++; temp--; } temp = mid + 1; while (temp &lt; nums.length &amp;&amp; nums[temp] == target) { result++; temp++; } break; } else if (nums[mid] &gt; target) { right = mid; } else { left = mid + 1; } } return result; }}","link":"/2020/12/03/LeetCode/34.%20%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/"},{"title":"LeetCode&#x2F;343. 整数拆分","text":"343. 整数拆分给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。 示例1 ： 123输入: 2输出: 1解释: 2 = 1 + 1, 1 × 1 = 1。 示例2： 123输入: 10输出: 36解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。 说明: 你可以假设 n 不小于 2 且不大于 58。 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题根据提示，需要用到动态规划，那么我们首先就需要找出状态转移方程。我们用dp数组来存储两个数的乘积，这个乘积分为两种情况，第一种情况就是，i被拆为i和i-j，那乘积就是i和i-j的乘积，另一种情况就是，拆分出j后还需要对剩下的i-j再次进行拆分，所以乘积就是j和dp[i-j]的乘积。通过以上分析我们就可以列出状态转移方程： dp[i] = Math.max(j * (i-j),j * dp[i-j])我们遍历从0到n的数，就可以得出结果。 具体代码如下： 123456789101112131415class Solution { public int integerBreak(int n) { if (n == 0) return 0; int[] dp = new int[n + 1]; for (int i = 0; i &lt;= n; i++) { int curMax = 0; for (int j = 1; j &lt; i; j++) { curMax = Math.max(curMax, Math.max(j * (i - j), j * dp[i - j])); } dp[i] = curMax; } return dp[n]; }}","link":"/2020/11/13/LeetCode/343.%20%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86/"},{"title":"LeetCode&#x2F;345. 反转字符串中的元音字母","text":"345. 反转字符串中的元音字母编写一个函数，以字符串作为输入，反转该字符串中的元音字母。 示例1 ： 12输入：&quot;hello&quot;输出：&quot;holle&quot; 示例2： 12输入：&quot;leetcode&quot;输出：&quot;leotcede&quot; 提示： 元音字母不包含字母 “y” 。 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题基于双指针法，创建两个指针，一个指向头，一个指向尾，进行遍历即可。 具体代码如下： 1234567891011121314151617181920class Solution { public String reverseVowels(String s) { char[] result = new char[s.length()]; Queue&lt;Character&gt; queue = new ArrayDeque&lt;&gt;(Arrays.asList('A', 'E', 'I', 'O', 'U', 'a', 'e', 'i', 'o', 'u')); int left = 0, right = s.length() - 1; while (left &lt;= right) { char temp1 = s.charAt(left); char temp2 = s.charAt(right); if (!queue.contains(temp1)) { result[left++] = temp1; } else if (!queue.contains(temp2)) { result[right--] = temp2; } else { result[left++] = temp2; result[right--] = temp1; } } return new String(result); }}","link":"/2020/09/21/LeetCode/345.%20%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E9%9F%B3%E5%AD%97%E6%AF%8D/"},{"title":"LeetCode&#x2F;344. 反转字符串","text":"344. 反转字符串编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。 你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。 示例1: 12输入：[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;] 示例2： 12输入：[&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;] 来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 题解：本题利用双指针，一个指向头，一个指向尾，每次交换两个数即可。 具体代码如下： 123456789101112131415class Solution { public void reverseString(char[] s) { int i = 0; int j = s.length - 1; char temp; while (i &lt; j) { temp = s[i]; s[i] = s[j]; s[j] = temp; i++; j--; } }}","link":"/2020/09/22/LeetCode/344.%20%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"title":"LeetCode&#x2F;347. 前 K 个高频元素","text":"347. 前 K 个高频元素给定一个非空的整数数组，返回其中出现频率前k高的元素。 示例1： 12输入: nums = [1,1,1,2,2,3], k = 2输出: [1,2] 示例2: 12输入: nums = [1], k = 1输出: [1] 提示： 你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。 你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。 题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。 你可以按任意顺序返回答案。 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题用最直观的思路，就是创建一个Map，通过计数、排序，可以得到每个数字按照出现次数的降序排列的HashMap，然后截取前k个返回就可以得到结果。 具体代码如下： 1234567891011121314151617181920212223242526class Solution { public int[] topKFrequent(int[] nums, int k) { Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); //计数 for (int i = 0; i &lt; nums.length; i++) { if (map.containsKey(nums[i])) { Integer times = map.get(nums[i]); times += 1; map.put(nums[i], times); } else { map.put(nums[i], 1); } } //按value降序排序 List&lt;Map.Entry&lt;Integer, Integer&gt;&gt; list = new ArrayList&lt;&gt;(map.entrySet()); Collections.sort(list, (o1, o2) -&gt; o2.getValue().compareTo(o1.getValue())); int[] result = new int[k]; Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; iterator = list.iterator(); //包装结果 for (int i = 0; i &lt; k; i++) { Map.Entry&lt;Integer, Integer&gt; next = iterator.next(); result[i] = next.getKey(); } return result; }} 当然了，这种暴力解法时间复杂度和空间复杂度都不太好，我们利用官方描述的堆的方式来解题。一顿操作后，发现时间复杂度和空间复杂度依旧很高。 具体代码如下： 1234567891011121314151617181920212223242526272829303132333435class Solution { public int[] topKFrequent(int[] nums, int k) { //建立出现评率数组 Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int num : nums) { map.put(num, map.getOrDefault(num, 0) + 1); } //对频率数组进行排序 List&lt;Map.Entry&lt;Integer, Integer&gt;&gt; list = new ArrayList&lt;&gt;(map.entrySet()); Collections.sort(list, (o1, o2) -&gt; o2.getValue().compareTo(o1.getValue())); //建立小顶堆 PriorityQueue&lt;int[]&gt; queue = new PriorityQueue&lt;&gt;(Comparator.comparingInt(o -&gt; o[1])); for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) { int key = entry.getKey(); int value = entry.getValue(); if (queue.size() == k) { //比较新元素和堆顶元素的大小，如果堆的大小为k且堆顶元素的值比新值小，则将替换堆顶元素 if (queue.peek()[1] &lt; value) { queue.poll(); queue.offer(new int[]{key, value}); } } else { queue.offer(new int[]{key, value}); } } //包装结果 int[] result = new int[k]; for (int i = 0; i &lt; k; i++) { result[i] = queue.poll()[0]; } return result; }} 还有一种桶排序的方法，桶排序的基本思想就是，首先我们还是要得到出现频次数组，然后我们需要新建一个桶数组，将桶数组的下标和出现频次对应起来，比如1出现了3次，那么桶数组下标为3的位置就应该存放1，最后，我们倒序遍历桶数组，就可以得到出现频次前K大的结果。 具体代码如下： 123456789101112131415161718192021222324252627282930class Solution { public int[] topKFrequent(int[] nums, int k) { //建立出现频率数组 Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int num : nums) { map.put(num, map.getOrDefault(num, 0) + 1); } List&lt;Integer&gt;[] freqList = new List[nums.length + 1]; for (int i = 0; i &lt; freqList.length; i++) { freqList[i] = new ArrayList&lt;&gt;(); } //将出现频次与桶数组下标对应 map.forEach((num, freq) -&gt; freqList[freq].add(num)); //包装结果 int[] result = new int[k]; int index = 0; for (int i = freqList.length - 1; i &gt; 0; i--) { for (Integer num : freqList[i]) { result[index++] = num; if (index == k) { return result; } } } return result; }}","link":"/2020/09/07/LeetCode/347.%20%E5%89%8D%20K%20%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/"},{"title":"LeetCode&#x2F;35. 搜索插入位置","text":"35. 搜索插入位置给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数组中无重复元素。 示例1 ： 12输入: [1,3,5,6], 5输出: 2 示例2： 12输入: [1,3,5,6], 2输出: 1 示例 3: 12输入: [1,3,5,6], 7输出: 4 示例 4: 12输入: [1,3,5,6], 0输出: 0 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题官方提示也说了，就是二分查找，而且就是最最最普通的二分查找，只不过加了一个如果target不存在于nums数组的话要返回插入位置的索引。具体来说，还是二分查找的大框架不变，只需要在最后找不到的时候返回left索引即可，如果非要找出本题的难点，那可能会是left、right值的问题，你到底一开始是选择right = nums.length，还是选择right = nums.length - 1；是选择left = mid，还是left = mid + 1；是right = mid还是right = mid - 1。 具体代码如下： 1234567891011121314151617181920212223242526class Solution { public int searchInsert(int[] nums, int target) { if (nums.length == 0) return -1; int left = 0; //这里用right = nums.length，下面的while循环条件就用left &lt; right //这里如果是right = nums.length - 1，下面的循环条件就是left &lt;= right //这是因为使用right = nums.length循环判等的话会出现越界 int right = nums.length; while (left &lt; right) { int mid = left + (right - left) / 2; //防止left和right太大导致相加除二溢出 if (nums[mid] == target) { //如果target就是nums[mid]的值的话就直接返回 return mid; } if (target &gt; nums[mid]) { //如果target比nums[mid]大，我们向右子区间收缩，所以这里需要left = mid + 1 left = mid + 1; } if (target &lt; nums[mid]) { //因为我们上面的right = nums.length，并且循环条件为left &lt; right //所以这里不能使用right = mid - 1，具体的大家可以debug观察结果 right = mid; } } return left; }}","link":"/2020/07/17/LeetCode/35.%20%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/"},{"title":"LeetCode&#x2F;350. 两个数组的交集 II","text":"350. 两个数组的交集 II给定两个数组，编写一个函数来计算它们的交集。 示例 1： 12输入：nums1 = [1,2,2,1], nums2 = [2,2]输出：[2,2] 示例 2: 12输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出：[4,9] 说明： 输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。我们可以不考虑输出结果的顺序。 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题应该不难想，就是两个指针对两个数组进行遍历，其中需要关注的有几点： 两个指针的地位应该是平等的，也就是说，不应该出现 for 循环嵌套 for 循环的情况； 大家通常只考虑相等情况，忽视了不等的时候如何进行指针的更新操作。 以上两种情况都容易造成死循环和越界，需要仔细考虑一下。 具体代码如下： 123456789101112131415161718192021222324252627class Solution { public int[] intersect(int[] nums1, int[] nums2) { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); //用来存放结果 Arrays.sort(nums1); Arrays.sort(nums2); int i = 0, j = 0; while (i &lt; nums1.length &amp;&amp; j &lt; nums2.length) { //如果两个值不相等，那么只移动数值较小的数组随对应的指针 if (nums1[i] &lt; nums2[j]) { i++; } else if (nums1[i] &gt; nums2[j]) { j++; } else if (nums1[i] == nums2[j]) { //如果nums1[i] == nums2[j]，则将结果加入list中后，将两个指针同时后移 list.add(nums1[i]); i++; j++; } } //使用Java8新特性 int[] result = list.stream().mapToInt(Integer::valueOf).toArray(); return result; }}","link":"/2020/07/13/LeetCode/350.%20%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86%20II/"},{"title":"LeetCode&#x2F;36. 有效的数独","text":"36. 有效的数独判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。 上图是一个部分填充的有效的数独。 数独部分空格内已填入了数字，空白格用 '.' 表示。 示例 1: 123456789101112131415161718192021222324252627282930输入:[ [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;], [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;], [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;], [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;], [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]输出: true示例 2:输入:[ [&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;], [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;], [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;], [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;], [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]输出: false解释: 除了第一行的第一个数字从 `5` 改为 `8` 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 `3x3` 宫内有两个 `8` 存在, 因此这个数独是无效的。 说明: 一个有效的数独（部分已被填充）不一定是可解的。 只需要根据以上规则，验证已经填入的数字是否有效即可。 给定数独序列只包含数字 1-9 和字符 '.' 。 给定数独永远是 9x9 形式的。 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：因为数独就是9x9的格子，所以我们直接创建三个9x9的二维数组来记录数字出现位置。rows[][]用来存放出现数字的行，columns[][]用来存放出现数字的列，box_index[][]用来存放出现数字的数字出现在哪个3x3的小方格中，用(i / 3) * 3 + j / 3判断当前数字所在的小方格索引，我们通过遍历整个9x9的数组，来判断当前出现数字是否满足条件。 具体代码如下： 1234567891011121314151617181920212223242526class Solution { public boolean isValidSudoku(char[][] board) { int[][] rows = new int[9][9]; int[][] columns = new int[9][9]; int[][] box_index = new int[9][9]; for (int i = 0; i &lt; 9; i++) { for (int j = 0; j &lt; 9; j++) { if (board[i][j] == '.') { continue; } //注意这里不能减'0'，会造成数组越界 int temp = board[i][j] - '1'; if (rows[i][temp] == 0 &amp;&amp; columns[j][temp] == 0 &amp;&amp; box_index[(i / 3) * 3 + j / 3][temp] == 0) { //赋值不能赋board[i][j]，这样会和判断条件冲突 rows[i][temp] = 1; columns[j][temp] = 1; box_index[(i / 3) * 3 + j / 3][temp] = 1; } else { return false; } } } return true; }}","link":"/2020/09/15/LeetCode/36.%20%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC/"},{"title":"LeetCode&#x2F;374. 猜数字大小","text":"374. 猜数字大小猜数字游戏的规则如下： 每轮游戏，我都会从 1 到 n 随机选择一个数字。 请你猜选出的是哪个数字。 如果你猜错了，我会告诉你，你猜测的数字比我选出的数字是大了还是小了。 你可以通过调用一个预先定义好的接口 int guess(int num) 来获取猜测结果，返回值一共有 3 种可能的情况（-1，1 或 0）： -1：我选出的数字比你猜的数字小 pick &lt; num 1：我选出的数字比你猜的数字大 pick &gt; num 0：我选出的数字和你猜的数字一样。恭喜！你猜对了！pick == num 示例 1： 12输入：n = 10, pick = 6输出：6 示例 2： 12输入：n = 1, pick = 1输出：1 示例 3： 12输入：n = 2, pick = 1输出：1 示例 4： 12输入：n = 2, pick = 2输出：2 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题就是通过guess(int num)函数进行二分查找，不断缩小区间，直到找到pick值为止 具体代码如下： 1234567891011121314151617181920212223242526/** * Forward declaration of guess API. * @param num your guess * @return -1 if num is lower than the guess number * 1 if num is higher than the guess number * otherwise return 0 * int guess(int num); */public class Solution extends GuessGame { public int guessNumber(int n) { int left = 1; int right = n; while (left &lt;= right) { int mid = left + (right - left) / 2; int result = guess(mid); if (result == 0) return mid; if (result &gt; 0) left = mid + 1; if (result &lt; 0) right = mid - 1; } return -1; }}","link":"/2020/10/12/LeetCode/374.%20%E7%8C%9C%E6%95%B0%E5%AD%97%E5%A4%A7%E5%B0%8F/"},{"title":"LeetCode&#x2F;377. 组合总和 Ⅳ","text":"377. 组合总和 Ⅳ给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。 示例 : 123456789101112131415nums = [1, 2, 3]target = 4所有可能的组合为：(1, 1, 1, 1)(1, 1, 2)(1, 2, 1)(1, 3)(2, 1, 1)(2, 2)(3, 1)请注意，顺序不同的序列被视作不同的组合。因此输出为 7。 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题虽然也叫做组合总和问题，但是和前面的问题不太一样，前面的组合总和问题都需要把所有的结果列出来，返回列表，而本题只需要返回所有结果的可能性。如果你试图将所有结果遍历出来然后返回result链表的大小，那么就会超时。因此我们根据官方的提示，尝试用动态规划的方法解决问题。至于这个题目怎么一下子想到动态规划，说实话这个可能就是做得多了才会有感觉吧，反正我一开始是没有想到的。 要用动态规划，我们能想到dp数组肯定是存放可能性的，然后就是需要找出状态转移方程，通过将几种情况列出来后我们发现，dp[i] = dp[i - nums[j]] +dp[i - nums[j + 1]]....这里[]里面的数都要大于零，状态转移方程找到后，问题迎刃而解。 123456789101112131415161718192021222324假设nums[]为[1, 2, 3]，我们通过列举几个例子来看下情况target = 0时dp([1, 2, 3], 0) = {}target = 1时dp([1, 2, 3], 1) = {1} = U({1} x dp([1, 2, 3], 1 - 1))target = 2时dp([1, 2, 3], 2) = U({1} x dp([1, 2, 3], 2 - 1), {1, 1} {2} x dp([1, 2, 3], 2 - 2)) {2}target = 3时dp([1, 2, 3], 3) = U({1} x dp([1, 2, 3], 3 - 1), {1, 1, 1} {1, 2} {2} x dp([1, 2, 3], 3 - 2), {2, 1} {3} x dp([1, 2, 3], 3 - 3)) {3}target = 4时dp([1, 2, 3], 4) = U({1} x dp([1, 2, 3], 4 - 1), {1, 1, 1, 1} {1, 1, 2} {1 ,2, 1} {1, 3} {2} x dp([1, 2, 3], 4 - 2), {2, 1, 1} {2, 2} {3} x dp([1, 2, 3], 4 - 3)) {3, 1} 具体代码如下： 123456789101112131415class Solution { public int combinationSum4(int[] nums, int target) { int[] dp = new int[target + 1]; dp[0] = 1; for (int i = 1; i &lt;= target; i++) { for (int j = 0; j &lt; nums.length; j++) { if (nums[j] &lt;= i) { dp[i] += dp[i - nums[j]]; } } } return dp[target]; }}","link":"/2020/09/10/LeetCode/377.%20%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%20%E2%85%A3/"},{"title":"LeetCode&#x2F;386. 字典序排数","text":"386. 字典序排数给定一个整数 n, 返回从 1 到 n 的字典顺序。 例如， 给定 n =13，返回 [1,10,11,12,13,2,3,4,5,6,7,8,9] 。 请尽可能的优化算法的时间复杂度和空间复杂度。 输入的数据 n 小于等于 5,000,000。 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题其实就是一颗十叉树，用到的就是深度优先搜索遍历。 具体代码如下： 123456789101112131415161718192021class Solution { List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); public List&lt;Integer&gt; lexicalOrder(int n) { for (int i = 1; i &lt; 10; i++) { dfs(n, i); } return result; } private void dfs(int n, int i) { if (i &gt; n) return; result.add(i); for (int j = 0; j &lt; 10; j++) { //提前进行剪枝，就不要递归，节省时间 if (i * 10 + j &gt; n) return; dfs(n, i * 10 + j); } }}","link":"/2020/09/18/LeetCode/386.%20%E5%AD%97%E5%85%B8%E5%BA%8F%E6%8E%92%E6%95%B0/"},{"title":"LeetCode&#x2F;39. 组合总和","text":"39. 组合总和给定一个无重复元素的数组 candidates和一个目标数 target，找出 candidates中所有可以使数字和为 target的组合。 candidates中的数字可以无限制重复被选取。 说明： 所有数字（包括 target）都是正整数。 解集不能包含重复的组合。 示例1 ： 123456输入：candidates = [2,3,6,7], target = 7,所求解集为：[ [7], [2,2,3]] 示例 2： 1234567输入：candidates = [2,3,5], target = 8,所求解集为：[ [2,2,2,2], [2,3,3], [3,5]] 提示： 1 &lt;= candidates.length &lt;= 30 1 &lt;= candidates[i] &lt;= 200 candidate中的每个元素都是独一无二的 1 &lt;= target &lt;= 500 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题我们还是依靠全排列的回溯思想，让我们在全排列的基础上修改此题。很直观的想法，就是该数组元素之和要等于target，那么我们可以设置一个变量count，每次回溯往track中添加元素后和target比较大小，如果相等则该track就是我们想要的结果，将track加入result中，如果target小于count，显然此时已经没有意义了，我们直接return。 具体代码如下： 123456789101112131415161718192021222324252627282930class Solution { List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) { LinkedList&lt;Integer&gt; track = new LinkedList&lt;&gt;(); int count = 0; backtrack(candidates, target, 0, count, track); return result; } void backtrack(int[] candidates, int target, int start, int count, LinkedList&lt;Integer&gt; track) { //触发结束条件 if (target == count) { result.add(new LinkedList&lt;&gt;(track)); return; } //如果count超过target则直接返回， if (target &lt; count) { return; } for (int i = start; i &lt; candidates.length; i++) { //将track中未出现的元素加入 track.add(candidates[i]); backtrack(candidates, target, i, count + candidates[i], track); //剔除最后一个元素，尝试下一个不同的元素 track.removeLast(); } }} 既然正向加可以，那么自然而然就会想到逆向减也是可行的，并且如果是逆向减的话还不需要设置count变量，节省了空间。我们直接将target - candidates[i]传入backtrack方法，如果target == 0时说明数组之和等于target，同样，如果target &lt; 0证明值超了，这时直接return即可。 具体代码如下： 12345678910111213141516171819202122232425262728class Solution { List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) { LinkedList&lt;Integer&gt; track = new LinkedList&lt;&gt;(); backtrack(candidates, target, 0, track); return result; } void backtrack(int[] candidates, int target, int start, LinkedList&lt;Integer&gt; track) { //触发结束条件 if (target == 0) { result.add(new LinkedList&lt;&gt;(track)); return; } if (target &lt; 0) { return; } for (int i = start; i &lt; candidates.length; i++) { //将track中未出现的元素加入 track.add(candidates[i]); backtrack(candidates, target - candidates[i], i, track); //剔除最后一个元素，尝试下一个不同的元素 track.removeLast(); } }}","link":"/2020/09/08/LeetCode/39.%20%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/"},{"title":"LeetCode&#x2F;40. 组合总和 II","text":"40. 组合总和 II给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的每个数字在每个组合中只能使用一次。 说明： 所有数字（包括目标数）都是正整数。解集不能包含重复的组合。示例 1: 12345678输入: candidates = [10,1,2,7,6,1,5], target = 8,所求解集为:[ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6]] 示例 2: 123456输入: candidates = [2,5,2,1,2], target = 5,所求解集为:[ [1,2,2], [5]] 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题和39. 组合总和类似，但是多出了限制条件，要求排列组合不能重复。我们先用最原始的思路在39. 组合总和上进行改造，为了避免重复，我们可以效仿47. 全排列 II的样子，创建一个used数组，用来标记当前元素是否已经被使用，接着，我们在每次backtrack的时候判断result里面是否有当前满足条件的track如果有的话就直接跳过，最后就是常规的回溯算法的标准框架。 具体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738class Solution { List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) { LinkedList&lt;Integer&gt; track = new LinkedList&lt;&gt;(); //设置标记数组用来判断当前数字是否已经被使用 boolean[] used = new boolean[candidates.length]; //对candidates数组进行排序 Arrays.sort(candidates); backtrack(candidates, target, 0, track, used); return result; } void backtrack(int[] candidates, int target, int start, LinkedList&lt;Integer&gt; track, boolean[] used) { //判断结束条件 if (target == 0) { //判读result结果数组中是否包含当前满足条件的排列 if (result.contains(track)) return; result.add(new LinkedList&lt;&gt;(track)); return; } if (target &lt; 0) { return; } for (int i = start; i &lt; candidates.length; i++) { if (used[i]) { continue; } track.add(candidates[i]); used[i] = true; backtrack(candidates, target - candidates[i], i, track, used); used[i] = false; track.removeLast(); } }} 这个结果说实话，是没有办法让人满意的，我们来思考一下如何优化。如果排序后，candidates中相邻两个元素相等，其实排列的结果是重复的，我们可以直接跳过。而且，还有一种更好的办法替代used数组，就是让每次backtrack传进去的start + 1。 具体代码如下： 123456789101112131415161718192021222324252627282930313233class Solution { List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) { LinkedList&lt;Integer&gt; track = new LinkedList&lt;&gt;(); //对candidates数组进行排序 Arrays.sort(candidates); backtrack(candidates, target, 0, track); return result; } void backtrack(int[] candidates, int target, int start, LinkedList&lt;Integer&gt; track) { if (target == 0) { result.add(new LinkedList&lt;&gt;(track)); return; } if (target &lt; 0) { return; } for (int i = start; i &lt; candidates.length; i++) { //如果candidates[i] == candidates[i - 1]证明排列重复，我们可以直接跳过 if (i &gt; start &amp;&amp; candidates[i] == candidates[i - 1]) { continue; } track.add(candidates[i]); //这里注意start要传入i+1 backtrack(candidates, target - candidates[i], i + 1, track); track.removeLast(); } }}","link":"/2020/09/08/LeetCode/40.%20%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%20II/"},{"title":"LeetCode&#x2F;400. 第N个数字","text":"400. 第N个数字在无限的整数序列 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, …中找到第 n 个数字。 注意:n 是正数且在32位整数范围内 ( n &lt; 231)。 示例1： 12345输入:3输出:3 示例2： 12345678输入:11输出:0说明:第11个数字在序列 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... 里是0，它是10的一部分。 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题要是面试的话临场还真不一定能找出规律，不过鉴于本题规律还算比较简单，可以参考训练自己的思维。通过找规律可以发现，数值为一位的数字一共有9个(1～9)，数值为二位的数字一共有180个(从10～99)，以此类推，最终可以发现规律即为起始位 * 位数 * 9，通过该规律，首先可以判断出n是几位数，从而定位到一个区间内。然后通过起始的位置可以计算出n位数对应的数字是多少，最后可以通过计算定位n对应该数字中的第几位，就可以得到结果。 具体代码如下： 1234567891011121314151617181920class Solution { public int findNthDigit(int n) { int start = 1; long digit = 1; long count = 9; while (n &gt; count) { n -= count; digit++; start *= 10; count = 9 * digit * start; } //定位n所指向的数字是多少 long num = start + (n - 1) / digit; //定位n所指向的数字是第几位 long reminder = (n - 1) % digit; return Long.toString(num).charAt((int)reminder) - '0'; }}","link":"/2020/11/23/LeetCode/400.%20%E7%AC%ACN%E4%B8%AA%E6%95%B0%E5%AD%97/"},{"title":"LeetCode&#x2F;392. 判断子序列","text":"392. 判断子序列给定字符串 s和 t，判断s是否为t的子序列。 你可以认为 s和 t中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s是个短字符串（长度 &lt;=100）。 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace“是”abcde“的一个子序列，而”aec“不是）。 示例1： 12s = &quot;abc&quot;, t = &quot;ahbgdc&quot;返回 true. 示例2： 12s = &quot;axc&quot;, t = &quot;ahbgdc&quot;返回 false. 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题思路其实很简单，就是双指针法，令两个指针分别指向两个字符串，如果两个指针指向的char相同，则两个指向都向后移位，如果两个指针指向的char值不同，则指向字符串t的指针向后移位，等到字符串t遍历完后，我们判断指针i是否已经遍历完s字符串，如果遍历完了，说明s是t的子串，如果没有完，说明s不是t的子串。 具体代码实现如下： 123456789public boolean isSubsequence(String s, String t) { int i = 0, j = 0; while (i &lt; s.length() &amp;&amp; j &lt; t.length()) { if (s.charAt(i) == t.charAt(j)) i++; j++; } return i == s.length();}","link":"/2020/07/27/LeetCode/392.%20%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97/"},{"title":"LeetCode&#x2F;404. 左叶子之和","text":"404. 左叶子之和计算给定二叉树的所有左叶子之和。 示例： 3 / \\ 9 20 / \\ 15 7 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24 来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 题解：本题我们需要明确， 只有左右孩子节点都为空的节点才可以称为叶子节点，我们只需要深度优先搜索遍历树，找到满足要求的节点，将其值累计啊即可。 具体代码如下： 12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { int result = 0; public int sumOfLeftLeaves(TreeNode root) { if (root == null) return 0; dfs(root); return result; } void dfs(TreeNode root) { if (root.left == null &amp;&amp; root.right == null) return; if (root.left != null) { if (root.left.left == null &amp;&amp; root.left.right == null) result += root.left.val; else dfs(root.left); } if (root.right != null) dfs(root.right); }}","link":"/2020/09/19/LeetCode/404.%20%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C/"},{"title":"LeetCode&#x2F;415. 字符串相加","text":"415. 字符串相加给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。 注意： num1和num2的长度都小于 5100. num1和num2都只包含数字0-9. num1和num2都不包含任何前导零。 你不能使用任何內建BigInteger库， 也不能直接将输入的字符串转换为整数形式。 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题思想很简单，就是利用加法原理，对应位相加再加上进位。 有些小细节我们需要注意： 两数相加有进位，我们需要新建一个变量存储进位信息 注意int和char的转换，我们给给越界数字串添加的是int 0而不是char '0' 最后得到的stringBuilder需要逆序 具体代码如下： 1234567891011121314151617181920212223242526272829303132class Solution { public String addStrings(String num1, String num2) { //我们建立两个指针，分别指向两个字符串的尾部 int index1 = num1.length() - 1; int index2 = num2.length() - 1; //count用来记录进位情况 int count = 0; //创建stringBuilder存放结果 StringBuilder stringBuilder = new StringBuilder(); //当两个指针没有越界，或者进位不为0时进行循环 while (index1 &gt;= 0 || index2 &gt;= 0 || count != 0) { //判断指针有没有越界，如果越界则补0 int i = index1 &lt; 0 ? 0 : num1.charAt(index1) - '0'; int j = index2 &lt; 0 ? 0 : num2.charAt(index2) - '0'; //我们将两数相加和进位的结果存放在temp中 int temp = i + j + count; //获取合数的个位存放进结果数组 stringBuilder.append(temp % 10); //获取进位情况 count = temp / 10; index1--; index2--; } //由于我们的stringBuilder是从零开始append的，所以需要将字符串reverse stringBuilder.reverse(); return stringBuilder.toString(); }}","link":"/2020/08/03/LeetCode/415.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0/"},{"title":"LeetCode&#x2F;454. 四数相加 II","text":"454. 四数相加 II给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。 为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -228 到 228 - 1 之间，最终结果不会超过 231 - 1 。 示例 ： 12345678910111213输入:A = [ 1, 2]B = [-2,-1]C = [-1, 2]D = [ 0, 2]输出:2解释:两个元组如下:1. (0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 02. (1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题虽然和18. 四数之和名字相近，但思路却不一样，这里参考官方解法，是一种比较好理解的方式，我们通过HashMap，将A和B中元素排列组合相加的元素值存入HashMap中，Key为(a+b)，Value为(a+b)结果出现的次数；同理对于C和D也这样操作，我们每次需要寻找HashMap中是否含有-(a+b)的Key，如果存在，直接让结果加上(a+b)出现的次数即可。 具体代码如下： 12345678910111213141516171819class Solution { public int fourSumCount(int[] A, int[] B, int[] C, int[] D) { Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int a : A) { for (int b : B) { map.put(a + b, map.getOrDefault(a + b, 0) + 1); } } int result = 0; for (int c : C) { for (int d : D) { if (map.containsKey(-c - d)) result += map.get(-c - d); } } return result; }}","link":"/2020/09/08/LeetCode/454.%20%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0%20II/"},{"title":"LeetCode&#x2F;437. 路径总和 III","text":"437. 路径总和 III给定一个二叉树，它的每个结点都存放着一个整数值。 找出路径和等于给定数值的路径总数。 路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。 二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。 示例： 123456789101112131415root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8 10 / \\ 5 -3 / \\ \\ 3 2 11 / \\ \\3 -2 1返回 3。和等于 8 的路径有:1. 5 -&gt; 32. 5 -&gt; 2 -&gt; 13. -3 -&gt; 11 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题网上讲了很多思路，有双递归和前缀和等等，我们这里还是延续该系列题型的思路，使用深度优先搜索遍历。由于路径开始的结点不一定是根结点，所以我们要递归的遍历以每个结点为根结点的情况下，是否有满足条件的路径，同时我们需要在每次递归当中设置一个新变量，该变量用来计算从当前结点出发满足条件的路径。 具体代码如下： 12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { public int pathSum(TreeNode root, int sum) { if (root == null) return 0; return dfs(root, sum) + pathSum(root.left, sum) + pathSum(root.right, sum); } private int dfs(TreeNode root, int sum) { if (root == null) return 0; sum -= root.val; //判断当前路径是否满足条件 int result = sum == 0 ? 1 : 0; return result + dfs(root.left, sum) + dfs(root.right, sum); }}","link":"/2020/11/23/LeetCode/437.%20%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%20III/"},{"title":"LeetCode&#x2F;455. 分发饼干","text":"455. 分发饼干假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。 对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。 示例 1: 123456输入: g = [1,2,3], s = [1,1]输出: 1解释: 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。所以你应该输出1。 示例 2: 123456输入: g = [1,2], s = [1,2,3]输出: 2解释: 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出2. 提示： 1 &lt;= g.length &lt;= 3 * 104 0 &lt;= s.length &lt;= 3 * 104 1 &lt;= g[i], s[j] &lt;= 231 - 1 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题虽然要用贪心策略，但是本题不涉及一个大饼干给多个小朋友分的情况，所以只需要判断当前s[i]是否小于g[j]即可，我们定义两个指针，如果满足s[j] &gt;= g[i]，就让result自增，同时将指针指向下一个小朋友，同时将饼干指针向后移。 具体代码如下： 123456789101112131415class Solution { public int findContentChildren(int[] g, int[] s) { Arrays.sort(g); Arrays.sort(s); int i = 0, j = 0, result = 0; while (i &lt; g.length &amp;&amp; j &lt; s.length) { if (s[j] &gt;= g[i]) { i++; result++; } j++; } return result; }}","link":"/2020/10/21/LeetCode/455.%20%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2/"},{"title":"LeetCode&#x2F;46. 全排列","text":"46. 全排列给定一个 没有重复 数字的序列，返回其所有可能的全排列。 示例 ： 12345678910输入: [1,2,3]输出:[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题的思想就是回溯，也可以说是一种暴力破解方法。我们不断的在递归之前将未出现的元素添加到track数组，在递归之后从track数组剔除元素并尝试加入下一个元素，最终遍历完所有的情况 具体代码如下： 12345678910111213141516171819202122232425262728293031class Solution { //存放结果数组 List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) { //记录路径 LinkedList&lt;Integer&gt; track = new LinkedList&lt;&gt;(); backtrack(nums, track); return res; } void backtrack(int[] nums, LinkedList&lt;Integer&gt; track) { //触发结束条件 if (track.size() == nums.length) { res.add(new LinkedList&lt;Integer&gt;(track)); return; } for (int i = 0; i &lt; nums.length; i++) { //排除不合法的选择 if (track.contains(nums[i])) { continue; } //将track中未出现的元素加入 track.add(nums[i]); backtrack(nums, track); //剔除最后一个元素，尝试下一个不同的元素 track.removeLast(); } }}","link":"/2020/09/01/LeetCode/46.%20%E5%85%A8%E6%8E%92%E5%88%97/"},{"title":"LeetCode&#x2F;47. 全排列 II","text":"47. 全排列 II给定一个可包含重复数字的序列，返回所有不重复的全排列。 示例 ： 1234567输入: [1,1,2]输出:[ [1,1,2], [1,2,1], [2,1,1]] 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题的思想就是回溯，也可以说是一种暴力破解方法。我们不断的在递归之前将未出现的元素添加到track数组，在递归之后从track数组剔除元素并尝试加入下一个元素，最终遍历完所有的情况 具体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution { List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); //临时结果数组，用于去重 HashSet&lt;List&lt;Integer&gt;&gt; temRes = new HashSet&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) { //记录路径 LinkedList&lt;Integer&gt; track = new LinkedList&lt;&gt;(); //标记数组，用于判断当前元素是否已经被遍历过 boolean[] used = new boolean[nums.length]; backtrack(nums, track, used); //将结果存入res中 for (List&lt;Integer&gt; temRe : temRes) { res.add(temRe); } return res; } void backtrack(int[] nums, LinkedList&lt;Integer&gt; track, boolean[] used) { //触发结束条件 if (track.size() == nums.length) { temRes.add(new LinkedList&lt;&gt;(track)); return; } for (int i = 0; i &lt; nums.length; i++) { //排除不合法的选择 if (used[i]) { continue; } //剪枝操作 if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !used[i - 1]) { continue; } //将当前元素加入track中并将标记为置为true track.add(nums[i]); used[i] = true; backtrack(nums, track, used); //取消选择 used[i] = false; track.removeLast(); } }}","link":"/2020/09/18/LeetCode/47.%20%E5%85%A8%E6%8E%92%E5%88%97%20II/"},{"title":"LeetCode&#x2F;5. 最长回文子串","text":"5. 最长回文子串给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 1： 123输入: &quot;babad&quot;输出: &quot;bab&quot;注意: &quot;aba&quot; 也是一个有效答案。 示例 2： 12输入: &quot;cbbd&quot;输出: &quot;bb&quot; 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：非常经典的题目，这里忽略暴力解法和Manacher算法只记录动态规划和中心扩散法。首先介绍动态规划方法，基于这样的思想，如果一个子串是回文子串，那么该子串掐头去尾后依然是回文字符串，用一个二维数组记录，dp[i][j]表示s[i,j]是否是回文子串 具体代码如下： 123456789101112131415161718192021222324252627282930313233class Solution { public String longestPalindrome(String s) { int n = s.length(); if (n &lt; 2) return s; int maxLength = 1; int start = 0; //可以不初始化对角线的值，因为对角线的值不会被其它位置参考 boolean[][] dp = new boolean[n][n]; //列向递增计算，保证前一列最下方的值被先计算出来，保证后一列状态转移方程不会缺失值 for (int j = 1; j &lt; n; j++) { for (int i = 0; i &lt; j; i++) { if (s.charAt(i) != s.charAt(j)) dp[i][j] = false; else { //边界条件，如果只有两个或者三个字符，其中两边的字符相同，那么这是一个回文子串 if (j - i &lt; 3) { dp[i][j] = true; } else { dp[i][j] = dp[i + 1][j - 1]; } } if (dp[i][j] &amp;&amp; j - i + 1 &gt; maxLength) { maxLength = j - i + 1; start = i; } } } return s.substring(start, start + maxLength); }} 还有一种中心扩散方法，从某个位置开始，依次向外扩散，求取最长回文子串，这种方法需要考虑当前位置为惠子子串的中心，该中心是奇数位置还是偶数位置，所以需要考虑两种情况，最后返回较长的子串即可 具体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution { //中心扩散法需要考虑中心位置是奇数还是偶数 public String longestPalindrome(String s) { int n = s.length(); if (n &lt; 2) return s; int maxLength = 1; int start = 0; for (int i = 0; i &lt; n - 1; i++) { int oddLength = help(s, i, i); int evenLength = help(s, i, i + 1); int curMaxLength = Math.max(oddLength, evenLength); if (curMaxLength &gt; maxLength) { maxLength = curMaxLength; //中心为奇或者偶的统一规律 start = i - (maxLength - 1) / 2; } } return s.substring(start, start + maxLength); } private int help(String s, int left, int right) { int n = s.length(); int i = left; int j = right; while (i &gt;= 0 &amp;&amp; j &lt; n) { if (s.charAt(i) == s.charAt(j)) { i--; j++; } else break; } //结束条件为s.charAt(i) != s.charAt(j) //回文串长度为j - i + 1 - 2 = j - i - 1 return j - i - 1; }}","link":"/2020/09/18/LeetCode/5.%20%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"},{"title":"LeetCode&#x2F;501. 二叉搜索树中的众数","text":"501. 二叉搜索树中的众数给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。 假定 BST 有如下定义： 结点左子树中所含结点的值小于等于当前结点的值 结点右子树中所含结点的值大于等于当前结点的值 左子树和右子树都是二叉搜索树 例如：给定 BST [1,null,2,2], 123451 \\ 2 /2 返回[2]. 提示：如果众数超过1个，不需考虑输出顺序 进阶：你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内） 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：二叉搜索树有一个很重要的特性，就是如果按照中序遍历二叉搜索树，我们会得到一个值依次递增的序列，所以只需要判断当前结点和父结点出现的次数，就可以得到结果数组。具体来说我们中序遍历一棵树，如果当前结点的值和父结点值相等，那我们就给currTime自增，如果当前结点是root结点，那么将currTime初始化为1。如果当前值出现次数比maxTime还大，那么将currTime的值赋给maxTime，并且将结果数组中的值清空，将当前结点的值加入到结果数组中；如果两者相等，即为两个不同的值出现次数相同的情况，我们将它们一并加入到结果数组中。 具体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution { List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); int maxTime = 0; int currTime = 0; TreeNode preNode = null; public int[] findMode(TreeNode root) { inOrder(root); int len = result.size(); int[] current = new int[len]; //将结果数组中的值取出以int[]形式返回 for (int i = 0; i &lt; len; i++) { current[i] = result.get(i); } return current; } //中序遍历树 void inOrder(TreeNode node) { if (node == null) { return; } inOrder(node.left); //判断当前出现次数是否为第一次，若是第一次初始化出现次数为1，否则自增加一 if (preNode != null &amp;&amp; preNode.val == node.val) { currTime++; } else { currTime = 1; } //判断当前出现次数是否比最大次数还大 if (currTime == maxTime) { result.add(node.val); } else if (currTime &gt; maxTime) { maxTime = currTime; //清掉以前存放的结果 result.clear(); result.add(node.val); } //很关键，别忘了向下递归的时候将当前结点赋给preNode preNode = node; inOrder(node.right); }}","link":"/2020/09/13/LeetCode/501.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0/"},{"title":"LeetCode&#x2F;50. Pow(x, n)","text":"50. Pow(x, n)实现 pow(x, n) ，即计算 x 的 n 次幂函数。 示例1： 12输入: 2.00000, 10输出: 1024.00000 示例2： 12输入: 2.10000, 3输出: 9.26100xxxxxxxxxx4 1输入: 2.10000, 32输出: 9.26100输入: intervals = [[1,4],[4,5]]3输出: [[1,5]]4解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。 示例 3: 123输入: 2.00000, -2输出: 0.25000解释: 2-2 = 1/22 = 1/4 = 0.25 说明: -100.0 &lt; x &lt; 100.0 n 是 32 位有符号整数，其数值范围是 [$-2^{31}$, $2^{31} − 1$] 。 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题可以直接使用 Java 的函数也能通过，但这明显不是我们想学习的，官方还有一种方法是迭代方法，这个方法通过找规律求解，在短时间内想到不容易，所以这里只记录递归方法。最原始的想法就是一个一个的乘起来，但是这样时间复杂度比较高，官方给出一种快速幂的思想，即 $x \\times x$，$x^2 \\times x^2$，$x^4 \\times x^4$…这样就能加速幂乘过程，但是这里要注意一个问题，就是幂指数为奇数的时候，应该怎么判断。快速幂算法给的是从后往前，每次幂指数折半，如果当前幂指数为奇数，就要在结果中再乘以一个$x$ 具体代码如下： 1234567891011121314151617181920212223class Solution { public double myPow(double x, int n) { double temp = recursion(x, n); //如果是负指数幂，需要返回结果的倒数 if (n &lt; 0) return 1 / temp; else{ return temp; } } private double recursion(double x, int n) { //递归终止条件，任何数的0次幂都是1 if (n == 0) return 1.0; //得到指数幂折半后的结果 double y = recursion(x, n / 2); if (n % 2 == 0) return y * y; else return y * y * x; }}","link":"/2020/11/13/LeetCode/50.%20Pow(x,%20n)/"},{"title":"LeetCode&#x2F;524. 通过删除字母匹配到字典里最长单词","text":"524. 通过删除字母匹配到字典里最长单词给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果答案不存在，则返回空字符串。 示例1： 12345输入:s = &quot;abpcplea&quot;, d = [&quot;ale&quot;,&quot;apple&quot;,&quot;monkey&quot;,&quot;plea&quot;]输出: &quot;apple&quot; 示例2： 12345输入:s = &quot;abpcplea&quot;, d = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]输出: &quot;a&quot; 说明: 所有输入的字符串只包含小写字母。 字典的大小不会超过 1000。 所有输入的字符串长度不会超过 1000。 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题要用到双指针的思想，即一个指针指向目标字符串s，另一个指针指向List&lt;String&gt; d中的每个字符串。我们循环遍历d中的字符串，如果其中字符和s中相等，我们使j指针加一，如果j指针已经到了d中字符串的尾部，判断当前符合要求的字符串是否比结果字符串长，并且是否字典序最小，如果满足条件，则将当前字符串赋值给结果字符串。 具体代码如下： 1234567891011121314151617class Solution { public String findLongestWord(String s, List&lt;String&gt; d) { String result = \"\"; for (String s1 : d) { for (int i = 0, j = 0; i &lt; s.length() &amp;&amp; j &lt; s1.length(); i++) { if (s.charAt(i) == s1.charAt(j)) j++; if (j == s1.length()) { if (s1.length() &gt; result.length() || (s1.length() == result.length() &amp;&amp; s1.compareTo(result) &lt; 0)) { result = s1; } } } } return result; }}","link":"/2020/09/23/LeetCode/524.%20%E9%80%9A%E8%BF%87%E5%88%A0%E9%99%A4%E5%AD%97%E6%AF%8D%E5%8C%B9%E9%85%8D%E5%88%B0%E5%AD%97%E5%85%B8%E9%87%8C%E6%9C%80%E9%95%BF%E5%8D%95%E8%AF%8D/"},{"title":"LeetCode&#x2F;53. 最大子序和","text":"53. 最大子序和给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例： 123输入: nums = [-2,1,-3,4,-1,2,1,-5,4]输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题由于要求局部的连续子数组的最大和，可以立马想到动态规划的方式来解题。因为只需要返回值，我们可以直接在原数组上进行操作，具体来说，如果当前元素的前一个元素小于零，那么加上一个负数势必不能保证当前和最大，所以如果出现这种情况直接跳过；如果当前元素的前一个元素大于零，那么就让当前元素加上前一个位置的值，将新值赋给当前位置。同时创建一个整型变量用来记录当前的连续子数组的最大和，最后返回该变量即可。 具体代码如下： 1234567891011121314151617class Solution { public int maxSubArray(int[] nums) { if (nums.length == 1) return nums[0]; int result = nums[0]; for (int i = 1; i &lt; nums.length; i++) { if (nums[i - 1] &gt; 0) { nums[i] += nums[i - 1]; result = Math.max(result, nums[i]); }else { result = Math.max(result, nums[i]); } } return result; }}","link":"/2020/11/23/LeetCode/53.%20%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/"},{"title":"LeetCode&#x2F;530. 二叉搜索树的最小绝对差","text":"530. 二叉搜索树的最小绝对差给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。 示例: 输入： 1 \\ 3 / 2 输出： 1 解释： 最小绝对差为 1，其中 2 和 1 的差的绝对值为 1（或者 2 和 3）。 提示： 树中至少有 2 个节点。 本题与 783 https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/ 相同 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解： 本题可以利用二叉搜索树的特性，对二叉搜索树进行中序遍历后序列是一个递增序列，所以很直观的想到对树进行中序遍历，然后逆向遍历找到最小的绝对值之差。 具体代码如下： 1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); public int getMinimumDifference(TreeNode root) { inOrder(root, result); int minValue = Integer.MAX_VALUE; for (int i = result.size() - 1; i &gt; 0; i--) { int temp = Math.abs(result.get(i) - result.get(i - 1)); if (minValue &gt; temp) { minValue = temp; } } return minValue; } void inOrder(TreeNode node, List&lt;Integer&gt; list) { if (node == null) return; inOrder(node.left, list); list.add(node.val); inOrder(node.right, list); }} 很显然，这样效率很差，因为要先中遍历，然后再对二叉树进行逆向遍历。进一步可以想到，在中序遍历的过程中直接搜索最小绝对值。具体做法就是创建一个preNode用来存放中序遍历中当前节点的上一个节点，因为中序遍历的特性，直接将minValue与node.val - preNode.val作比较，将较小值赋值给minValue。 具体代码如下： 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { int minValue = Integer.MAX_VALUE; TreeNode preNode = new TreeNode(Integer.MAX_VALUE); public int getMinimumDifference(TreeNode root) { inOrder(root); return minValue; } void inOrder(TreeNode node) { if (node == null) return; inOrder(node.left); int temp = Math.abs(node.val - preNode.val); if (minValue &gt; temp) minValue = temp; preNode = node; inOrder(node.right); }}","link":"/2020/10/12/LeetCode/530.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE/"},{"title":"LeetCode&#x2F;538. 把二叉搜索树转换为累加树","text":"538. 把二叉搜索树转换为累加树给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。 例如: 输入: 原始二叉搜索树: 5 / \\ 2 13 输出: 转换为累加树: 18 / \\ 20 13 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解： 本题官方的反中序遍历方法确实很厉害，但是也不是那么的高不可攀。我们一看到题目，最原始的想法就是，右边比左边大，那么就应该先把右子树处理完，然后得到一个累加值，然后再处理左子树各个节点，其实这就是中序遍历逆过来遍历。 具体代码如下： 12345678910111213class Solution { int sum = 0; public TreeNode convertBST(TreeNode root) { if (root != null) { convertBST(root.right); sum += root.val; root.val = sum; convertBST(root.left); } return root; }}","link":"/2020/09/21/LeetCode/538.%20%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91/"},{"title":"LeetCode&#x2F;54. 螺旋矩阵","text":"54. 螺旋矩阵给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。 示例1： 1234567输入:[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]]输出: [1,2,3,6,9,8,7,4,5] 示例2： 1234567891011输入:[ [1, 2, 3, 4], [5, 6, 7, 8], [9,10,11,12]]输出: [1,2,3,4,8,12,11,10,9,5,6,7]来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/spiral-matrix著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 限制： 0 &lt;= matrix.length &lt;= 100 0 &lt;= matrix[i].length &lt;= 100 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题和剑指 Offer 29. 顺时针打印矩阵一模一样，唯一的不同就是需要注意返回值的格式。思路比较好想，就是一圈一圈打印，由此思路，我们可以设置两个点，即方框左上角的点和右下角的点，每打印一圈，左上角的点向右下角缩，右下角的点向左上角缩，这样循环就可以打印完所有的点。这里还需要考虑两种特殊情况，如果左上角点的行和右下角点的行相等，直接递增打印这一行即可，同理若处于同一列，递增打印这一列即可。 具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution { int[] result; int index = 0; public int[] spiralOrder(int[][] matrix) { if (matrix.length == 0) return new int[]{}; int leftRow = 0; int leftColumn = 0; int rightRow = matrix.length - 1; int rightColumn = matrix[0].length - 1; result = new int[matrix.length * matrix[0].length]; while (leftRow &lt;= rightRow &amp;&amp; leftColumn &lt;= rightColumn) { printEdge(matrix, leftRow++, leftColumn++, rightRow--, rightColumn--); } return result; } private void printEdge(int[][] matrix, int leftRow, int leftColumn, int rightRow, int rightColumn) { if (leftRow == rightRow) { for (int i = leftColumn; i &lt;= rightColumn; i++) { result[index++] = matrix[leftRow][i]; } } else if (leftColumn == rightColumn) { for (int i = leftRow; i &lt;= rightRow; i++) { result[index++] = matrix[i][leftColumn]; } } else { int curColumn = leftColumn; int curRow = leftRow; while (curColumn != rightColumn) { result[index++] = matrix[leftRow][curColumn++]; } while (curRow != rightRow) { result[index++] = matrix[curRow++][rightColumn]; } while (curColumn != leftColumn) { result[index++] = matrix[rightRow][curColumn--]; } while (curRow != leftRow) { result[index++] = matrix[curRow--][leftColumn]; } } }}","link":"/2020/11/16/LeetCode/54.%20%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/"},{"title":"LeetCode&#x2F;547. 朋友圈","text":"547. 朋友圈班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。 给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。 示例 1: 1234567输入：[[1,1,0], [1,1,0], [0,0,1]]输出：2 解释：已知学生 0 和学生 1 互为朋友，他们在一个朋友圈。第2个学生自己在一个朋友圈。所以返回 2 。 示例 2: 123456输入：[[1,1,0], [1,1,1], [0,1,1]]输出：1解释：已知学生 0 和学生 1 互为朋友，学生 1 和学生 2 互为朋友，所以学生 0 和学生 2 也是朋友，所以他们三个在一个朋友圈，返回 1 。 提示： 1 &lt;= N &lt;= 200 M[i][i] == 1 M[i][j] == M[j][i] 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题已知朋友间的关系具有传递性，很显然就是一个并查集的问题，这里需要注意的是M[i][j] == M[j][i]，那么我们只需要遍历矩阵的右上半边即可 具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839class Solution { public int findCircleNum(int[][] M) { //初始假设每个人独立成一个簇，自己是自己父节点 int[] parents = new int[M.length]; Arrays.fill(parents, -1); //将有联系的两个小朋友划分为一个簇，这里注意只需要遍历一半矩阵 for (int i = 0; i &lt; M.length; i++) { for (int j = 0; j &lt; i; j++) { if (M[i][j] == 1 &amp;&amp; i != j) { union(parents, i, j); } } } //计算簇的个数，即父节点个数，即 parents[i] == -1的节点的个数 int count = 0; for (int i = 0; i &lt; parents.length; i++) { if (parents[i] == -1) count++; } return count; } private int find(int[] parents, int i) { if (parents[i] == -1) { return i; } return find(parents, parents[i]); } private void union(int parent[], int x, int y) { int xParent = find(parent, x); int yParent = find(parent, y); if (xParent != yParent) { parent[xParent] = yParent; } }} 提示还给出了深度优先搜索遍历，DFS的基本思想就是从一个节点开始，搜索完所有的相邻节点成一个簇，然后搜索下一个还未搜索的节点 具体代码如下： 12345678910111213141516171819202122232425class Solution { public int findCircleNum(int[][] M) { boolean[] visited = new boolean[M.length]; int count = 0; for (int i = 0; i &lt; M.length; i++) { //如果当前节点没有被访问过，进行DFS if (!visited[i]) { dfs(M, visited, i); //一次递归遍历结束，簇的个数加一 count++; } } return count; } private void dfs(int[][] m, boolean[] visited, int i) { for (int j = 0; j &lt; m.length; j++) { if (m[i][j] == 1 &amp;&amp; !visited[j]) { //将当前节点标记，并递归遍历下一个节点 visited[j] = true; dfs(m, visited, j); } } }}","link":"/2020/10/27/LeetCode/547.%20%E6%9C%8B%E5%8F%8B%E5%9C%88/"},{"title":"LeetCode&#x2F;56. 合并区间","text":"56. 合并区间给出一个区间的集合，请合并所有重叠的区间。 示例1： 123输入: intervals = [[1,3],[2,6],[8,10],[15,18]]输出: [[1,6],[8,10],[15,18]]解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. 示例2： 123输入: intervals = [[1,4],[4,5]]输出: [[1,5]]解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。 注意：输入类型已于2019年4月15日更改。 请重置默认代码定义以获取新方法签名。 提示： intervals[i][0] &lt;= intervals[i][1] 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题在1288. 删除被覆盖区间的基础上更进一步，但是思路大同小异。首先对数组进行排序，按第一个元素升序，第二个元素降序排列。排列完成后需要考虑两种情况：1. 两个区间有交集，那么需要找出右边界最大的区间；2. 两个区间没有交集，直接将新区间添加进结果数组即可。 具体代码如下： 12345678910111213141516171819202122232425262728293031323334353637class Solution { public int[][] merge(int[][] intervals) { //判空操作 if (intervals.length == 0) return new int[][]{}; //对数组进行排序 Arrays.sort(intervals, (a, b) -&gt; { if (a[0] == b[0]) return b[1] - a[1]; return a[0] - b[0]; }); //将排序后数组中的第一个元素加入结果链表中 Deque&lt;int[]&gt; list = new LinkedList&lt;&gt;(); int left = intervals[0][0]; int right = intervals[0][1]; list.add(new int[]{left, right}); for (int i = 1; i &lt; intervals.length; i++) { int[] temp = intervals[i]; //如果两个区间不相交，直接添加新区间即可 if (temp[0] &gt; right) { left = temp[0]; right = temp[1]; list.add(new int[]{left, right}); } else { //如果两个区间相交，找出最大的右边界 int[] curr = list.removeLast(); right = Math.max(curr[1], temp[1]); curr[1] = right; list.add(curr); } } return list.toArray(new int[list.size()][]); }}","link":"/2020/10/06/LeetCode/56.%20%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/"},{"title":"LeetCode&#x2F;60. 第k个排列","text":"60. 第k个排列给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。 按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下： &quot;123&quot; &quot;132&quot; &quot;213&quot; &quot;231&quot; &quot;312&quot; &quot;321&quot; 给定 n 和 k，返回第 k 个排列。 说明： 给定 n 的范围是 [1, 9]。 给定 k 的范围是[1, n!]。 示例1： 12输入: n = 3, k = 3输出: &quot;213&quot; 示例2: 12输入: n = 4, k = 9输出: &quot;2314&quot; 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题一看到排列，我们就想到了回溯。如果单纯的生成所有可能取值，再从中获取目标字符串肯定会超时。通过观察，我们可以发现一定的规律，即数字的全排列是成组的。 1234567891011121314151617举个例子，比如我们的n = 4, k = 9，我们有如下的排列：------------以&quot;1&quot;开头------------ [1, 2, 3, 4] index = 0 [1, 2, 4, 3] index = 1 [1, 3, 2, 4] index = 2 [1, 3, 4, 2] index = 3 [1, 4, 2, 3] index = 4 [1, 4, 3, 2] index = 5------------以&quot;2&quot;开头------------ [2, 1, 3, 4] index = 6 [2, 1, 4, 3] index = 7 [2, 3, 1, 4] index = 8 这是我们要找的目标值 [2, 3, 4, 1] index = 9 [2, 4, 1, 3] index = 10 [2, 4, 3, 1] index = 11------------以&quot;3&quot;开头------------ 此处省略。。。。。。。 有了如上的规律，那么我们就可以缩减问题的规模，通过n和k可以算出目标字符串是以哪个数字开头的，然后通过剩下的数字进行排列，再定位我们要找的是该组中的第几个，就可以得到最终的结果。比如说，我们现在的n = 4, k = 9，我们可以计算出每组有(n-1)!=3!=6个排列，然后我们给positon + gap和k进行比较，同时初始化一个变量count用来算出第一个数字是多少，如果positon + gap小于k，说明我们要找的目标字符串肯定不在该组中，如果positon + gap大于k，则该组中有我们的目标字符串。我们通过position = k - (position - gap) - 1来定位目标字符串在该组的位置，通过count--来定位目标字符串在哪个组中。最后，我们用backtrack来生成剩下数字的排列，进行拼接就可以获取到目标字符串。 具体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class Solution { //存放结果数组 List&lt;String&gt; res = new LinkedList&lt;&gt;(); //存放路径 StringBuilder track; //gap为每组间隔，position为结果在该组的位置，count为列表第一个数字的值 int n, k, gap = 1, position = 0, count = 1; public String getPermutation(int n, int k) { this.n = n; this.k = k; //标记当前值是否被使用 boolean[] used = new boolean[n - 1]; //计算间隔 for (int i = n - 1; i &gt; 0; i--) { gap *= i; } //如果position位置大于k时，说明目标列表在当前组中 while (position &lt; k) { position += gap; //用来计算第一个数字为几 count++; } //寻找目标最终位置 position = k - (position - gap) - 1; count--; //组装除结果列表第一个元素外的列表 ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; n; i++) { if (i + 1 == count) { continue; } list.add(i + 1); } //将ArrayList转换为int数组 int[] nums = list.stream().mapToInt(m -&gt; m).toArray(); //记录路径 this.track = new StringBuilder(); //将列表开头元素加入 track.append(count); backtrack(nums, track, used); //获取目标字符串 return res.get(position); } void backtrack(int[] nums, StringBuilder track, boolean[] used) { //触发结束条件 //如果track.length() == n，说明生成了一个字符串结果 if (track.length() == n) { res.add(track.toString()); return; } for (int i = 0; i &lt; nums.length; i++) { //排除不合法的选择 if (used[i]) { continue; } //将track中未出现的元素加入 used[i] = true; track.append(nums[i]); backtrack(nums, track, used); //剔除最后一个元素，尝试下一个不同的元素 used[i] = false; track.deleteCharAt(track.length() - 1); } }} 当然了，还有一种数学归纳的方法，可以直接判断出目标字符串。所用到的原理和我们上述的比较positon + gap和k的大小，来判断当前位置该填写哪个数字。我们还是以上述的n = 4, k = 9举例，计算出每组有(n-1)!=3!=6个排列，可以定位到第一个位置的数字为2，利用(n-2)!=2!=2和k = k - m * (n - 1)!= 3 ，这里的m是指经过多少个gap定位到目标字符串。接着我们继续重复上面的过程继续往下搜索，由于2 &lt; 3，所以我们可以确定第二位数组为3，利用(n-3)!=1!=1和k = k - m * (n - 2)!= 1，最终可以定位到2314，即我们需要找的目标字符串。 上述两种方法，都对排列的顺序有要求，如果顺序打乱，就不能得到想要的结果。 具体代码请参考官网题解","link":"/2020/09/01/LeetCode/60.%20%E7%AC%ACk%E4%B8%AA%E6%8E%92%E5%88%97/"},{"title":"LeetCode&#x2F;589. N叉树的前序遍历","text":"589. N叉树的前序遍历给定一个 N 叉树，返回其节点值的前序遍历。 例如，给定一个 3叉树 : 返回其前序遍历: [1,3,5,6,2,4]。 说明: 递归法很简单，你可以使用迭代法完成此题吗? 来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 题解：既然是树的遍历，那么一共就是两种思路，即深度优先搜索遍历和广度优先搜索遍历。其中递归法就是深度优先搜索遍历的思想，我们从左到右依次遍历N叉树的每个节点。 具体代码如下： 1234567891011121314151617181920212223242526272829303132/*// Definition for a Node.class Node { public int val; public List&lt;Node&gt; children; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, List&lt;Node&gt; _children) { val = _val; children = _children; }};*/class Solution { List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); public List&lt;Integer&gt; preorder(Node root) { if (root == null) return result; result.add(root.val); //遍历当前节点的所有孩子节点 for (int i = 0; i &lt; root.children.size(); i++) { preorder(root.children.get(i)); } return result; }} 题目要求思考迭代方法来遍历，能想到的就是借鉴广度优先搜索遍历的方法。创建一个栈，每次栈顶弹出的元素就是前序遍历的顺序。具体来说，逆序每个节点的孩子节点，然后依次入栈，每次pop()栈顶的元素，就是前序遍历的顺序。 具体代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940/*// Definition for a Node.class Node { public int val; public List&lt;Node&gt; children; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, List&lt;Node&gt; _children) { val = _val; children = _children; }};*/class Solution { List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); public List&lt;Integer&gt; preorder(Node root) { if (root == null) return result; Deque&lt;Node&gt; deque = new ArrayDeque&lt;&gt;(); deque.add(root); while (!deque.isEmpty()) { Node node = deque.pop(); result.add(node.val); //每次逆序入栈当前节点的所有孩子节点 Collections.reverse(node.children); for (Node child : node.children) { deque.push(child); } } return result; }}","link":"/2020/09/09/LeetCode/589.%20N%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"title":"LeetCode&#x2F;617. 合并二叉树","text":"617. 合并二叉树给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。 你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。 示例1 ： 1234567891011121314输入: Tree 1 Tree 2 1 2 / \\ / \\ 3 2 1 3 / \\ \\ 5 4 7 输出: 合并后的树: 3 / \\ 4 5 / \\ \\ 5 4 7 注意: 合并必须从两个树的根节点开始。 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题就是一个二叉树的遍历，你可以采用深度优先搜索，也可采用广度优先搜索，这里深度优先搜索比较好实现。我们采用前序遍历，当遍历每个节点时，如果t1为空，则直接返回t2，反之直接返回t1，如果不为空，将两节点的值相加赋给新树，递归遍历即可。 具体代码如下： 123456789101112131415161718192021/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public TreeNode mergeTrees(TreeNode t1, TreeNode t2) { if (t1 == null) return t2; if (t2 == null) return t1; TreeNode root = new TreeNode(t1.val + t2.val); root.left = mergeTrees(t1.left, t2.left); root.right = mergeTrees(t1.right, t2.right); return root; }} 12345678910111213141516171819/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public TreeNode mergeTrees(TreeNode t1, TreeNode t2) { if (t1 == null || t2 == null) return t1 == null ? t2 : t1; t1.val += t2.val; t1.left = mergeTrees(t1.left, t2.left); t1.right = mergeTrees(t1.right, t2.right); return t1; }}","link":"/2020/09/23/LeetCode/617.%20%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"title":"LeetCode&#x2F;63. 不同路径Ⅱ","text":"63. 不同路径 II一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？ 网格中的障碍物和空位置分别用 1 和 0 来表示。 说明：m和 n 的值均不超过 100。 示例 1: 12345678910111213输入:[[0,0,0],[0,1,0],[0,0,0]]输出: 2解释:3x3 网格的正中间有一个障碍物。从左上角到右下角一共有 2 条不同的路径：1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题是62题的升级版本，思想基于动态规划思想，若碰到障碍物，那么到(i,j)点的路径数量为0，否则到(i,j)点的路径数量为(i,j-1)加上(i-1,j)的路径数量。具体递归方程如下： dp(i,j)=\\begin{cases} 0,&obstacleGrid(i,j)=0 \\\\ dp(i-1,j)+dp(i,j-1),&obstacleGrid(i,j)\\not=0 \\end{cases}其中第一行和第一列，由于只能一直横着走或者一直竖着走，那么到该行该列上点的路径恒为1，具体实现代码如下： 123456789101112131415161718192021222324252627class Solution { public static int uniquePathsWithObstacles(int[][] obstacleGrid) { //初始化方格尺寸 int m = obstacleGrid.length; int n = obstacleGrid[0].length; int[][] dp = new int[m][n]; //初始化路径数组 //初始化第一行 for (int i = 0; i &lt; m &amp;&amp; obstacleGrid[i][0] == 0; i++) { dp[i][0] = 1; } //初始化第一列 for (int i = 0; i &lt; n &amp;&amp; obstacleGrid[0][i] == 0; i++) { dp[0][i] = 1; } //若没有障碍物，则(i,j)点的路径数量为(i,j-1)与(i-1,j)的路径数量之和 for (int i = 1; i &lt; m; i++) { for (int j = 1; j &lt; n; j++) { if (obstacleGrid[i][j] == 0) dp[i][j] = dp[i][j - 1] + dp[i - 1][j]; } } //最后返回右下角的dp值，即为总路径数量 return dp[m - 1][n - 1]; }}","link":"/2020/10/01/LeetCode/63.%20%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%E2%85%A1/"},{"title":"LeetCode&#x2F;62. 不同路径","text":"62. 不同路径一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 问总共有多少条不同的路径？ 例如，上图是一个7 x 3的网格。有多少可能的路径？ 示例 1: 输入: m = 3, n = 2输出: 3解释:从左上角开始，总共有 3 条路径可以到达右下角。 向右 -&gt; 向右 -&gt; 向下 向右 -&gt; 向下 -&gt; 向右 向下 -&gt; 向右 -&gt; 向右 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题思想基于动态规划思想，到(i,j)点的路径之和等于到点(i,j-1)与点(i-1,j)的路径之和，递归方程如下： dp(i,j)= dp(i-1,j)+dp(i,j-1)其中第一行和第一列，由于只能一直横着走或者一直竖着走，那么到该行该列上点的路径恒为1，具体实现代码如下： 123456789101112131415161718192021222324class Solution { public int uniquePaths(int m, int n) { int[][] dp = new int[m][n];//初始化路径数组 //初始化第一行 for (int i = 0; i &lt; m; i++) { dp[i][0] = 1; } //初始化第一列 for (int i = 0; i &lt; n; i++) { dp[0][i] = 1; } //递归求解dp数组 for (int i = 1; i &lt; m; i++) { for (int j = 1; j &lt; n; j++) { dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } //最后返回右下角的dp值，即为总路径数量 return dp[m - 1][n - 1]; }}","link":"/2020/10/01/LeetCode/62.%20%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/"},{"title":"LeetCode&#x2F;633. 平方数之和","text":"633. 平方数之和给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a2 + b2 = c。 示例1 ： 123输入: 5输出: True解释: 1 * 1 + 2 * 2 = 5 示例2： 12输入: 3输出: False 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题基于双指针法，创建两个指针，一个指向头，一个指向尾，但在数学中我们知道，两数只需要判断到小于目标数字c的开方即可。 具体代码如下： 1234567891011121314class Solution { public boolean judgeSquareSum(int c) { int left = 0, right = (int) Math.sqrt(c); while (left &lt;= right) { if (left * left + right * right == c) return true; else if (left * left + right * right &gt; c) right--; else left++; } return false; }}","link":"/2020/09/21/LeetCode/633.%20%E5%B9%B3%E6%96%B9%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"title":"LeetCode&#x2F;637. 二叉树的层平均值","text":"637. 二叉树的层平均值给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。 示例1: 输入： 3 / \\ 9 20 / \\ 15 7 输出：[3, 14.5, 11] 解释： 第 0 层的平均值是 3 , 第1层是 14.5 , 第2层是 11 。因此返回 [3, 14.5, 11] 。 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解： 如果做过二叉树的层序遍历的话想这道题其实很简单，需要改变的地方就是我们不再维护一个ArrayList来存储遍历的每一层的数值，而是直接用一个Double变量将每层值加起来然后除以每层的size。 具体代码如下： 123456789101112131415161718192021222324class Solution { public List&lt;Double&gt; averageOfLevels(TreeNode root) { List&lt;Double&gt; result = new ArrayList&lt;&gt;(); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while (!queue.isEmpty()) { Double temp = 0.0; int len = queue.size(); for (int i = 0; i &lt; len; i++) { TreeNode node = queue.poll(); temp += node.val; if (node.left != null) { queue.add(node.left); } if (node.right != null) { queue.add(node.right); } } result.add(temp / len); } return result; }}","link":"/2020/09/12/LeetCode/637.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC/"},{"title":"LeetCode&#x2F;64. 最小路径和","text":"64. 最小路径和给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。 示例 : 12345678输入:[ [1,3,1], [1,5,1], [4,2,1]]输出: 7解释: 因为路径 1→3→1→1→1 的总和最小。 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题和62. 不同路径基本上就是一毛一样，所以我们还是采用动态规划的思想，第一行和第一列由于只能一直横着走或者一直竖着走比较特殊，我们首先初始化第一行和第一列。对于普通元素(i,j)，我们可以写出状态转移方程$dp[i][j]=min(dp[i-1][j],dp[i][j-1])$，最后返回dp数组的最后一个元素即可。 具体实现代码如下： 1234567891011121314151617181920212223class Solution { public int minPathSum(int[][] grid) { int[][] dp = new int[grid.length][grid[0].length]; dp[0][0] = grid[0][0]; //初始化第一行 for (int i = 1; i &lt; grid.length; i++) { dp[i][0] = dp[i - 1][0] + grid[i][0]; } //初始化第一列 for (int i = 1; i &lt; grid[0].length; i++) { dp[0][i] = dp[0][i - 1] + grid[0][i]; } //动态规划求解dp数组 for (int i = 1; i &lt; grid.length; i++) { for (int j = 1; j &lt; grid[0].length; j++) { dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]; } } return dp[grid.length - 1][grid[0].length - 1]; }} 当然，本题的空间复杂度较高，我们发现dp[i][j]只与dp[i-1][j]和dp[i][j-1]有关，所以我们可以将dp数组从二维压缩到一维。我们必须明确，纵向为i横向为j，如下图所示： 首先将j指向的第一行更新，dp[j]=dp[j-1]+grid[0][j]，然后进行迭代，如果j==0时，dp[0]的更新只与上一次dp[0]的值有关，即dp[j] += grid[i][j]，如果j!=0，dp[j]的值与它左边和上边的值有关，即dp[j] = Math.min(dp[j], dp[j - 1]) + grid[i][j]。 具体代码如下： 12345678910111213141516171819202122class Solution { public int minPathSum(int[][] grid) { int[] dp = new int[grid[0].length]; dp[0] = grid[0][0]; //初始化第一行 for (int j = 1; j &lt; grid[0].length; j++) { dp[j] = dp[j - 1] + grid[0][j]; } for (int i = 1; i &lt; grid.length; i++) { for (int j = 0; j &lt; grid[0].length; j++) { if (j == 0) { dp[j] += grid[i][j]; } else { dp[j] = Math.min(dp[j], dp[j - 1]) + grid[i][j]; } } } return dp[grid[0].length - 1]; }}","link":"/2020/07/23/LeetCode/64.%20%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"},{"title":"LeetCode&#x2F;653. 两数之和 IV - 输入 BST","text":"653. 两数之和 IV - 输入 BST给定一个二叉搜索树和一个目标结果，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。 案例1: 输入: 5 / \\ 3 6 / \\ \\ 2 4 7 Target = 9 输出: True 案例2： 12345678910输入: 5 / \\ 3 6 / \\ \\2 4 7Target = 28输出: False 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解： 本题和该系列前几道题思路是一样的，就是将结果存储在一个集合中，然后对二叉搜索树进行遍历，如果能找到两个相加等于目标值的节点，则返回true，否则返回false。 具体代码如下： 123456789101112131415class Solution { public boolean findTarget(TreeNode root, int k) { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); return search(root, k, list); } boolean search(TreeNode node, int target, List&lt;Integer&gt; list) { if (node == null) return false; if (list.contains(target - node.val)) return true; list.add(node.val); return search(node.left, target - node.val, list) || search(node.right, target - node.val, list); }}","link":"/2020/10/05/LeetCode/653.%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%20IV%20-%20%E8%BE%93%E5%85%A5%20BST/"},{"title":"LeetCode&#x2F;654. 最大二叉树","text":"654. 最大二叉树给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下： 二叉树的根是数组中的最大元素。 左子树是通过数组中最大值左边部分构造出的最大二叉树。 右子树是通过数组中最大值右边部分构造出的最大二叉树。 通过给定的数组构建最大二叉树，并且输出这个树的根节点。 示例: 输入：[3,2,1,6,0,5] 输出：返回下面这棵树的根节点： 6 / \\ 3 5 \\ / 2 0 \\ 1 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解： 本题其实很好想，我们首先明确需要干什么。首先需要找出这个数组中最大的值，记录这个最大值和最大值所在的索引，让这个最大值成为树的根节点。然后就是递归的生成左子树和右子树，分别对应数组中最大值左边的值和右边的值。最后返回这棵树即可。 具体代码如下： 123456789101112131415161718192021222324252627282930class Solution { public TreeNode constructMaximumBinaryTree(int[] nums) { return build(nums, 0, nums.length - 1); } TreeNode build(int[] nums, int left, int right) { //结束条件 if (left &gt; right) return null; //初始化最大值和最大值所在索引 int index = -1; int largest = Integer.MIN_VALUE; //循环遍历数组，找出该区间中的最大值和最大值索引 for (int i = left; i &lt;= right; i++) { if (nums[i] &gt; largest) { index = i; largest = nums[i]; } } //利用当前区间中的最大值生成根节点 TreeNode node = new TreeNode(largest); //递归生成左子树和右子树 node.left = build(nums, left, index - 1); node.right = build(nums, index + 1, right); //返回该树即可 return node; }}","link":"/2020/09/12/LeetCode/654.%20%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"title":"LeetCode&#x2F;657. 机器人能否返回原点","text":"657. 机器人能否返回原点在二维平面上，有一个机器人从原点(0, 0)开始。给出它的移动顺序，判断这个机器人在完成移动后是否在(0, 0) 处结束。 移动顺序由字符串表示。字符 move[i] 表示其第 i 次移动。机器人的有效动作有 R（右），L（左），U（上）和 D（下）。如果机器人在完成所有动作后返回原点，则返回 true。否则，返回 false。 注意：机器人“面朝”的方向无关紧要。 “R” 将始终使机器人向右移动一次，“L” 将始终向左移动等。此外，假设每次移动机器人的移动幅度相同。 示例1 ： 123输入: &quot;UD&quot;输出: true解释：机器人向上移动一次，然后向下移动一次。所有动作都具有相同的幅度，因此它最终回到它开始的原点。因此，我们返回 true。 示例2： 123输入: &quot;LL&quot;输出: false解释：机器人向左移动两次。它最终位于原点的左侧，距原点有两次 “移动” 的距离。我们返回 false，因为它在移动结束时没有返回原点。 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题思路很简单，一开始想到的就是创建两个整型变量，通过加左减右，加上减下的方法，当遍历完整个字符串后，看两个变量是否为0，如果为0则证明机器人回到了原点。 具体代码如下： 123456789101112131415161718192021class Solution { public boolean judgeCircle(String moves) { if (moves.isEmpty()) { return true; } int up = 0; int left = 0; for (int i = 0; i &lt; moves.length(); i++) { char s = moves.charAt(i); if (s == 'U') up++; if (s == 'D') up--; if (s == 'L') left++; if (s == 'R') left--; } return up == 0 &amp;&amp; left == 0; }}","link":"/2020/08/28/LeetCode/657.%20%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%83%BD%E5%90%A6%E8%BF%94%E5%9B%9E%E5%8E%9F%E7%82%B9/"},{"title":"LeetCode&#x2F;680. 验证回文字符串 Ⅱ","text":"680. 验证回文字符串 Ⅱ给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。 示例1: 12输入: &quot;aba&quot;输出: True 示例2： 123输入: &quot;abca&quot;输出: True解释: 你可以删除c字符。 注意: 字符串只包含从 a-z的小写字母。字符串的最大长度是50000。 来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 题解：本题和125. 验证回文串很像，除去了标点符号和大小写，但是增加了可以删除一个元素的条件。我们还是创建双指针，这里我们选择将字符串s转换为char[]数组，这样能够提高速度。left指针向前遍历，right指针向后遍历，因为题目说了允许删除一个字符来构成回文字符串，所以我们在遇到第一个不是回文的两个字符后，可以通过isValidPalindrome方法判断夹在left和right之间的子串是不是回文子串。这样，当遇到第一组不相同的字符后，我们进入isValidPalindrome判断，如果子串继续不相同，那么就不是回文字符串，如果相同就是。 具体代码如下： 12345678910111213141516171819202122class Solution { public boolean validPalindrome(String s) { int left = 0, right = s.length() - 1; char[] chars = s.toCharArray(); while (left &lt; right) { if (chars[left] != chars[right]) //如果两个子串有一个不是回文子串，那么该字符串就不是回文字符串 return isValidPalindrome(chars, left + 1, right) || isValidPalindrome(chars, left, right - 1); left++; right--; } return true; } private boolean isValidPalindrome(char[] chars, int left, int right) { while (left &lt; right) { if (chars[left++] != chars[right--]) return false; } return true; }}","link":"/2020/09/22/LeetCode/680.%20%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2%20%E2%85%A1/"},{"title":"LeetCode&#x2F;684. 冗余连接","text":"684. 冗余连接在本问题中, 树指的是一个连通且无环的无向图。 输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, ..., N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。 结果图是一个以边组成的二维数组。每一个边的元素是一对[u, v] ，满足 u &lt; v，表示连接顶点u 和v的无向图的边。 返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 [u, v] 应满足相同的格式 u &lt; v。 示例1 ： 123456输入: [[1,2], [1,3], [2,3]]输出: [2,3]解释: 给定的无向图为: 1 / \\2 - 3 示例 2： 123456输入: [[1,2], [2,3], [3,4], [1,4], [1,5]]输出: [1,4]解释: 给定的无向图为:5 - 1 - 2 | | 4 - 3 注意: 输入的二维数组大小在 3 到 1000。 二维数组中的整数在1到N之间，其中N是输入数组的大小。 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：判断路径中是否有环，在数据结构中我们学习过两种方法，即深度优先搜索遍历(DFS)和拓扑排序，在LeetCode上还有一种方法叫做并查集，我们一并介绍。 深度优先搜索遍历(DFS)深度优先搜索遍历思想很简单，就是从某个结点开始不停地找相邻顶点，判断edges中的边的两个结点是否已经存在路径，如果存在，直接返回当前edge即我们要的结果。具体来说，就是将edges中每个edge的两个端点赋值给currNode和nextNode，我们去判断，能不能从currNode最终找到nextNode，如果能够找到，说明两端点之间已经存在一条路径，这时候，currNode和nextNode这条新的edge如果加入到graph中，那么一定会产生环，我们直接返回。 具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution { public int[] findRedundantConnection(int[][] edges) { if (edges.length == 0) { return new int[]{}; } //用来存放无向图 Map&lt;Integer, ArrayList&lt;Integer&gt;&gt; graph = new HashMap&lt;&gt;(); for (int[] edge : edges) { int currNode = edge[0]; int nextNode = edge[1]; //用于DFS标记当前结点有没有被访问 boolean[] visited = new boolean[edges.length + 1]; //查找currNode和nextNode之间是否有路径 if (hasPath(currNode, nextNode, graph, visited)) { return edge; } //如果两个结点之间没有路径，则将两个结点加入到图中 if (graph.get(currNode) == null) { graph.put(currNode, new ArrayList&lt;&gt;()); } graph.get(currNode).add(nextNode); if (graph.get(nextNode) == null) { graph.put(nextNode, new ArrayList&lt;&gt;()); } graph.get(nextNode).add(currNode); } return new int[]{}; } private boolean hasPath(int currNode, int nextNode, Map&lt;Integer, ArrayList&lt;Integer&gt;&gt; graph, boolean[] vistied) { //说明currNode已经到nextNode，即currNode与nextNode存在路径 if (currNode == nextNode) { return true; } vistied[currNode] = true; //当前两个结点都没有被访问过，则直接返回false if (!graph.containsKey(currNode) || !graph.containsKey(nextNode)) { return false; } ArrayList&lt;Integer&gt; neighbor = graph.get(currNode); for (Integer temp : neighbor) { //如果当前结点已经被访问过，则跳过访问下一个结点 if (vistied[temp]) { continue; } if (hasPath(temp, nextNode, graph, vistied)) { return true; } } return false; }} 由于采用深度优先搜索遍历，时间复杂度非常糟糕 拓扑排序拓扑排序思想其实和广度优先搜索遍历大同小异，我们首先将edges中所有边加入图中，由于无向图不像有向图那样可以找到入度为0的起始点，我们只能搜索所有入度为1的结点，将它们加入队列当中。我们遵循这样的原则：首先从队列中弹出一个结点，找出与该结点相邻的所有结点，然后将这些结点的入度都减1，看看这些结点中有没有入度为1的结点，如果有，将它们入队，如此循环结束。我们寻找inCount数组中是否还有入度不为1的结点，这些结点对应的边就会形成环，我们逆序遍历，找到最后的那个成环的边返回即可。 具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution { public int[] findRedundantConnection(int[][] edges) { if (edges.length == 0) { return new int[]{}; } //用来存放无向图 int[] inCount = new int[edges.length + 1]; Map&lt;Integer, ArrayList&lt;Integer&gt;&gt; graph = new HashMap&lt;&gt;(); for (int[] edge : edges) { int currNode = edge[0]; int nextNode = edge[1]; //入度自增一 inCount[currNode]++; inCount[nextNode]++; //将两个结点加入到图关系中 if (graph.get(currNode) == null) { graph.put(currNode, new ArrayList&lt;&gt;()); } graph.get(currNode).add(nextNode); if (graph.get(nextNode) == null) { graph.put(nextNode, new ArrayList&lt;&gt;()); } graph.get(nextNode).add(currNode); } //在无向图中，入度至少为1，我们遍历整个graph，将入度为1的结点加入队列 Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); for (int i = 1; i &lt; edges.length + 1; i++) { if (inCount[i] == 1) { queue.add(i); } } //将队列中的元素出队，并将与之相邻的结点入度减1，如果相邻结点入度为1，则将该结点入队 while (!queue.isEmpty()) { Integer temp = queue.poll(); ArrayList&lt;Integer&gt; integers = graph.get(temp); for (Integer integer : integers) { if (--inCount[integer] == 1) { queue.add(integer); } } } //如果遍历完后，inCount数组中还剩下入度大于1的元素，则这些元素对应的边就是环，我们逆序返回最后一个边即可 for (int i = edges.length - 1; i &gt; 0; i--) { if (inCount[edges[i][0]] &gt; 1 &amp;&amp; inCount[edges[i][1]] &gt; 1) { return edges[i]; } } return new int[]{}; }} 可以看到，采用拓扑排序，时间复杂度只是提高了一点点 并查集并查集看过思想以后发现非常简单，并查集顾名思义有两个操作，即查找和合并，查找是查找当前元素的id，合并是指将两个有边连接的集合合并成一个集合，这里我们要把所有结点都与该集合的根结点直接相连，这样形成的树足够的平，保证能在O(1)的时间复杂度里面查找到我们想要的元素id。在本题中，查找即对应着查找当前结点的集合根结点是谁，合并即如果当前边所对应的两个结点不在同一集合，那么我们需要将这两个集合合并在一起。我们每次得到的u和v，需要判断当前两个结点是否处于同一集合当中，如果是，则加入这条边就会成环，我们需要返回这条边。 具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution { public int[] findRedundantConnection(int[][] edges) { //存放当前结点父结点是哪个 int[] parents = new int[edges.length + 1]; //存放当前结点所在集合大小 int[] sizes = new int[edges.length + 1]; //默认每个森林只有一个结点的话，大小为1 Arrays.fill(sizes, 1); for (int[] edge : edges) { int u = edge[0]; int v = edge[1]; //如果集合根结点为0，则将当前结点令集合为根结点 if (parents[u] == 0) parents[u] = u; if (parents[v] == 0) parents[v] = v; //寻找u和v的根结点 int pu = find(u, parents); int pv = find(v, parents); //如果父结点相等，添加这条边后会形成环 if (pu == pv) return edge; //我们始终将小集合merge入大集合当中 if (sizes[pv] &gt; sizes[pu]) { int temp = pv; pv = pu; pu = temp; } parents[pv] = pu; sizes[pu] += sizes[pv]; } return new int[]{}; } int find(int target, int[] parents) { while (parents[target] != target) { //一次跳跃两个寻找当前结点的根结点 parents[target] = parents[parents[target]]; target = parents[target]; } return target; }}","link":"/2020/09/17/LeetCode/684.%20%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5/"},{"title":"LeetCode&#x2F;685. 冗余连接 II","text":"685. 冗余连接 II在本问题中，有根树指满足以下条件的有向图。该树只有一个根节点，所有其他节点都是该根节点的后继。每一个节点只有一个父节点，除了根节点没有父节点。 输入一个有向图，该图由一个有着N个节点 (节点值不重复1, 2, …, N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。 结果图是一个以边组成的二维数组。 每一个边 的元素是一对 [u, v]，用以表示有向图中连接顶点 u 和顶点 v 的边，其中 u 是 v 的一个父节点。 返回一条能删除的边，使得剩下的图是有N个节点的有根树。若有多个答案，返回最后出现在给定二维数组的答案。 示例1 ： 1234567输入: [[1,2], [1,3], [2,3]]输出: [2,3]解释: 给定的有向图如下: 1 / \\v v2--&gt;3 示例 2： 1234567输入: [[1,2], [2,3], [3,4], [4,1], [1,5]]输出: [4,1]解释: 给定的有向图如下:5 &lt;- 1 -&gt; 2 ^ | | v 4 &lt;- 3 注意: 输入的二维数组大小在 3 到 1000。 二维数组中的整数在1到N之间，其中N是输入数组的大小。 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题是在684. 冗余连接的基础上将无向图换成有向图，我们要明确题目的定义，即有根树指满足以下条件的有向图。该树只有一个根节点，所有其他节点都是该根节点的后继。每一个节点只有一个父节点，除了根节点没有父节点。所以有两种情况我们需要考虑。第一种就是就是像上一题一样虽然没有构成环，但是增加了这条边后，不能构成有向树，即不能保证每个节点只有一个父节点，对应[[1,2],[1,3],[2,3]]这种情况。第二种情况就是构成了有向图中的环，对应[[2,1],[3,1],[4,2],[1,4]]。针对上述两种问题，我们分别来讨论，第一种情况，我们遍历edges数组，如果每条edge的两个节点对应的parent[i]为0，说明这两个节点都是新节点，如果当前节点的parent[i]不为0，则说明已经有一条路径存在，加上这条边就不满足有根树的条件，所以我们将原先路径和新的路径保存，最后直接返回该边即可。对于第二种情况，这里和上一题思路一样，直接用并查集的思想去做就可以了。 具体代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Solution { public int[] findRedundantDirectedConnection(int[][] edges) { int[] parents = new int[edges.length + 1]; int[] roots = new int[edges.length + 1]; int[] sizes = new int[edges.length + 1]; Arrays.fill(sizes, 1); int[] ans1 = new int[2]; int[] ans2 = new int[2]; //第一部分用于查找每个结点的parents是谁 for (int[] edge : edges) { int u = edge[0]; int v = edge[1]; if (parents[v] &gt; 0) { ans1 = new int[]{parents[v], v}; ans2 = new int[]{edge[0], edge[1]}; edge[0] = edge[1] = -1; } parents[v] = u; } //第二部分用于查找环 for (int[] edge : edges) { int u = edge[0]; int v = edge[1]; if (u &lt; 0 || v &lt; 0) continue; if (roots[u] == 0) roots[u] = u; if (roots[v] == 0) roots[v] = v; int pu = find(u, roots); int pv = find(v, roots); if (pu == pv) { if (ans1[0] == 0 &amp;&amp; ans1[1] == 0) return edge; else return ans1; } if (sizes[pv] &gt; sizes[pu]) { int temp = pv; pv = pu; pu = temp; } roots[pv] = pu; sizes[pu] += sizes[pv]; } return ans2; } int find(int target, int[] parents) { while (parents[target] != target) { parents[target] = parents[parents[target]]; target = parents[target]; } return target; }}","link":"/2020/09/18/LeetCode/685.%20%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5%20II/"},{"title":"LeetCode&#x2F;700. 二叉搜索树中的搜索","text":"700. 二叉搜索树中的搜索给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。 例如， 1234567891011121314输入: Tree 1 Tree 2 1 2 / \\ / \\ 3 2 1 3 / \\ \\ 5 4 7 输出: 合并后的树: 3 / \\ 4 5 / \\ \\ 5 4 7 你应该返回如下子树： 123 2 / \\ 1 3 在上述示例中，如果要找的值是 5，但因为没有节点值为 5，我们应该返回 NULL。 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题根据二叉搜索树的特性，可知根节点的左孩子都小于它本身，根节点的右孩子都大于它本身，我们递归进行比较，如果能找到返回子树，如果找不到返回null 具体代码如下： 123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { TreeNode result = null; public TreeNode searchBST(TreeNode root, int val) { search(root, val); return result; } void search(TreeNode node, int target) { if (node == null) return; if (target == node.val) { result = node; return; } if (target &gt; node.val) searchBST(node.right, target); if (target &lt; node.val) searchBST(node.left, target); }} 简洁版本： 12345678class Solution { public TreeNode searchBST(TreeNode root, int val) { if (root == null || root.val == val) return root; if (root.val &gt; val) return searchBST(root.left, val); else if (root.val &lt; val) return searchBST(root.right, val); else return root; }}","link":"/2020/09/30/LeetCode/700.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2/"},{"title":"LeetCode&#x2F;701. 二叉搜索树中的插入操作","text":"701. 二叉搜索树中的插入操作给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据保证，新值和原始二叉搜索树中的任意节点值都不同。 注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果。 例如， 1234567891011121314输入: Tree 1 Tree 2 1 2 / \\ / \\ 3 2 1 3 / \\ \\ 5 4 7 输出: 合并后的树: 3 / \\ 4 5 / \\ \\ 5 4 7 你应该返回如下子树： 123 2 / \\ 1 3 或者这歌树也是有效的： 1234567 5 / \\ 2 7 / \\ 1 3 \\ 4 提示： 给定的树上的节点数介于0和10^4之间 每个节点都有一个唯一整数值，取值范围从0到 10^8 -10^8 &lt;= val &lt;= 10^8 新值和原始二叉搜索树中的任意节点值都不同 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题根据二叉搜索树的特性，将目标值和val和root.val进行比较，找到空白地方直接插入即可 具体代码如下： 123456789101112131415161718class Solution { public TreeNode insertIntoBST(TreeNode root, int val) { if (root == null) return new TreeNode(val); if (root.val &gt; val) { if (root.left == null) { root.left = new TreeNode(val); } else insertIntoBST(root.left, val); } else { if (root.right == null) { root.right = new TreeNode(val); } else { insertIntoBST(root.right, val); } } return root; }}","link":"/2020/09/30/LeetCode/701.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C/"},{"title":"LeetCode&#x2F;714. 买卖股票的最佳时机含手续费","text":"714. 买卖股票的最佳时机含手续费给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。 你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。 返回获得利润的最大值。 注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。 示例 1: 12345678输入: prices = [1, 3, 2, 8, 4, 9], fee = 2输出: 8解释: 能够达到的最大利润: 在此处买入 prices[0] = 1在此处卖出 prices[3] = 8在此处买入 prices[4] = 4在此处卖出 prices[5] = 9总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8. 注意: 0 &lt; prices.length &lt;= 50000. 0 &lt; prices[i] &lt; 50000. 0 &lt;= fee &lt; 50000. 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题和122. 买卖股票的最佳时机 II很相似，只不过是加入了手续费，手续费的扣除可以在买入阶段也可以在卖出阶段。 具体代码如下： 123456789101112131415class Solution { public int maxProfit(int[] prices, int fee) { if (prices.length == 0) return 0; int[][] T = new int[prices.length][2]; T[0][0] = 0; T[0][1] = -prices[0]; for (int i = 1; i &lt; prices.length; i++) { T[i][0] = Math.max(T[i - 1][0], T[i - 1][1] + prices[i] - fee); T[i][1] = Math.max(T[i - 1][1], T[i - 1][0] - prices[i]); } return T[prices.length - 1][0]; }} 同理，还可以优化空间复杂度。 具体代码如下： 1234567891011121314class Solution { public int maxProfit(int[] prices, int fee) { if (prices.length == 0) return 0; int notHave = 0; int have = -prices[0]; for (int i = 1; i &lt; prices.length; i++) { notHave = Math.max(notHave, have + prices[i] - fee); have = Math.max(have, notHave - prices[i]); } return notHave; }}","link":"/2020/11/04/LeetCode/714.%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9/"},{"title":"LeetCode&#x2F;763. 划分字母区间","text":"763. 划分字母区间字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一个字母只会出现在其中的一个片段。返回一个表示每个字符串片段的长度的列表。 示例 1： 123456输入：S = &quot;ababcbacadefegdehijhklij&quot;输出：[9,7,8]解释：划分结果为 &quot;ababcbaca&quot;, &quot;defegde&quot;, &quot;hijhklij&quot;。每个字母最多出现在一个片段中。像 &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; 的划分是错误的，因为划分的片段数较少。 提示： S的长度在[1, 500]之间。 S只包含小写字母 'a' 到 'z' 。 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：这里用到Map结构，所以在查找插入的时候会耗费一定的时间，官方给的解法是直接创建一个字母映射数组，可以加速处理过程。本题基本思路就是首先需要遍历字符串，将每个字母最远出现位置的索引保存起来，要保证相同字母出现在同一个片段里面，就是要让这个片段的长度大于等于该片段中字母最远出现位置的索引。取start和end两个索引，依次遍历字符串，获取当前字母出现最远位置的索引，要保证end大于该区间中每个字母的最远索引，所以取end和当前字母最远索引的较大值。当遍历的当前位置和end相等时，即可以保证从start到end这个区间内的字母仅出现在该区间内，并且可以保证该区间最短，也就是题目要求的片段尽可能多。 具体代码如下： 1234567891011121314151617181920212223242526class Solution { List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); public List&lt;Integer&gt; partitionLabels(String S) { Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); //获取每个字母出现位置最远的索引 for (int i = 0; i &lt; S.length(); i++) { map.put(S.charAt(i), i); } int start = 0; int end = 0; for (int i = 0; i &lt; S.length(); i++) { int currIndex = map.get(S.charAt(i)); //让片段包括当前出现字母的最远索引 end = Math.max(end, currIndex); //此处保证片段最短，即片段尽可能的多 if (i == end) { result.add(i - start + 1); //完成一个片段后，将start指向下一个位置开始新的片段 start = i + 1; } } return result; }}","link":"/2020/09/30/LeetCode/763.%20%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4/"},{"title":"LeetCode&#x2F;77. 组合","text":"77. 组合给定两个整数n和k，返回1 ... n中所有可能的k个数的组合。 示例 ： 12345678910输入: n = 4, k = 2输出:[ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4],] 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题一看到排列组合，就还是回溯的问题，至于怎么回溯，其实做了这么多题了，我们应该总结出一套框架了：在回溯中，首先会判断结束条件，如果满足结束条件，就将结果保存并返回；如果不满足结束条件，我们需要递归地将当前数值加入临时数组中，然后再次backtrack，只有当临时数组的长度符合要求时才会递归地返回，此时我们就会得到一个结果值；最后递归返回后将当前值去除，添加别的值进行不同的排列组合，重复以上过程，就会得到全部结果。这道题和全排列问题非常的相似，不同的是这里不是返回所有的排列值，而是返回指定长度的组合结果。这里我们可以将结束条件设置为临时数组长度等于k时就结束，然后在backtrack过程中加入一个start变量以防止数字重复。 具体代码如下： 12345678910111213141516171819202122232425262728class Solution { List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) { LinkedList&lt;Integer&gt; track = new LinkedList&lt;&gt;(); if (k &lt;= 0 || n &lt; k) { return result; } backtrack(n, k, 1, track, result); return result; } void backtrack(int n, int k, int begin, LinkedList&lt;Integer&gt; track, List&lt;List&lt;Integer&gt;&gt; result) { //触发结束条件 if (track.size() == k) { result.add(new LinkedList&lt;&gt;(track)); return; } for (int i = start; i &lt;= n; i++) { //将track中未出现的元素加入 track.add(i); backtrack(n, k, i + 1, track, result); //剔除最后一个元素，尝试下一个不同的元素 track.removeLast(); } }}","link":"/2020/09/08/LeetCode/77.%20%E7%BB%84%E5%90%88/"},{"title":"LeetCode&#x2F;785. 判断二分图","text":"785. 判断二分图给定一个无向图graph，当这个图为二分图时返回true。 如果我们能将一个图的节点集合分割成两个独立的子集A和B，并使图中的每一条边的两个节点一个来自A集合，一个来自B集合，我们就将这个图称为二分图。 graph将会以邻接表方式给出，graph[i]表示图中与节点i相连的所有节点。每个节点都是一个在0到graph.length-1之间的整数。这图中没有自环和平行边： graph[i]中不存在i，并且graph[i]中没有重复的值。 示例1 ： 123456789输入: [[1,3], [0,2], [1,3], [0,2]]输出: true解释: 无向图如下:0----1| || |3----2我们可以将节点分成两组: {0, 2} 和 {1, 3}。 示例2： 123456789输入: [[1,2,3], [0,2], [0,1,3], [0,2]]输出: false解释: 无向图如下:0----1| \\ || \\ |3----2我们不能将节点分割成两个独立的子集。 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题思想不难，但是细节要命。基本思想就是染色法，通过广度优先搜索遍历(BFS)，随机选择一个结点上色，比如说染上黑色，然后找到与该结点相连的所有邻接结点，给他们染上不同的颜色，比如说白色。这样，通过广度优先搜索遍历，如果发现某两个相邻结点染色一致，那么就不是二分图，直接返回false就好，反之，当整个图遍历完后，条件依然满足，那么就是二分图，返回true。 具体代码如下： 123456789101112131415161718192021222324252627282930313233class Solution { public boolean isBipartite(int[][] graph) { int n = graph.length; //存放数组长度 //用来存放颜色 //染色状态，0表示未染色，1表示染成黑色，2表示染成白色 int[] color = new int[n]; //初始化颜色数组 Arrays.fill(color, 0); for (int i = 0; i &lt; n; i++) { if (color[i] == 0) { //如果没有这个判断的话，会增加时间复杂度 Queue&lt;Integer&gt; list = new LinkedList&lt;&gt;(); //初始化队列 list.offer(i); //BFS理论上讲可以随机选择一个开始结点 color[i] = 1; //将初始结点染色，你可以染黑色，也可以染白色 while (!list.isEmpty()) { //下面就是标准的BFS框架了，将一个结点的所有邻接结点全部入队，然后执行相应的染色操作 int index = list.poll(); //将当前结点取出 int colorFlags = color[index] == 1 ? 2 : 1; //判断当前结点的染色情况，如果当前结点染色为黑色，那么就要给邻接结点染上白色 for (int neighbor : graph[index]) { //遍历当前结点所有的邻接结点 if (color[neighbor] == 0) { //若邻接结点没染色，那么给它们染上相反的颜色，并将邻接结点入队 color[neighbor] = colorFlags; list.offer(neighbor); } else if (color[neighbor] != colorFlags) { //到这一步就是，如果邻接结点染色了，并且和当前结点颜色一致，那么就不是二分图，直接返回false return false; } } } } } return true; }} 这里我们不妨回顾一下Java中队列的基本知识，在Java中，队列一般用LinkedList来实现，主要的API有add、offer、poll、remove、peek和element，我们来看一下这些方法的区别在哪里，直接上源码： add方法 123456789101112131415161718192021222324252627/** * Appends the specified element to the end of this list. * * &lt;p&gt;This method is equivalent to {@link #addLast}. * * @param e element to be appended to this list * @return {@code true} (as specified by {@link Collection#add}) */public boolean add(E e) { linkLast(e); return true;}/** * Links e as last element. */void linkLast(E e) { final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++;} add方法就是在队尾添加一个新的结点。 offer方法 12345678910/** * Adds the specified element as the tail (last element) of this list. * * @param e the element to add * @return {@code true} (as specified by {@link Queue#offer}) * @since 1.5 */public boolean offer(E e) { return add(e);} offer方法就是add实现的，惊不惊喜，意不意外？ poll方法 1234567891011121314151617181920212223242526272829/** * Retrieves and removes the head (first element) of this list. * * @return the head of this list, or {@code null} if this list is empty * @since 1.5 */public E poll() { final Node&lt;E&gt; f = first; return (f == null) ? null : unlinkFirst(f);}/** * Unlinks non-null first node f. */private E unlinkFirst(Node&lt;E&gt; f) { // assert f == first &amp;&amp; f != null; final E element = f.item; final Node&lt;E&gt; next = f.next; f.item = null; f.next = null; // help GC first = next; if (next == null) last = null; else next.prev = null; size--; modCount++; return element;} poll方法检索并移除队列第一个元素，如果队列为空，则返回空。 remove方法 1234567891011121314151617181920212223/** * Retrieves and removes the head (first element) of this list. * * @return the head of this list * @throws NoSuchElementException if this list is empty * @since 1.5 */public E remove() { return removeFirst();}/** * Removes and returns the first element from this list. * * @return the first element from this list * @throws NoSuchElementException if this list is empty */public E removeFirst() { final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return unlinkFirst(f);} remove方法也是返回并移除队列第一个元素，不过如果队列为空则会抛出NoSuchElementException异常。 peek方法 12345678910/** * Retrieves, but does not remove, the head (first element) of this list. * * @return the head of this list, or {@code null} if this list is empty * @since 1.5 */public E peek() { final Node&lt;E&gt; f = first; return (f == null) ? null : f.item;} peek方法，只是检索队列的第一个元素，并不会移除元素，如果队列为空，则返回null。 element方法 1234567891011121314151617181920212223/** * Retrieves, but does not remove, the head (first element) of this list. * * @return the head of this list * @throws NoSuchElementException if this list is empty * @since 1.5 */public E element() { return getFirst();}/** * Returns the first element in this list. * * @return the first element in this list * @throws NoSuchElementException if this list is empty */public E getFirst() { final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return f.item;} element方法，和peek方法一样，只不过在队列为空时会抛出NoSuchElementException异常。","link":"/2020/07/16/LeetCode/785.%20%E5%88%A4%E6%96%AD%E4%BA%8C%E5%88%86%E5%9B%BE/"},{"title":"LeetCode&#x2F;79. 单词搜索","text":"79. 单词搜索给定一个二维网格和一个单词，找出该单词是否存在于网格中。 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。 示例: 12345678910board =[ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E']]给定 word = &quot;ABCCED&quot;, 返回 true给定 word = &quot;SEE&quot;, 返回 true给定 word = &quot;ABCB&quot;, 返回 false 提示： board 和 word 中只包含大写和小写英文字母。 1 &lt;= board.length &lt;= 200 1 &lt;= board[i].length &lt;= 200 1 &lt;= word.length &lt;= 10^3 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题思想其实很简单，就是在board限制的范围内，你去上下左右进行搜索，匹配word字符串，每一行每一行的匹配，但是代码非常的绕。 具体代码如下： 1234567891011121314151617181920212223242526272829303132class Solution { public boolean exist(char[][] board, String word) { for (int i = 0; i &lt; board.length; i++) { for (int j = 0; j &lt; board[0].length; j++) { if (backtrack(board, word, i, j, 0)) { return true; } } } return false; } boolean backtrack(char[][] board, String word, int x, int y, int start) { //判断是否越界，如果越界直接返回false if (x &gt;= board.length || x &lt; 0 || y &gt;= board[0].length || y &lt; 0 || board[x][y] != word.charAt(start)) { return false; } //如果start == word.length - 1证明查找结束 if (start == word.length() - 1) { return true; } //保存当前值用于结束递归的时候复原 char temp = board[x][y]; //这里使用这样的方法就可以不用创建二维的标记数组 board[x][y] = '#'; boolean result = backtrack(board, word, x + 1, y, start + 1) || backtrack(board, word, x - 1, y, start + 1) || backtrack(board, word, x, y + 1, start + 1) || backtrack(board, word, x, y - 1, start + 1); board[x][y] = temp; return result; }}","link":"/2020/07/17/LeetCode/79.%20%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/"},{"title":"LeetCode&#x2F;842. 将数组拆分成斐波那契序列","text":"842. 将数组拆分成斐波那契序列给定一个数字字符串 S，比如 S = &quot;123456579&quot;，我们可以将它分成斐波那契式的序列 [123, 456, 579]。 形式上，斐波那契式序列是一个非负整数列表 F，且满足： 0 &lt;= F[i] &lt;= 2^31 - 1，（也就是说，每个整数都符合 32 位有符号整数类型）；F.length &gt;= 3；对于所有的0 &lt;= i &lt; F.length - 2，都有 F[i] + F[i+1] = F[i+2] 成立。另外，请注意，将字符串拆分成小块时，每个块的数字一定不要以零开头，除非这个块是数字 0 本身。 返回从 S 拆分出来的任意一组斐波那契式的序列块，如果不能拆分则返回 []。 示例1 ： 12输入：&quot;123456579&quot;输出：[123,456,579] 示例2： 12输入: &quot;11235813&quot;输出: [1,1,2,3,5,8,13] 示例3： 123输入: &quot;112358130&quot;输出: []解释: 这项任务无法完成。 示例4： 123输入：&quot;0123&quot;输出：[]解释：每个块的数字不能以零开头，因此 &quot;01&quot;，&quot;2&quot;，&quot;3&quot; 不是有效答案。 示例5： 123输入: &quot;1101111&quot;输出: [110, 1, 111]解释: 输出 [11,0,11,11] 也同样被接受。 提示： 1 &lt;= S.length &lt;= 200 字符串 S 中只含有数字。 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题其实就是贪心算法，就是不断的去尝试满足条件的组合，成功的就返回，不成功的就回到上一个状态继续下一次回溯。46. 全排列系列题目就是类似的思路。 具体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution { List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); public List&lt;Integer&gt; splitIntoFibonacci(String S) { backtrack(S, 0); return result; } boolean backtrack(String s, int index) { //index已经到字符串结尾并且result大小大于3，表示已经找到了一个满足要求的组合 if (index == s.length() &amp;&amp; result.size() &gt;= 3) { return true; } // for (int i = index; i &lt; s.length(); i++) { //这里说明两位以上的数组不能以0开头 if (s.charAt(index) == '0' &amp;&amp; i &gt; index) { break; } long num = subDigit(s, index, i + 1); //即判断该数值是否大于斐波那契序列要求，如果大于直接后面的都会比当前大，直接终止 if (num &gt; Integer.MAX_VALUE) { break; } int size = result.size(); if (size &gt;= 2 &amp;&amp; num &gt; result.get(size - 1) + result.get(size - 2)) { break; } if (size &lt;= 1 || num == result.get(size - 1) + result.get(size - 2)) { result.add((int) num); if (backtrack(s, i + 1)) { return true; } //如果不满足条件，就需要回溯，把前面添加的最后一位不满足要求的数字从result中剔除 result.remove(result.size() - 1); } } return false; } //该方法用于将字符串转换为长整形数值 long subDigit(String s, int start, int end) { long res = 0; for (int i = start; i &lt; end; i++) { res = res * 10 + s.charAt(i) - '0'; } return res; }}","link":"/2020/09/17/LeetCode/842.%20%E5%B0%86%E6%95%B0%E7%BB%84%E6%8B%86%E5%88%86%E6%88%90%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%BA%8F%E5%88%97/"},{"title":"LeetCode&#x2F;844. 比较含退格的字符串","text":"844. 比较含退格的字符串给定 S 和 T 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 # 代表退格字符。 注意：如果对空文本输入退格字符，文本继续为空。 示例1 ： 123输入：S = &quot;ab#c&quot;, T = &quot;ad#c&quot;输出：true解释：S 和 T 都会变成 “ac”。 示例 2： 123输入：S = &quot;ab##&quot;, T = &quot;c#d#&quot;输出：true解释：S 和 T 都会变成 “”。 示例 3： 123输入：S = &quot;a##c&quot;, T = &quot;#a#c&quot;输出：true解释：S 和 T 都会变成 “c”。 示例 4： 123输入：S = &quot;a#c&quot;, T = &quot;b&quot;输出：false解释：S 会变成 “c”，但 T 仍然是 “b”。 提示： 1 &lt;= S.length &lt;= 200 1 &lt;= T.length &lt;= 200 S 和 T 只含有小写字母以及字符'#'。 进阶： 你可以用 O(N) 的时间复杂度和 O(1) 的空间复杂度解决该问题吗？ 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题思路其实很好想，就是通过栈来处理。如果遇到#就弹栈，如果遇到字母就压栈，这里需要处理一个特殊情况就是字符串开头就是#，这时直接跳过即可。两个字符串相同的情况首先必须建立在处理过后的栈的大小相等，然后挨个判断每个字母是否相等，如果相等则两个字符串相同，反之不同。 123456789101112131415161718192021222324252627282930313233class Solution { public boolean backspaceCompare(String S, String T) { Deque&lt;Character&gt; stack1 = new ArrayDeque&lt;&gt;(); Deque&lt;Character&gt; stack2 = new ArrayDeque&lt;&gt;(); for (int i = 0; i &lt; S.length(); i++) { if (S.charAt(i) == '#') { if (stack1.isEmpty()) continue; stack1.pop(); } else { stack1.push(S.charAt(i)); } } for (int i = 0; i &lt; T.length(); i++) { if (T.charAt(i) == '#') { if (stack2.isEmpty()) continue; stack2.pop(); } else stack2.push(T.charAt(i)); } if (stack1.size() == stack2.size()) { while (!stack1.isEmpty()){ char a = stack1.pop(); char b = stack2.pop(); if (a != b) return false; } return true; } return false; }}","link":"/2020/09/17/LeetCode/844.%20%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"title":"LeetCode&#x2F;861. 翻转矩阵后的得分","text":"861. 翻转矩阵后的得分有一个二维矩阵 A 其中每个元素的值为 0 或 1 。 移动是指选择任一行或列，并转换该行或列中的每一个值：将所有 0 都更改为 1，将所有 1 都更改为 0。 在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的得分就是这些数字的总和。 返回尽可能高的分数。 示例： 12345输入：[[0,0,1,1],[1,0,1,0],[1,1,0,0]]输出：39解释：转换为 [[1,1,1,1],[1,0,0,1],[1,1,1,1]]0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39 提示： 1 &lt;= A.length &lt;= 20 1 &lt;= A[0].length &lt;= 20 A[i][j] 是 0 或 1 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题其实想到的了非常简单，我们要保证每一行构成的二进制数最大，并且可以翻转行和列，那么肯定要将最高位变成一，这样才能保证这个数是所有组合中最大的。然后判断每一列，需要知道每列中1的个数多还是0的个数多，如果1多就不翻转，如果0多就翻转，即取两者出现次数较大的。最后，我们不需要改变原数组就可以计算所有最大数之和，具体来说，已经将最开始的位置变为了1，那么result就是$m \\times 2 ^{n - 1}$，其中m为行数，n为列数，然后计算每一列的情况，结果为$k \\times 2^{n - i -1}$，其中k为0和1较大出现的次数，i为当前列数索引。这里需要注意一点，就是处理每一列时，需要首先判断该行第一个元素是否为1，也就是判断该行是否进行了翻转，如果翻转，情况就会是1 - A[j][i]，即相反情况。 具体代码如下： 1234567891011121314151617181920212223class Solution { public int matrixScore(int[][] A) { int m = A.length; int n = A[0].length; //假定每行首都为1 int result = m * (1 &lt;&lt; (n - 1)); for (int i = 1; i &lt; n; i++) { int count = 0; for (int j = 0; j &lt; m; j++) { //如果行首没有进行翻转，直接加上原本的数字即可 if (A[j][0] == 1) { count += A[j][i]; } else { //如果行首进行了翻转，要加上当前数字的相反数，即原先为0现在为1 count += (1 - A[j][i]); } } int k = Math.max(count, m - count); result = result + k * (1 &lt;&lt; (n - i - 1)); } return result; }}","link":"/2020/12/07/LeetCode/861.%20%E7%BF%BB%E8%BD%AC%E7%9F%A9%E9%98%B5%E5%90%8E%E7%9A%84%E5%BE%97%E5%88%86/"},{"title":"LeetCode&#x2F;860. 柠檬水找零","text":"860. 柠檬水找零在柠檬水摊上，每一杯柠檬水的售价为 5 美元。 顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。 每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。 注意，一开始你手头没有任何零钱。 如果你能给每位顾客正确找零，返回 true ，否则返回 false 。 示例 1: 1234567输入：[5,5,5,10,20]输出：true解释：前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。由于所有客户都得到了正确的找零，所以我们输出 true。 示例 2: 12输入：[5,5,10]输出：true 示例 3： 12输入：[10,10]输出：false 示例 4： 1234567输入：[5,5,10,10,20]输出：false解释：前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。由于不是每位顾客都得到了正确的找零，所以答案是 false。 提示： 120 &lt;= bills.length &lt;= 10000bills[i] 不是 5 就是 10 或是 20 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题看似简单，其实还是有很多的细节。由于只有三种面值的货币，所以我们创建两个变量five和ten，分别表示五美元钞票张数和十美元钞票张数，考虑如果第一次收到的就是大于五美元的钞票，由于没有找零的钞票，所以直接返回false。每当我们遇到十美元钞票时候，需要让十美元张数加一，同时因为需要找回五美元，所以五美元张数减一。遇到二十美元的时候，有两种找零方式，第一种是三张五美元，第二种是一张五美元，一张十美元。优先选择第二种方案，因为五美元钞票不光要找二十美元的还要找十美元的，用处较多。当没有一张十美元和一张五美元钞票时，才退而求其次，找零三张五美元钞票，这里注意，如果此时五美元钞票不足三张，直接返回false，因为此时已经无法对二十美元找零；如果遍历完整个数组，都满足条件，直接在方法最后返回true。 具体代码如下： 1234567891011121314151617181920212223242526class Solution { public boolean lemonadeChange(int[] bills) { if (bills[0] != 5) return false; int five = 0, ten = 0; for (int i = 0; i &lt; bills.length; i++) { if (bills[i] == 5) five++; if (bills[i] == 10) { five--; ten++; } if (bills[i] == 20) { if (ten &gt; 0 &amp;&amp; five &gt; 0) { ten--; five--; } else if (five &gt;= 3) { five -= 3; } else return false; } } return true; }}","link":"/2020/12/03/LeetCode/860.%20%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6/"},{"title":"LeetCode&#x2F;876. 链表的中间结点","text":"876. 链表的中间结点给定一个头结点为 head 的非空单链表，返回链表的中间结点。 如果有两个中间结点，则返回第二个中间结点。 示例1： 输入：[1,2,3,4,5] 输出：此列表中的结点 3 (序列化形式：[3,4,5]) 返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。 注意，我们返回了一个 ListNode 类型的对象 ans，这样： ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL. 示例2： 123输入：[1,2,3,4,5,6]输出：此列表中的结点 4 (序列化形式：[4,5,6])由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。 提示： 给定链表的结点数介于 1 和 100 之间。 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解： 本题就是快慢指针的应用，创建一快一慢指针，快指针一次走两步，慢指针一次走一步，当快指针走到头时，慢指针刚好到中点位置，这里要注意如果结点数目如果是偶数，那么慢指针要指向中间的第二个结点，这个我们通过while循环条件就能控制，如果为偶数结点，快指针最后会指向最后一个结点的下一个结点(即空结点)，而慢指针刚好指向中间第二个结点。 具体代码如下： 123456789101112131415161718192021/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */class Solution { public ListNode middleNode(ListNode head) { if (head == null) return null; ListNode fast = head, slow = head; while (fast != null &amp;&amp; fast.next != null) { fast = fast.next.next; slow = slow.next; } return slow; }}","link":"/2020/11/05/LeetCode/876.%20%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9/"},{"title":"LeetCode&#x2F;88. 合并两个有序数组","text":"88. 合并两个有序数组给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。 说明: 初始化 nums1 和 nums2的元素数量分别为 m 和 n 。你可以假设 nums1有足够的空间（空间大小大于或等于m + n）来保存 nums2中的元素。 示例: 12345输入:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3输出: [1,2,2,3,5,6] 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题思路就是比较数组两个元素大小，然后从后往前遍历即可。这里需要注意，如果两个数组长度不一样，那么当任意一个数组遍历完后，我们只需将另一个数组中的元素按序插入即可。 具体代码如下： 12345678910111213141516171819202122232425class Solution { public void merge(int[] nums1, int m, int[] nums2, int n) { int index = m + n - 1; m--; n--; while (m &gt;= 0 &amp;&amp; n &gt;= 0) { if (nums1[m] &gt; nums2[n]) { nums1[index--] = nums1[m--]; } else { nums1[index--] = nums2[n--]; } } //如果一个数组已经遍历完了，将另一个数组中的元素直接替换nums1之前的元素即可 if (m &gt;= 0) { while (m &gt;= 0) { nums1[index--] = nums1[m--]; } } else { while (n &gt;= 0) { nums1[index--] = nums2[n--]; } } }}","link":"/2020/09/22/LeetCode/88.%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"},{"title":"LeetCode&#x2F;921. 使括号有效的最少添加","text":"921. 使括号有效的最少添加给定一个由 '(' 和 ')' 括号组成的字符串 S，我们需要添加最少的括号（ '(' 或是 ')'，可以在任何位置），以使得到的括号字符串有效。 从形式上讲，只有满足下面几点之一，括号字符串才是有效的： 它是一个空字符串，或者它可以被写成 AB （A 与 B 连接）, 其中 A 和 B 都是有效字符串，或者它可以被写作 (A)，其中 A 是有效字符串。给定一个括号字符串，返回为使结果字符串有效而必须添加的最少括号数。 示例 1： 12输入：&quot;())&quot;输出：1 示例 2： 12输入：&quot;(((&quot;输出：3 示例 3： 12输入：&quot;()&quot;输出：0 示例 4： 12输入：&quot;()))((&quot;输出：4 提示： S.length &lt;= 1000 S 只包含 '('和')'字符。 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：由于本题只用到了左右圆括号，所以我们不需要用到栈。思路很简单，就是遇到(让变量加一，遇到)让变量减一。有一种情况就是)过多，例如()))这种情况，我们就需要另一个变量来记录插入左括号的个数，最后返回两个变量之和，就是需要的左括号数量和右括号数量之和即可。 具体代码如下： 123456789101112131415161718192021class Solution { public int minAddToMakeValid(String S) { int insertCount = 0; int needNums = 0; for (int i = 0; i &lt; S.length(); i++) { if (S.charAt(i) == '(') { needNums++; } if (S.charAt(i) == ')') { needNums--; if (needNums == -1) { needNums = 0; insertCount++; } } } return insertCount + needNums; }}","link":"/2020/09/18/LeetCode/921.%20%E4%BD%BF%E6%8B%AC%E5%8F%B7%E6%9C%89%E6%95%88%E7%9A%84%E6%9C%80%E5%B0%91%E6%B7%BB%E5%8A%A0/"},{"title":"LeetCode&#x2F;922. 按奇偶排序数组 II","text":"922. 按奇偶排序数组 II给定一个非负整数数组 A， A 中一半整数是奇数，一半整数是偶数。 对数组进行排序，以便当 A[i] 为奇数时，i 也是奇数；当 A[i] 为偶数时， i 也是偶数。 你可以返回任何满足上述条件的数组作为答案。 示例： 123输入：[4,2,5,7]输出：[4,5,2,7]解释：[4,7,2,5]，[2,5,4,7]，[2,7,4,5] 也会被接受。 提示： 2 &lt;= A.length &lt;= 20000 A.length % 2 == 0 0 &lt;= A[i] &lt;= 1000 来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 题解：本题最直观的想法就是，创建一个新数组，遍历原数组，然后将奇数放入奇数索引位置，偶数放入偶数索引位置即可。 具体代码如下： 1234567891011121314151617181920212223242526class Solution { public int[] sortArrayByParityII(int[] A) { int[] result = new int[A.length]; int index = 0; //这里可以只是用一个循环 //将所有偶数填入偶数位置 for (int temp : A) { if (temp % 2 == 0) { result[index] = temp; index += 2; } } //将所有奇数填入奇数位置 index = 1; for (int temp : A) { if (temp % 2 == 1) { result[index] = temp; index += 2; } } return result; }} 由于上述方法需要使用额外空间，我们可以在原数组上进行修改，让j指向奇数索引位置，i指向偶数索引位置，两个指针每次移动两步，如果i指向当前位置的元素是奇数，就让j向后移动，直到j指向的元素为偶数，然后交换，用i指针遍历完整个数组，就会得到结果数组。 具体代码如下： 1234567891011121314151617class Solution { public int[] sortArrayByParityII(int[] A) { int j = 1; for (int i = 0; i &lt; A.length; i += 2){ //如果i指向的是奇数，寻找j指向偶数的位置，两者进行交换 if (A[i] % 2 == 1){ while (A[j] % 2 == 1){ j += 2; } int temp = A[i]; A[i] = A[j]; A[j] = temp; } } return A; }}","link":"/2020/11/13/LeetCode/922.%20%E6%8C%89%E5%A5%87%E5%81%B6%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%20II/"},{"title":"LeetCode&#x2F;925. 长按键入","text":"925. 长按键入你的朋友正在使用键盘输入他的名字 name。偶尔，在键入字符 c 时，按键可能会被长按，而字符可能被输入 1 次或多次。 你将会检查键盘输入的字符 typed。如果它对应的可能是你的朋友的名字（其中一些字符可能被长按），那么就返回 True。 示例 1： 123输入：name = &quot;alex&quot;, typed = &quot;aaleex&quot;输出：true解释：'alex' 中的 'a' 和 'e' 被长按。 示例 2： 123输入：name = &quot;saeed&quot;, typed = &quot;ssaaedd&quot;输出：false解释：'e' 一定需要被键入两次，但在 typed 的输出中不是这样。 示例 3： 12输入：name = &quot;leelee&quot;, typed = &quot;lleeelee&quot;输出：true 示例 4： 123输入：name = &quot;laiden&quot;, typed = &quot;laiden&quot;输出：true解释：长按名字中的字符并不是必要的。 提示： name.length &lt;= 1000 typed.length &lt;= 1000 name 和 typed 的字符都是小写字母。 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题本质就是利用双指针比较两个字符串是否满足要求，但是这里面有很多特殊情况。由于题目说明的情况只是按着某个键不松手，重复输入相同的字符，所以虽然有重复，但是字符序列的顺序是不变的，简单来说就是不能出现name中压根没有的字符。我们创建两个两个指针指向了两个字符串，如果两个字符相等，那么两个指针自增，如果不相等，那么有两种情况，第一种是typed中当前字符和上一个字符相同，这种情况就是题目说明的按着某一个键不松手，这时只需要将指向typed的指针自增即可；第二种情况就是tyeped[j] != typed[j - 1]，这种情况就是出现了完全不存在name中的字符，直接返回false即可。 具体代码如下： 1234567891011121314151617181920212223242526272829303132class Solution { public boolean isLongPressedName(String name, String typed) { //如果第一个字符都不相等，那么肯定不满足条件 if (name.charAt(0) != typed.charAt(0)) return false; int i = 0, j = 0; while (i &lt; name.length() &amp;&amp; j &lt; typed.length()) { //如果两个字符相同，指针自增 if (name.charAt(i) == typed.charAt(j)) { i++; j++; } else { //如果两个字符不相同有两种情况 //1.出现了name中没有的新字符，直接返回false if (typed.charAt(j) != typed.charAt(j - 1)) return false; //2.由于长按造成重复，直接自增跳过即可 j++; } } //这里用来处理name已经遍历完，typed剩下的字符只能是name最后一个字符的重复 //和上述的一样，同样有两种情况，一种是出现新字符，一种是长按重复 while (j &lt; typed.length()) { if (typed.charAt(j) != typed.charAt(j - 1)) return false; j++; } //这里需要判断一下如果typed比name短的话， i != name.length()直接返回false return i == name.length(); }}","link":"/2020/10/21/LeetCode/925.%20%E9%95%BF%E6%8C%89%E9%94%AE%E5%85%A5/"},{"title":"LeetCode&#x2F;94. 二叉树的中序遍历","text":"94. 二叉树的中序遍历 示例: 12345678输入: [1,null,2,3] 1 \\ 2 / 3输出: [1,3,2] 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题递归方式很简单，就是标准的框架，我们来看看非递归方式 具体代码如下： 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); public List&lt;Integer&gt; inorderTraversal(TreeNode root) { inOrder(root); return result; } void inOrder(TreeNode node) { if (node == null) return; inOrder(node.left); result.add(node.val); inOrder(node.right); }} 要使用非递归方式，肯定需要用栈结构来模拟递归过程。由于中序遍历是左中右顺序，那么可以从根节点开始，一直向左遍历，边遍历边压栈，直到左子树的尽头。这时来处理，将当前节点存进结果数组(即整棵树最左端)，然后逆着向上遍历，到父节点，如果有右节点，最后遍历右节点。 1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); Deque&lt;TreeNode&gt; stack = new ArrayDeque&lt;&gt;(); public List&lt;Integer&gt; inorderTraversal(TreeNode root) { while (root != null || !stack.isEmpty()) { //一直遍历到最左端 if (root != null) { stack.push(root); root = root.left; } else { //按照左、中、右顺序依次进入结果集合 root = stack.pop(); result.add(root.val); root = root.right; } } return result; }}","link":"/2020/10/22/LeetCode/94.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"title":"LeetCode&#x2F;95. 不同的二叉搜索树 II","text":"95. 不同的二叉搜索树 II给定一个整数 n，生成所有由 1 … n 为节点所组成的 二叉搜索树 。 示例 ： 1234567891011121314151617输入：3输出：[ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3]]解释：以上的输出对应以下 5 种不同结构的二叉搜索树： 1 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\ 2 1 2 3 提示： 0 &lt;= n &lt;= 8 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：这道题目前没有想出太好的思路，就是参考官方题解。首先要明确二叉搜索树的结构，二叉搜索树就是每一个结点的左子树都小于该根结点的值，右子树都大于每个根结点的值。我们可以将输入的n分为两个集合，以每次遍历到的i结点为根结点，递归构建1~i-1的左子树，递归构建i+1~n的右子树。最后我们要遍历所有的结果，一共会有 leftTreeNodes.size()*rightTreeNodes.size()种情况，我们固定左子树，遍历右子树，将所有的可能情况都遍历完全。 具体代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class Solution { public List&lt;TreeNode&gt; generateTrees(int n) { //如果给定数为0，则返回空，否则进行递归调用 if (n == 0) { return new LinkedList&lt;TreeNode&gt;(); } return buildTrees(1, n); } public List&lt;TreeNode&gt; buildTrees(int begin, int end) { //用于存放所有树结果 List&lt;TreeNode&gt; resultNode = new LinkedList&lt;TreeNode&gt;(); //如果begin &gt; end，当前二叉树为空，即为跳出条件 if (begin &gt; end) { resultNode.add(null); return resultNode; } for (int i = begin; i &lt; end; i++) { //递归生成左子树和右子树 List&lt;TreeNode&gt; leftTreeNodes = buildTrees(begin, i - 1); List&lt;TreeNode&gt; rightTreeNodes = buildTrees(i + 1, end); //一共会有leftTreeNodes.size()*rightTreeNodes.size()种情况 //固定左子树，然后和不同的右子树搭配，将所有的情况加入resultNode中返回 for (TreeNode leftTreeNode : leftTreeNodes) { for (TreeNode rightTreeNode : rightTreeNodes) { TreeNode treeNode = new TreeNode(i); treeNode.left = leftTreeNode; treeNode.right = rightTreeNode; resultNode.add(treeNode); } } } return resultNode; }}class TreeNode { int val; TreeNode left; TreeNode right; TreeNode() { } TreeNode(int val) { this.val = val; } TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left = left; this.right = right; }}","link":"/2020/07/21/LeetCode/95.%20%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%20II/"},{"title":"LeetCode&#x2F;96. 不同的二叉搜索树","text":"96. 不同的二叉搜索树给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？ 示例 ： 12345678910输入: 3输出: 5解释:给定 n = 3, 一共有 5 种不同结构的二叉搜索树: 1 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\ 2 1 2 3 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：学过数据结构的小伙伴应该都知道，计算n个结点的二叉树的形态数，其实个数就是Catalan数，与其吭哧吭哧一步一步推导动态规划的状态转移方程，不如我们来学习一下Catlan数。 首先我们要知道什么是Catalan数，这里我引用维基百科的定义： 卡塔兰数是组合数学中一个常在各种计数问题中出现的数列。以比利时的数学家欧仁·查理·卡特兰（1814–1894）命名。历史上，清朝数学家明安图（1692年－1763年）在其《割圜密率捷法》中最先发明这种计数方式，远远早于卡塔兰[。有中国学者建议将此数命名为“明安图数”或“明安图-卡塔兰数”。 Catalan的一般项为： C_n = \\frac{1}{n+1} \\left(\\begin{matrix}2n \\\\ n \\end{matrix} \\right) = \\frac{(2n)!}{(n+1)!n!}Catalan数基于一定的实际意义。在一个n * n的方格中，从(0,0)到(n,n)的路径数，这个路径个数其实就是从2n个路径中挑出n条，所以就是$\\left(\\begin{matrix}2n \\ n \\end{matrix} \\right)$，但是Catalan还有一定的要求，就是在每次移动过程中不能越过对角线，那么我们就可以得出Catalan数的计算公式$C_n = \\left(\\begin{matrix}2n \\ n \\end{matrix} \\right)-\\left(\\begin{matrix}2n \\ n+1 \\end{matrix} \\right)$。 根据维基百科的内容可以知道，Catalan的递推关系为： C_0 = 1 \\quad and \\quad C_{n+1}=\\sum_{i=0}^nC_i C_{n-i} \\quad for \\quad n \\ge 0 \\\\ C_0 = 1 \\quad and \\quad C_{n+1}=\\frac{2(2n+1)}{n+2}C_n这个对应到我们这道题上，令f(i)为以第i个结点为根结点的二叉树的个数，那么有 Catalan(n) = f(1)+f(2)...+f(n)其中当i为根结点时，左子树有i-1个结点，右子树有n-i个结点，即$f(i)=Catalan(i-1)*Catalan(n-i)$，这样代入进去，我们就可以得到Catalan数的递推公式了。 具体代码如下： 123456789class Solution { public int numTrees(int n) { long catalan = 1; //这里需要用long,否则可能因为数组太大造成结果溢出 for (int i = 0; i &lt; n; i++) { catalan = catalan * 2 * (2 * i + 1) / (i + 2); } return (int) catalan; }} 本文参考： 维基百科 LZM的博客","link":"/2020/07/15/LeetCode/96.%20%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"},{"title":"LeetCode&#x2F;973. 最接近原点的 K 个点","text":"973. 最接近原点的 K 个点我们有一个由平面上的点组成的列表 points。需要从中找出 K 个距离原点 (0, 0) 最近的点。 （这里，平面上两点之间的距离是欧几里德距离。） 你可以按任何顺序返回答案。除了点坐标的顺序之外，答案确保是唯一的。 示例1: 1234567输入：points = [[1,3],[-2,2]], K = 1输出：[[-2,2]]解释： (1, 3) 和原点之间的距离为 sqrt(10)，(-2, 2) 和原点之间的距离为 sqrt(8)，由于 sqrt(8) &lt; sqrt(10)，(-2, 2) 离原点更近。我们只需要距离原点最近的 K = 1 个点，所以答案就是 [[-2,2]]。 示例2： 123输入：points = [[3,3],[5,-1],[-2,4]], K = 2输出：[[3,3],[-2,4]]（答案 [[-2,4],[3,3]] 也会被接受。） 提示： 1 &lt;= K &lt;= points.length &lt;= 10000 -10000 &lt; points[i][0] &lt; 10000 -10000 &lt; points[i][1] &lt; 10000 来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 题解：本题和剑指 Offer 40. 最小的k个数思路一样，最原始的想法就是直接利用API对原始数组进行排序，然后返回前K个元素。 具体代码如下： 1234567class Solution { public int[][] kClosest(int[][] points, int K) { Arrays.sort(points, (o1, o2) -&gt; (int) (Math.pow(o1[0], 2) + Math.pow(o1[1], 2) - Math.pow(o2[0], 2) - Math.pow(o2[1], 2))); return Arrays.copyOfRange(points, 0, K); }} 另一种想法就是利用大顶堆来排序，堆中始终维护数组中最小的K的元素。 具体代码如下： 12345678910111213141516171819202122232425262728class Solution { public int[][] kClosest(int[][] points, int K) { PriorityQueue&lt;int[]&gt; temp = new PriorityQueue&lt;&gt;(new Comparator&lt;int[]&gt;() { @Override public int compare(int[] o1, int[] o2) { return o2[0] - o1[0]; } }); for (int i = 0; i &lt; K; i++) { temp.add(new int[]{points[i][0] * points[i][0] + points[i][1] * points[i][1], i}); } for (int i = K; i &lt; points.length; i++) { int distance = points[i][0] * points[i][0] + points[i][1] * points[i][1]; if (distance &lt; temp.peek()[0]) { temp.poll(); temp.add(new int[]{distance, i}); } } int[][] result = new int[K][2]; for (int i = 0; i &lt; K; i++) { result[i] = points[temp.poll()[1]]; } return result; }}","link":"/2020/09/22/LeetCode/973.%20%E6%9C%80%E6%8E%A5%E8%BF%91%E5%8E%9F%E7%82%B9%E7%9A%84%20K%20%E4%B8%AA%E7%82%B9/"},{"title":"LeetCode&#x2F;946. 验证栈序列","text":"946. 验证栈序列给定 pushed 和 popped 两个序列，每个序列中的 值都不重复，只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 true；否则，返回 false 。 示例1： 12345输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]输出：true解释：我们可以按以下顺序执行：push(1), push(2), push(3), push(4), pop() -&gt; 4,push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1 示例2： 123输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]输出：false解释：1 不能在 2 之前弹出。 提示： 0 &lt;= pushed.length == popped.length &lt;= 1000 0 &lt;= pushed[i], popped[i] &lt; 1000 pushed 是 popped 的排列。 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题只讲思路，至于是用数组、栈、还是链表实现由你。遍历pushed数组，如果当前元素和popped数组当前所指元素相等，则指向pushed数组指针回退一格，指向popped数组指针前进一格，如果不等则指向pushed数组指针继续向前遍历，这里我采用栈结构实现。 具体代码如下： 1234567891011121314class Solution { public boolean validateStackSequences(int[] pushed, int[] popped) { Deque&lt;Integer&gt; stack = new ArrayDeque(); int popIndex = 0; for (int x : pushed) { stack.push(x); while (!stack.isEmpty() &amp;&amp; stack.peek() == popped[popIndex]) { stack.pop(); popIndex++; } } return stack.isEmpty(); }} 链表结构实现： 1234567891011121314class Solution { public boolean validateStackSequences(int[] pushed, int[] popped) { LinkedList&lt;Integer&gt; stack = new LinkedList&lt;&gt;(); int popIndex = 0; for (int x : pushed) { stack.push(x); while (!stack.isEmpty() &amp;&amp; stack.peek() == popped[popIndex]) { stack.pop(); popIndex++; } } return stack.isEmpty(); }} 数组结构实现： 1234567891011121314class Solution { public boolean validateStackSequences(int[] pushed, int[] popped) { int[] stack = new int[pushed.length]; int pushIndex = 0, popIndex = 0; for (int i = 0; i &lt; pushed.length; i++) { stack[pushIndex++] = pushed[i]; while (pushIndex &gt; 0 &amp;&amp; popped[popIndex] == stack[pushIndex - 1]) { pushIndex--; popIndex++; } } return pushIndex == 0; }}","link":"/2020/11/17/LeetCode/946.%20%E9%AA%8C%E8%AF%81%E6%A0%88%E5%BA%8F%E5%88%97/"},{"title":"LeetCode&#x2F;977. 有序数组的平方","text":"977. 有序数组的平方给定一个按非递减顺序排序的整数数组 A，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。 示例1: 12输入：[-4,-1,0,3,10]输出：[0,1,9,16,100] 示例2： 12输入：[-7,-3,2,3,11]输出：[4,9,9,49,121] 提示： 1 &lt;= A.length &lt;= 10000 -10000 &lt;= A[i] &lt;= 10000 A 已按非递减顺序排序。 来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 题解：本题利用双指针，一个指向头，一个指向尾，比较两数平方的大小，然后倒序插入新建的数组当中。 具体代码如下： 1234567891011121314151617class Solution { public int[] sortedSquares(int[] A) { int[] result = new int[A.length]; int index = A.length - 1; int left = 0, right = A.length - 1; while (left &lt;= right) { if (A[left] * A[left] &gt; A[right] * A[right]) { result[index--] = A[left] * A[left]; left++; } else { result[index--] = A[right] * A[right]; right--; } } return result; }}","link":"/2020/09/22/LeetCode/977.%20%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/"},{"title":"LeetCode&#x2F;941. 有效的山脉数组","text":"941. 有效的山脉数组给定一个整数数组 A，如果它是有效的山脉数组就返回 true，否则返回 false。 让我们回顾一下，如果 A 满足下述条件，那么它是一个山脉数组： A.length &gt;= 3 在 0 &lt; i &lt; A.length - 1 条件下，存在 i 使得： A[0] &lt; A[1] &lt; ... A[i-1] &lt; A[i] A[i] &gt; A[i+1] &gt; ... &gt; A[A.length - 1] 示例 1： 12输入：[2,1]输出：false 示例 2： 12输入：[3,5,5]输出：false 示例 3： 12输入：[0,3,2,1]输出：true 提示： 0 &lt;= A.length &lt;= 10000 0 &lt;= A[i] &lt;= 10000 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题没有什么特殊的，就前后两个指针，left指针向后遍历，遇到后一个比前一个大的，就继续下一个，如果后一个等于或小于前一个，就跳出循环；right指针从前往后遍历，遇到前一个大于后一个的，向前遍历，如果前一个小于或等于后一个的，直接跳出循环。最后判断left和right指针是否相等，如果不相等，直接返回false，如果相等，我们需要注意两种特殊情况，即[0,1,2,3,4,5,6,7,8,9]和[9,8,7,6,5,4,3,2,1,0]，这两种情况下，我们只需要判断left是否等于A.length - 1或者是right是否等于0即可。 具体代码如下： 123456789101112131415161718192021222324252627282930313233343536class Solution { public boolean validMountainArray(int[] A) { if (A.length &lt; 3) return false; int left = 0, right = A.length - 1; //左指针后移，判断后一个是否大于前一个 while (left &lt; A.length - 1) { if (A[left] &lt; A[left + 1]) { left++; } else { break; } } //右指针前移，判断前一个是否大于后一个 while (right &gt; 0 &amp;&amp; left != right) { if (A[right] &lt; A[right - 1]) { right--; } else { break; } } //判断两个指针是否相遇 if (left == right) { //判读两种特殊情况 if (left == A.length - 1 || right == 0) return false; else return true; } else { return false; } }}","link":"/2020/10/21/LeetCode/941.%20%E6%9C%89%E6%95%88%E7%9A%84%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84/"},{"title":"LeetCode&#x2F;98. 验证二叉搜索树","text":"98. 验证二叉搜索树给定一个二叉树，判断其是否是一个有效的二叉搜索树。 假设一个二叉搜索树具有如下特征： 节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 示例 1: 12345输入: 2 / \\ 1 3输出: true 示例 2: 123456789输入: 5 / \\ 1 4 / \\ 3 6输出: false解释: 输入为: [5,1,4,null,null,3,6]。 根节点的值为 5 ，但是其右子节点值为 4 。 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题我们依然可以利用二叉搜索树的性质来解题，二叉搜索树的中序遍历是一个升序的数组，我们可以判断相邻两个数组是否为升序关系从而判断该树是否为二叉搜索树。 具体代码如下： 12345678910111213141516171819202122class Solution { List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); public boolean isValidBST(TreeNode root) { inOrder(root); for (int i = 0; i &lt; result.size() - 1; i++) { if (result.get(i) &gt;= result.get(i + 1)) { return false; } } return true; } void inOrder(TreeNode node) { if (node == null) { return; } inOrder(node.left); result.add(node.val); inOrder(node.right); }} 当然了，这样做时间复杂度很爆炸，我们可以不用递归完成后再遍历数组判断是否合法，可以直接在递归的过程中判断。 具体代码如下： 123456789101112131415161718class Solution { long temp = Long.MIN_VALUE; public boolean isValidBST(TreeNode root) { if (root == null) { return true; } if (!isValidBST(root.left)) { return false; } if (root.val &lt;= temp) { return false; } temp = root.val; return isValidBST(root.right); }}","link":"/2020/09/13/LeetCode/98.%20%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"},{"title":"LeetCode&#x2F;986. 区间列表的交集","text":"986. 区间列表的交集给定两个由一些 闭区间 组成的列表，每个区间列表都是成对不相交的，并且已经排序。 返回这两个区间列表的交集。 （形式上，闭区间 [a, b]（其中 a &lt;= b）表示实数 x 的集合，而 a &lt;= x &lt;= b。两个闭区间的交集是一组实数，要么为空集，要么为闭区间。例如，[1, 3] 和 [2, 4] 的交集为 [2, 3]。） 示例： 12输入：A = [[0,2],[5,10],[13,23],[24,25]], B = [[1,5],[8,12],[15,24],[25,26]]输出：[[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]] 提示： 0 &lt;= A.length &lt; 1000 0 &lt;= B.length &lt; 1000 0 &lt;= A[i].start, A[i].end, B[i].start, B[i].end &lt; 10^9 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题还是区间求解题目，理论上讲应该先排序，但是题目说明给定的两个数组已经是有序的了。首先考虑两个数组的交集，因为交集情况比较多，我们可以通过取不相交集合的反得到所有相交的情况，不相交的情况只有leftB &lt; rightA || rightB &lt; leftA，然后取反就是相交的情况，即leftA &lt;= rightB &amp;&amp; rightA &gt;= leftB。根据画图观察可以发现，相交的情况中，交集满足[Math.max(leftA, leftB), Math.min(rightA, rightB)]，直接将满足条件的交集添加即可。最后考虑两个指针的移动情况，当rightB小于rightA的时候，直接将j指针向后移，反之将i指针后移，这种情况主要针对一个区间较大，包含了几个小区间的情况。 具体代码如下： 12345678910111213141516171819202122232425262728293031323334class Solution { public int[][] intervalIntersection(int[][] A, int[][] B) { List&lt;int[]&gt; list = new ArrayList&lt;&gt;(); if (A == null || B == null) return list.toArray(new int[0][]); //定义四个变量，分别记录两个区间的begin和end int leftA; int rightA; int leftB; int rightB; //定义两个指针指向不同区间 int i = 0, j = 0; while (i &lt; A.length &amp;&amp; j &lt; B.length) { leftA = A[i][0]; rightA = A[i][1]; leftB = B[j][0]; rightB = B[j][1]; //两个区间相交时将交集添加到结果数组中 if (leftA &lt;= rightB &amp;&amp; rightA &gt;= leftB) { list.add(new int[]{Math.max(leftA, leftB), Math.min(rightA, rightB)}); } //指针前移 if (rightA &gt; rightB) { j++; } else { i++; } } return list.toArray(new int[list.size()][]); }}","link":"/2020/10/07/LeetCode/986.%20%E5%8C%BA%E9%97%B4%E5%88%97%E8%A1%A8%E7%9A%84%E4%BA%A4%E9%9B%86/"},{"title":"LeetCode&#x2F;993. 二叉树的堂兄弟节点","text":"993. 二叉树的堂兄弟节点在二叉树中，根节点位于深度 0 处，每个深度为 k 的节点的子节点位于深度 k+1 处。 如果二叉树的两个节点深度相同，但父节点不同，则它们是一对堂兄弟节点。 我们给出了具有唯一值的二叉树的根节点 root，以及树中两个不同节点的值 x 和 y。 只有与值 x 和 y 对应的节点是堂兄弟节点时，才返回 true。否则，返回 false。 示例1： 输入：root = [1,2,3,4], x = 4, y = 3 输出：false 示例2: 12输入：root = [1,2,3,null,4,null,5], x = 5, y = 4输出：true 示例3: 12输入：root = [1,2,3,null,4], x = 2, y = 3输出：false 提示： 二叉树的节点数介于 2 到 100 之间。 每个节点的值都是唯一的、范围为 1 到 100 的整数。 来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 题解：本题让寻找堂兄弟结点，说的直白一点就是寻找二叉树每一层中，是否包含所给的x和y。这里需要注意的一点就是因为是堂兄弟，所以x和y不能是同一个父结点两个子结点，我们通过设置一个标记flag，如果同父则将flag置为true，最后返回即可。 具体代码如下： 123456789101112131415161718192021222324252627282930public boolean isCousins(TreeNode root, int x, int y) { Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); boolean flags = false; while (!queue.isEmpty()) { ArrayList&lt;Integer&gt; temp = new ArrayList&lt;&gt;(); int len = queue.size(); for (int i = 0; i &lt; len; i++) { TreeNode node = queue.poll(); temp.add(node.val); if (node.left != null) { queue.add(node.left); } if (node.right != null) { queue.add(node.right); } if (node.left != null &amp;&amp; node.right != null) { if ((node.left.val == x &amp;&amp; node.right.val == y) || (node.left.val == y &amp;&amp; node.right.val == x)) { flags = true; } } } if (temp.contains(x) &amp;&amp; temp.contains(y) &amp;&amp; !flags) { return true; } } return false;}","link":"/2020/09/12/LeetCode/993.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%A0%82%E5%85%84%E5%BC%9F%E8%8A%82%E7%82%B9/"},{"title":"LeetCode&#x2F;剑指 Offer 03. 数组中重复的数字","text":"剑指 Offer 03. 数组中重复的数字找出数组中重复的数字。 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。 示例1 ： 123输入：[2, 3, 1, 0, 2, 5, 3]输出：2 或 3 限制： 2 &lt;= n &lt;= 100000 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题最直接的解法就是暴力破解，这个不做过多解释，大家应该都能想到。 具体代码如下： 1234567891011class Solution { public int findRepeatNumber(int[] nums) { for (int i = 0; i &lt; nums.length; i++) { for (int j = i + 1; j &lt; nums.length; j++) { if (nums[i] == nums[j]) return nums[i]; } } return -1; }} 还有一种解法用到了Set集合的特性，遍历数组，判断数组中的每个数字是否都在Set集合中，如果存在直接返回，如果不存在则向集合中添加。 具体代码如下: 1234567891011class Solution { public int findRepeatNumber(int[] nums) { Set&lt;Integer&gt; result = new HashSet&lt;&gt;(); for (int num : nums) { if (result.contains(num)) return num; result.add(num); } return -1; }} 至于很多题解说的原地置换的方法，我觉得有些取巧，就不再赘述。","link":"/2020/08/09/LeetCode/%E5%89%91%E6%8C%87%20Offer%2003.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"},{"title":"LeetCode&#x2F;剑指 Offer 06. 从尾到头打印链表","text":"剑指 Offer 06. 从尾到头打印链表输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。 示例1 ： 12输入：head = [1,3,2]输出：[2,3,1] 限制： 10 &lt;= 链表长度 &lt;= 10000 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本来逆序我们可以想到头插法，但是题目要求用数组返回，那我们直接使用栈结构。将head所有结点值压入栈，然后将所有结点值出栈，顺序存入数组。 具体代码如下： 1234567891011121314class Solution { public int[] reversePrint(ListNode head) { LinkedList&lt;Integer&gt; result = new LinkedList&lt;&gt;(); while (head != null) { result.addFirst(head.val); head = head.next; } int[] res = new int[result.size()]; for (int i = 0; i &lt; result.size(); i++) { res[i] = result.get(i); } return res; }}","link":"/2020/08/11/LeetCode/%E5%89%91%E6%8C%87%20Offer%2006.%20%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"},{"title":"LeetCode&#x2F;剑指 Offer 04. 二维数组中的查找","text":"剑指 Offer 04. 二维数组中的查找在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 示例 ： 现有矩阵 matrix 如下： 1234567[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]] 给定 target = 5，返回 true。 给定 target = 20，返回 false。 限制： 120 &lt;= n &lt;= 10000 &lt;= m &lt;= 1000 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题最直接的解法就是暴力破解，这个不做过多解释，大家应该都能想到。 具体代码如下： 1234567891011class Solution { public boolean findNumberIn2DArray(int[][] matrix, int target) { for (int i = 0; i &lt; matrix.length; i++) { for (int j = 0; j &lt; matrix[0].length; j++) { if (matrix[i][j] == target) return true; } } return false; }} 本题由于横纵都是有序集合，所以一定有优化的空间，一看到有序的数组，我们本能地反应出要用二分查找，我们对每个小数组进行二分查找，如果找到了target则返回true，否则对下一个小数组进行二分查找，要是都没有找到，就返回false 具体代码如下: 1234567891011class Solution { public boolean findNumberIn2DArray(int[][] matrix, int target) { for (int i = 0; i &lt; matrix.length; i++) { if (Arrays.binarySearch(matrix[i], target) &gt;= 0) return true; else continue; } return false; }} 最后一种方法是借鉴官方做法，我们从二维数组的右上角判断该位置数字和target值的大小，如果该位置数字等于target则返回true；如果该位置数组小于target，我们递增到下一行同样的位置比较大小；如果该位置数字大于target，我们需要向左遍历该子数组，判断target是否存在于这个子数组中，如果存在返回true，否则返回false 具体代码如下： 123456789101112131415161718192021class Solution { public boolean findNumberIn2DArray(int[][] matrix, int target) { if (matrix.length == 0 || matrix[0].length == 0) return false; int m = matrix.length; int n = matrix[0].length; for (int i = 0; i &lt; m; i++) { if (matrix[i][n - 1] == target) { return true; } else if (matrix[i][n - 1] &lt; target) { continue; } else { for (int j = n - 1; j &gt;= 0; j--) { if (matrix[i][j] == target) return true; } } } return false; }}","link":"/2020/08/09/LeetCode/%E5%89%91%E6%8C%87%20Offer%2004.%20%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"},{"title":"LeetCode&#x2F;剑指 Offer 07. 重建二叉树","text":"剑指 Offer 07. 重建二叉树输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。 例如，给出 12前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7] 返回如下的二叉树： 3 / \\ 9 20 / \\ 15 7 限制： 10 &lt;= 节点个数 &lt;= 5000 来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 题解：本题还是构造二叉树，基本思想就是根据preorder数组确定当前根节点的值，然后在inorder中寻找当前根节点值的位置，其左边为左子树，右边为右子树。这里需要注意的就是preorder递归区间的生成，我们可以依据inorder中根节点的索引来判断，左子树就是[preLeft + 1, preLeft + leftSize]，右子树就是[preLeft + leftSize + 1, preRight]，最终返回node即可。 具体代码如下： 1234567891011121314151617181920212223242526272829class Solution { public TreeNode buildTree(int[] preorder, int[] inorder) { return build(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1); } TreeNode build(int[] preorder, int preLeft, int preRight, int[] inorder, int inLeft, int inRight) { if (preLeft &gt; preRight) return null; int rootVal = preorder[preLeft]; int index = -1; for (int i = inRight; i &gt;= inLeft; i--) { if (inorder[i] == rootVal) { index = i; break; } } //用以确定区间 int leftSize = index - inLeft; TreeNode node = new TreeNode(rootVal); node.left = build(preorder, preLeft + 1, preLeft + leftSize, inorder, inLeft, index - 1); node.right = build(preorder, preLeft + leftSize + 1, preRight, inorder, index + 1, inRight); return node; }}","link":"/2020/11/13/LeetCode/%E5%89%91%E6%8C%87%20Offer%2007.%20%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"title":"LeetCode&#x2F;剑指 Offer 10- II. 青蛙跳台阶问题","text":"剑指 Offer 10- II. 青蛙跳台阶问题一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个n 级的台阶总共有多少种跳法。 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回1。 示例1 ： 12输入：n = 2输出：2 示例2： 12输入：n = 7输出：21 示例3： 12输入：n = 0输出：1 提示： 0 &lt;= n &lt;= 100 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题思路和剑指 Offer 10- I. 斐波那契数列如出一辙，都是斐波那契数列的应用，与剑指 Offer 10- I. 斐波那契数列不同的是，本题是从斐波那契数列第三个索引上的值开始的，我们依旧利用动态规划进行计算。 具体代码如下： 123456789101112131415161718class Solution { public int numWays(int n) { if (n == 0) return 1; if (n &lt;= 2) return n; int[] dp = new int[]{0, 0, 0}; dp[0] = 1; dp[1] = 2; for (int i = 2; i &lt; n; i++) { dp[2] = (dp[0] + dp[1]) % 1000000007; dp[0] = dp[1]; dp[1] = dp[2]; } return dp[2]; }}","link":"/2020/08/28/LeetCode/%E5%89%91%E6%8C%87%20Offer%2010-%20II.%20%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/"},{"title":"LeetCode&#x2F;剑指 Offer 09. 用两个栈实现队列","text":"剑指 Offer 09. 用两个栈实现队列用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail和 deleteHead，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead操作返回 -1 ) 示例1 ： 1234输入：[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;][[],[3],[],[]]输出：[null,null,3,-1] 示例2： 1234输入：[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;][[],[],[5],[2],[],[]]输出：[null,-1,null,null,5,2] 限制： 1 &lt;= values &lt;= 10000 最多会对 appendTail、deleteHead 进行 10000 次调用 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题要求用栈实现队列，我们可以想象，把栈底看成是队列的头，那么我们每次进行压栈操作，就相当于从队尾添加元素。出队操作需要另一个栈来辅助进行，我们可以将stack1的元素依次弹出并压入stack2，这样，在stack2进行pop操作时，就可以实现出队功能，另外，如果将stack1元素全部压入stack2后stack2还为空，那么说明队列中没有元素，即返回-1。 具体代码如下： 1234567891011121314151617181920212223242526272829class CQueue { //初始化两个栈 LinkedList&lt;Integer&gt; stack1; LinkedList&lt;Integer&gt; stack2; public CQueue() { stack1 = new LinkedList&lt;&gt;(); stack2 = new LinkedList&lt;&gt;(); } //入队操作直接就将元素压入stack1即可 public void appendTail(int value) { stack1.push(value); } public int deleteHead() { //如果stack2为空，则将stack1中的元素全部压入stack2 if (stack2.isEmpty()) { while (!stack1.isEmpty()) { stack2.push(stack1.pop()); } } //将stack1中元素全部压入stack2中后，stack2依然为空则返回-1，若不为空则返回栈顶元素 if (stack2.isEmpty()) return -1; else return stack2.pop(); }}","link":"/2020/08/12/LeetCode/%E5%89%91%E6%8C%87%20Offer%2009.%20%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"},{"title":"LeetCode&#x2F;剑指 Offer 11. 旋转数组的最小数字","text":"剑指 Offer 11. 旋转数组的最小数字把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组[3,4,5,1,2]为 [1,2,3,4,5]的一个旋转，该数组的最小值为1。 示例 1: 12输入：[3,4,5,1,2]输出：1 示例 2： 12输入：[2,2,2,0,1]输出：0 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题由于官方测试用例规模小，所以最直接的想法就是遍历整个数组，把numbers[0]当做哨兵，如果后面的元素有小于numbers[0]的，返回第一个检索到的数值，如果没有，则numbers[0]就是该序列最小数，直接返回。当然用二分查找也是可以的，如果时间复杂度超了的话，我们就要考虑二分的方法。 具体实现代码如下： 12345678910class Solution { public int minArray(int[] numbers) { for (int i = 1; i &lt; numbers.length; i++) { if (numbers[i] &lt; numbers[0]) { return numbers[i]; } } return numbers[0]; }}","link":"/2020/07/22/LeetCode/%E5%89%91%E6%8C%87%20Offer%2011.%20%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"},{"title":"LeetCode&#x2F;剑指 Offer 12. 矩阵中的路径","text":"剑指 Offer 12. 矩阵中的路径请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。 [[“a”,”b”,”c”,”e”],[“s”,”f”,”c”,”s”],[“a”,”d”,”e”,”e”]] 但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。 示例1 ： 12输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCCED&quot;输出：true 示例2: 12输入：board = [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]], word = &quot;abcd&quot;输出：false 限制： 1 &lt;= board.length &lt;= 200 1 &lt;= board[i].length &lt;= 200 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题一看是在二维数组中寻找一条符合条件的路径，最先想到的就是深度优先搜索遍历。具体来说，就是从一个点开始遍历，分别向上、下、左、右发散遍历，如果找到符合条件的字符串，则返回true，否则返回false。 具体代码如下： 1234567891011121314151617181920212223242526272829class Solution { public boolean exist(char[][] board, String word) { for (int i = 0; i &lt; board.length; i++) { for (int j = 0; j &lt; board[0].length; j++) { if (board[i][j] == word.charAt(0) &amp;&amp; dfs(board, word, i, j, 0)) return true; } } return false; } private boolean dfs(char[][] board, String word, int i, int j, int start) { //边界条件，如果索引越界或者当前位置不满足条件，则返回false if (i &gt;= board.length || i &lt; 0 || j &gt;= board[0].length || j &lt; 0 || board[i][j] != word.charAt(start)) return false; //已经找到满足条件的字符串 if (start == word.length() - 1) return true; //这里可以减少创建标记数组的开销，直接在搜索之前先将当前位置置为符号，递归后再恢复 char temp = board[i][j]; board[i][j] = '$'; boolean result = dfs(board, word, i - 1, j, start + 1) || dfs(board, word, i + 1, j, start + 1) || dfs(board, word, i, j - 1, start + 1) || dfs(board, word, i, j + 1, start + 1); board[i][j] = temp; return result; }}","link":"/2020/08/09/LeetCode/%E5%89%91%E6%8C%87%20Offer%2012.%20%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/"},{"title":"LeetCode&#x2F;剑指 Offer 13. 机器人的运动范围","text":"剑指 Offer 13. 机器人的运动范围地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？ 示例 1： 12输入：m = 2, n = 3, k = 1输出：3 示例 2： 12输入：m = 3, n = 1, k = 0输出：1 提示： 1 &lt;= n,m &lt;= 100 0 &lt;= k &lt;= 20 来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 题解：一看到在矩形棋盘中的路径，首先想到DFS，因为这里只给了长和宽，没办法用特殊符号标记，所以没有办法省略visited数组。计算行坐标和列坐标的数位之和很简单，就是取模将各个位上的数字相加即可。由于采用递归地方式进行遍历，所以只需要考虑向右，向下走的情况即可，如果向上或者向左走，就会产生路径重复。我们DFS需要返回的结果就是当前位置(1)加上向右遍历和向下遍历的结果之和。 具体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738class Solution { public int movingCount(int m, int n, int k) { //创建标记数组 boolean[][] visited = new boolean[m][n]; return dfs(0, 0, m, n, k, 0, visited); } private int dfs(int i, int j, int m, int n, int k, int count, boolean[][] visited) { //如果越界，或者行和列和大于k，或者已经被访问过，那么直接返回0 if (i &gt;= m || j &gt;= n || visited[i][j] || k &lt; sum(i, j)) return 0; //将当前位置标记为已经访问过 visited[i][j] = true; //向右向下遍历 int right = dfs(i, j + 1, m, n, k, count + 1, visited); int down = dfs(i + 1, j, m, n, k, count + 1, visited); //返回结果 return right + down + 1; } //计算行坐标和列坐标的数位之和 private int sum(int m, int n) { int result = 0; while (m != 0) { result += m % 10; m /= 10; } while (n != 0) { result += n % 10; n /= 10; } return result; }}","link":"/2020/11/13/LeetCode/%E5%89%91%E6%8C%87%20Offer%2013.%20%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/"},{"title":"LeetCode&#x2F;剑指 Offer 14- I. 剪绳子","text":"剑指 Offer 14- I. 剪绳子给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n &gt; 1并且m &gt; 1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。 示例1 ： 123输入: 2输出: 1解释: 2 = 1 + 1, 1 × 1 = 1。 示例2： 123输入: 10输出: 36解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。 说明: 你可以假设 n 不小于 2 且不大于 58。 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题根据提示，需要用到动态规划，那么我们首先就需要找出状态转移方程。我们用dp数组来存储两个数的乘积，这个乘积分为两种情况，第一种情况就是，i被拆为i和i-j，那乘积就是i和i-j的乘积，另一种情况就是，拆分出j后还需要对剩下的i-j再次进行拆分，所以乘积就是j和dp[i-j]的乘积。通过以上分析我们就可以列出状态转移方程： dp[i] = Math.max(j * (i-j),j * dp[i-j])我们遍历从0到n的数，就可以得出结果。 具体代码如下： 123456789101112131415class Solution { public int integerBreak(int n) { if (n == 0) return 0; int[] dp = new int[n + 1]; for (int i = 0; i &lt;= n; i++) { int curMax = 0; for (int j = 1; j &lt; i; j++) { curMax = Math.max(curMax, Math.max(j * (i - j), j * dp[i - j])); } dp[i] = curMax; } return dp[n]; }} 本题也可以用数学方法来解决，可以知道，和一定，两个数字相差越小，乘积越大，举个例子，x + y = 10，当x = 2, y = 8时， x * y = 16，当x = 5, y = 5时，x * y = 25，所以我们取尽量接近的数字连乘，得到的结果最大。我们假设取每段相等，则乘积y有： y = (\\frac{n}{x})^x对两边取对数： lny = x \\times \\frac{n}{x}两边对x求导： y' \\times \\frac{1}{y} = ln \\frac{n}{x} + x \\times \\frac{x}{n}(- \\frac{n}{x^2}) \\\\ y' = (ln \\frac{x}{n} - 1) \\times (\\frac{n}{x})^x令$y’ = 0$，可得$x = \\frac{n}{e}$，也就是当每段取$e$时，乘积最大，但是因为要取整数，取3最合适。 具体代码如下： 123456789101112131415class Solution { public int cuttingRope(int n) { //长度为2或3只有一种情况 if (n == 2 || n == 3) return n - 1; //如果是三的倍数，直接就是三的指数 if (n % 3 == 0) { return (int) Math.pow(3, n / 3); } else if (n % 3 == 1) { //如果余1就单另出来一个长度为4的绳子 return (int) (4 * Math.pow(3, (n - 4) / 3)); } else { //n对3取模余2的情况 return (int) (2 * Math.pow(3, (n - 2) / 3)); } }}","link":"/2020/11/13/LeetCode/%E5%89%91%E6%8C%87%20Offer%2014-%20I.%20%E5%89%AA%E7%BB%B3%E5%AD%90/"},{"title":"LeetCode&#x2F;剑指 Offer 14- II. 剪绳子 II","text":"剑指 Offer 14- II. 剪绳子 II给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]...k[m - 1] 。请问 k[0]k[1]...*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。 答案需要取模1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 示例1 ： 123输入: 2输出: 1解释: 2 = 1 + 1, 1 × 1 = 1。 示例2： 123输入: 10输出: 36解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。 提示： 2 &lt;= n &lt;= 1000 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题和剑指 Offer 14- I. 剪绳子大同小异，唯一的区别就是防止越界，在每次计算时对结果取模即可。 具体代码如下： 12345678910111213class Solution { public int cuttingRope(int n) { if (n == 2 || n == 3) return n - 1; long result = 1; while (n &gt; 4) { n = n - 3; result = (result * 3) % 1000000007; } return (int) (n * result % 1000000007); }}","link":"/2020/11/13/LeetCode/%E5%89%91%E6%8C%87%20Offer%2014-%20II.%20%E5%89%AA%E7%BB%B3%E5%AD%90%20II/"},{"title":"LeetCode&#x2F;剑指 Offer 15. 二进制中1的个数","text":"剑指 Offer 15. 二进制中1的个数请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。 示例1 ： 123输入：00000000000000000000000000001011输出：3解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。 示例2： 123输入：00000000000000000000000010000000输出：1解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。 示例3： 123输入：11111111111111111111111111111101输出：31解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题可以直接调用Java的bitCount API，也可以通过移位操作计算1的个数。 具体代码如下： 1234567891011public class Solution { // you need to treat n as an unsigned value public int hammingWeight(int n) { int result = 0; while (n != 0) { result += n &amp; 1; n = n &gt;&gt;&gt; 1; } return result; }}","link":"/2020/11/13/LeetCode/%E5%89%91%E6%8C%87%20Offer%2015.%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/"},{"title":"LeetCode&#x2F;剑指 Offer 16. 数值的整数次方","text":"剑指 Offer 16. 数值的整数次方实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。 示例1： 12输入: 2.00000, 10输出: 1024.00000 示例2： 12输入: 2.10000, 3输出: 9.26100xxxxxxxxxx4 1输入: 2.10000, 32输出: 9.26100输入: intervals = [[1,4],[4,5]]3输出: [[1,5]]4解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。 示例 3: 123输入: 2.00000, -2输出: 0.25000解释: 2-2 = 1/22 = 1/4 = 0.25 说明: -100.0 &lt; x &lt; 100.0 n 是 32 位有符号整数，其数值范围是 [$-2^{31}$, $2^{31} − 1$] 。 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题可以直接使用 Java 的函数也能通过，但这明显不是我们想学习的，官方还有一种方法是迭代方法，这个方法通过找规律求解，在短时间内想到不容易，所以这里只记录递归方法。最原始的想法就是一个一个的乘起来，但是这样时间复杂度比较高，官方给出一种快速幂的思想，即 $x \\times x$，$x^2 \\times x^2$，$x^4 \\times x^4$…这样就能加速幂乘过程，但是这里要注意一个问题，就是幂指数为奇数的时候，应该怎么判断。快速幂算法给的是从后往前，每次幂指数折半，如果当前幂指数为奇数，就要在结果中再乘以一个$x$ 具体代码如下： 1234567891011121314151617181920212223class Solution { public double myPow(double x, int n) { double temp = recursion(x, n); //如果是负指数幂，需要返回结果的倒数 if (n &lt; 0) return 1 / temp; else{ return temp; } } private double recursion(double x, int n) { //递归终止条件，任何数的0次幂都是1 if (n == 0) return 1.0; //得到指数幂折半后的结果 double y = recursion(x, n / 2); if (n % 2 == 0) return y * y; else return y * y * x; }}","link":"/2020/11/13/LeetCode/%E5%89%91%E6%8C%87%20Offer%2016.%20%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/"},{"title":"LeetCode&#x2F;剑指 Offer 17. 打印从1到最大的n位数","text":"剑指 Offer 17. 打印从1到最大的n位数输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。 示例1： 12输入: n = 1输出: [1,2,3,4,5,6,7,8,9] 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题想法非常直观，就是创建一个符合要求大小的数组，然后递增的填入数据即可。 具体代码如下： 12345678910class Solution { public int[] printNumbers(int n) { int pow = (int) Math.pow(10, n); int[] result = new int[pow - 1]; for (int i = 0; i &lt; pow - 1; i++) { result[i] = i + 1; } return result; }}","link":"/2020/11/13/LeetCode/%E5%89%91%E6%8C%87%20Offer%2017.%20%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0/"},{"title":"LeetCode&#x2F;剑指 Offer 18. 删除链表的节点","text":"剑指 Offer 18. 删除链表的节点给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。 返回删除后的链表的头节点。 注意：此题对比原题有改动 示例1 ： 123输入: head = [4,5,1,9], val = 5输出: [4,1,9]解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9. 示例2: 123输入: head = [4,5,1,9], val = 1输出: [4,5,9]解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9. 说明： 题目保证链表中节点的值互不相同 若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题思想很简单，就是线性遍历整个链表，遇到与目标值相等的结点，直接删除即可。这里需要注意一种情况，就是head结点对应的值就是要删除的值，这时候我们直接返回head.next。 具体代码如下： 123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */class Solution { public ListNode deleteNode(ListNode head, int val) { ListNode pre = new ListNode(0); ListNode curr = head; pre.next = head; if (head.val == val){ return head.next; } while (curr != null) { if (curr.val == val) { pre.next = curr.next; break; } else { curr = curr.next; pre = pre.next; } } return head; }} 还有一种递归删除方法。 具体代码如下： 1234567891011121314151617181920/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */class Solution { public ListNode deleteNode(ListNode head, int val) { if (head == null) return null; if (head.val == val) { return head.next; } head.next = deleteNode(head.next, val); return head; }}","link":"/2020/11/16/LeetCode/%E5%89%91%E6%8C%87%20Offer%2018.%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/"},{"title":"LeetCode&#x2F;剑指 Offer 21. 调整数组顺序使奇数位于偶数前面","text":"剑指 Offer 21. 调整数组顺序使奇数位于偶数前面输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。 示例 ： 123输入：nums = [1,2,3,4]输出：[1,3,2,4] 注：[3,1,2,4] 也是正确的答案之一。 提示： 1 &lt;= nums.length &lt;= 50000 1 &lt;= nums[i] &lt;= 10000 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题思路比较简单，就是定义两个指针，左指针指向偶数且右指针指向奇数时两者交换即可。 具体代码如下： 1234567891011121314151617class Solution { public int[] exchange(int[] nums) { int left = 0, right = nums.length - 1; while (left &lt; right) { while (left &lt; right &amp;&amp; nums[left] % 2 == 1) { left++; } while (left &lt; right &amp;&amp; nums[right] % 2 == 0) { right--; } int temp = nums[left]; nums[left] = nums[right]; nums[right] = temp; } return nums; }}","link":"/2020/11/16/LeetCode/%E5%89%91%E6%8C%87%20Offer%2021.%20%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/"},{"title":"LeetCode&#x2F;剑指 Offer 22. 链表中倒数第k个节点","text":"剑指 Offer 22. 链表中倒数第k个节点输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。 示例 ： 123给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.返回链表 4-&gt;5. 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题我们创建两个指针，让fast指针先走k步，然后fast和slow每次走一步直到fast走到链表尾部，此时slow指向的下个元素就是目标链表的头结点。其中我们加入了dummy结点方便操作。 具体代码如下： 1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */class Solution { public ListNode getKthFromEnd(ListNode head, int k) { ListNode dummy = new ListNode(0); dummy.next = head; ListNode fast = dummy; for (int i = 0; i &lt; k; i++) { fast = fast.next; } ListNode slow = dummy; while (fast.next != null) { fast = fast.next; slow = slow.next; } return slow.next; }}","link":"/2020/11/16/LeetCode/%E5%89%91%E6%8C%87%20Offer%2022.%20%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/"},{"title":"LeetCode&#x2F;剑指 Offer 24. 反转链表","text":"剑指 Offer 24. 反转链表定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。 示例 ： 12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 限制： 10 &lt;= 节点个数 &lt;= 5000 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题最直观的想法就是修改每个节点的指向，让后一个节点的next指针指向前一个节点，但是因为让后一个节点指向前一个节点会造成链表断掉，所以我们还需要一个临时节点存储当前节点。每次将curr和pre向后移动，将当前节点用临时节点存储起来，当前节点的next指向pre，依次遍历整个链表 具体代码如下： 123456789101112131415161718192021/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */class Solution { public ListNode reverseList(ListNode head) { ListNode pre = null; ListNode curr = head; while (curr != null) { ListNode temp = curr; curr = curr.next; temp.next = pre; pre = temp; } return pre; }} 递归方法的思想就是依次递归到链表的尾部，然后依次将当前节点的head.next.next = head，然后将head.next = null即可 具体代码如下： 12345678910111213141516171819/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */class Solution { public ListNode reverseList(ListNode head) { if (head == null || head.next == null) return head; ListNode temp = reverseList(head.next); head.next.next = head; head.next = null; return temp; }}","link":"/2020/11/16/LeetCode/%E5%89%91%E6%8C%87%20Offer%2024.%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"},{"title":"LeetCode&#x2F;剑指 Offer 25. 合并两个排序的链表","text":"剑指 Offer 25. 合并两个排序的链表输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。 示例 ： 12输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 限制： 10 &lt;= 链表长度 &lt;= 1000 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题想法比较简单，就是创建一个新链表，然后遍历两个链表结点，哪个结点值小就往新链表后面接。 具体代码如下： 1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */class Solution { public ListNode mergeTwoLists(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(0); ListNode temp = dummy; while (l1 != null &amp;&amp; l2 != null) { if (l1.val &gt; l2.val) { temp.next = l2; l2 = l2.next; } else { temp.next = l1; l1 = l1.next; } temp = temp.next; } temp.next = l1 == null ? l2 : l1; return dummy.next; }} 本题还有一种递归的思路，这里给出了详细解释https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/yi-kan-jiu-hui-yi-xie-jiu-fei-xiang-jie-di-gui-by-/ 具体代码如下： 12345678910111213141516171819202122232425/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */class Solution { public ListNode mergeTwoLists(ListNode l1, ListNode l2) { if (l1 == null) return l2; else if (l2 == null) return l1; else if (l1.val &lt; l2.val) { l1.next = mergeTwoLists(l1.next, l2); return l1; } else { l2.next = mergeTwoLists(l1, l2.next); return l2; } }}","link":"/2020/11/16/LeetCode/%E5%89%91%E6%8C%87%20Offer%2025.%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/"},{"title":"LeetCode&#x2F;剑指 Offer 26. 树的子结构","text":"剑指 Offer 26. 树的子结构输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构) B是A的子结构， 即A中有出现和B相同的结构和节点值。 例如:给定的树 A： 12345 3 / \\ 4 5 / \\1 2 给定的树 B： 123 4 /1 返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。 示例 1： 12输入：A = [1,2,3], B = [3,1]输出：false 示例 2： 12输入：A = [3,4,5,1,2], B = [4,1]输出：true 限制： 0 &lt;= 节点个数 &lt;= 10000 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题思路比较简单，要判断B是否为A的子结构，有两种可能，第一种是A的根结点就是B的根结点，那么只需要递归遍历左右子树即可，第二种情况就是B的根结点不在A的根结点上，这种情况需要递归地遍历，找到B的根结点在A中的位置，然后判断。 具体代码如下： 12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public boolean isSubStructure(TreeNode A, TreeNode B) { if (A == null || B == null) return false; return isSub(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B); } private boolean isSub(TreeNode a, TreeNode b) { //如果b为空，证明B已经遍历完，即A中存在子结构B if (b == null) return true; //如果A遍历完或者两结点值不相等，那么返回false if (a == null || a.val != b.val) return false; return isSub(a.left, b.left) &amp;&amp; isSub(a.right, b.right); }}","link":"/2020/11/16/LeetCode/%E5%89%91%E6%8C%87%20Offer%2026.%20%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/"},{"title":"LeetCode&#x2F;剑指 Offer 27. 二叉树的镜像","text":"剑指 Offer 27. 二叉树的镜像请完成一个函数，输入一个二叉树，该函数输出它的镜像。 例如输入： 12345 4 / \\ 2 7 / \\ / \\1 3 6 9 镜像输出： 12345 4 / \\ 7 2 / \\ / \\9 6 3 1 示例 1： 12输入：root = [4,2,7,1,3,6,9]输出：[4,7,2,9,6,3,1] 限制： 10 &lt;= 节点个数 &lt;= 1000 来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 题解：碰到二叉树需要递归的，我们还是同样的思路。先思考一个结点应该怎么操作，然后递归进行就好了。拿根结点来说，我们要翻转二叉树，无非就是左右子结点交换，然后进行递归就好。 具体代码如下： 123456789101112131415161718192021222324/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public TreeNode invertTree(TreeNode root) { if (root == null){ return root; } TreeNode temp = root.left; root.left = root.right; root.right = temp; invertTree(root.left); invertTree(root.right); return root; }}","link":"/2020/11/16/LeetCode/%E5%89%91%E6%8C%87%20Offer%2027.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/"},{"title":"LeetCode&#x2F;剑指 Offer 28. 对称的二叉树","text":"剑指 Offer 28. 对称的二叉树给定一个二叉树，检查它是否是镜像对称的。 例如，二叉树[1,2,2,3,4,4,3]是对称的。 1 / \\ 2 2 / \\ / \\ 3 4 4 3 但是下面这个 [1,2,2,null,3,null,3]则不是镜像对称的: 1 / \\ 2 2 \\ \\ 3 3 来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 题解：具体代码如下： 123456789101112131415161718192021/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public boolean isSymmetric(TreeNode root) { if (root == null) return true; return tranverse(root.left, root.right); } public static boolean tranverse(TreeNode leftNode, TreeNode rightNode) { if (leftNode == null &amp;&amp; rightNode == null) return true; if (leftNode == null || rightNode == null || leftNode.val != rightNode.val) return false; return tranverse(leftNode.left, rightNode.right) &amp;&amp; tranverse(leftNode.right, rightNode.left); }}","link":"/2020/09/09/LeetCode/%E5%89%91%E6%8C%87%20Offer%2028.%20%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"title":"LeetCode&#x2F;剑指 Offer 30. 包含min函数的栈","text":"剑指 Offer 30. 包含min函数的栈定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。 示例： 12345678MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.min(); --&gt; 返回 -3.minStack.pop();minStack.top(); --&gt; 返回 0.minStack.min(); --&gt; 返回 -2. 提示： 各函数的调用总次数不超过 20000 次 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题可能一看到题目，有可能会想到利用PriorityQueue来解决问题，但是PriorityQueue无法同时满足返回最小和栈结构。本题可以创建一个辅助栈专门存放当前最小的元素，返回栈中最小的元素直接操作最小栈中的元素即可，其他的操作按照正常的栈来操作。用不同的集合类可能会造成时间复杂度上的差异，这里使用Deque。 具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839class MinStack { Deque&lt;Integer&gt; stack; Deque&lt;Integer&gt; minStack; public MinStack() { stack = new ArrayDeque(); //存放当前栈中最小元素的栈 minStack = new ArrayDeque(); minStack.push(Integer.MAX_VALUE); } public void push(int x) { stack.push(x); //每次push操作中minStack压入当前栈中最小的元素 minStack.push(Math.min(minStack.peek(), x)); } public void pop() { stack.pop(); minStack.pop(); } public int top() { return stack.peek(); } public int min() { return minStack.peek(); }}/** * Your MinStack object will be instantiated and called as such: * MinStack obj = new MinStack(); * obj.push(x); * obj.pop(); * int param_3 = obj.top(); * int param_4 = obj.min(); */","link":"/2020/11/17/LeetCode/%E5%89%91%E6%8C%87%20Offer%2030.%20%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/"},{"title":"LeetCode&#x2F;剑指 Offer 29. 顺时针打印矩阵","text":"剑指 Offer 29. 顺时针打印矩阵输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。 示例1： 12输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]输出：[1,2,3,6,9,8,7,4,5] 示例2： 12输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]输出：[1,2,3,4,8,12,11,10,9,5,6,7] 限制： 0 &lt;= matrix.length &lt;= 100 0 &lt;= matrix[i].length &lt;= 100 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题代码不好写，但是思路比较好想，就是一圈一圈打印，由此思路，我们可以设置两个点，即方框左上角的点和右下角的点，每打印一圈，左上角的点向右下角缩，右下角的点向左上角缩，这样循环就可以打印完所有的点。这里还需要考虑两种特殊情况，如果左上角点的行和右下角点的行相等，直接递增打印这一行即可，同理若处于同一列，递增打印这一列即可。 具体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution { int[] result; int index = 0; public int[] spiralOrder(int[][] matrix) { if (matrix.length == 0) return new int[]{}; int leftRow = 0; int leftColumn = 0; int rightRow = matrix.length - 1; int rightColumn = matrix[0].length - 1; result = new int[matrix.length * matrix[0].length]; //左上角的点向右下角缩，右下角的点向左上角缩 while (leftRow &lt;= rightRow &amp;&amp; leftColumn &lt;= rightColumn) { printEdge(matrix, leftRow++, leftColumn++, rightRow--, rightColumn--); } return result; } private void printEdge(int[][] matrix, int leftRow, int leftColumn, int rightRow, int rightColumn) { //行相等 if (leftRow == rightRow) { for (int i = leftColumn; i &lt;= rightColumn; i++) { result[index++] = matrix[leftRow][i]; } //列相等 } else if (leftColumn == rightColumn) { for (int i = leftRow; i &lt;= rightRow; i++) { result[index++] = matrix[i][leftColumn]; } } else { //按照上、右、下、左的顺序打印即可 int curColumn = leftColumn; int curRow = leftRow; while (curColumn != rightColumn) { result[index++] = matrix[leftRow][curColumn++]; } while (curRow != rightRow) { result[index++] = matrix[curRow++][rightColumn]; } while (curColumn != leftColumn) { result[index++] = matrix[rightRow][curColumn--]; } while (curRow != leftRow) { result[index++] = matrix[curRow--][leftColumn]; } } }}","link":"/2020/11/16/LeetCode/%E5%89%91%E6%8C%87%20Offer%2029.%20%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/"},{"title":"LeetCode&#x2F;剑指 Offer 31. 栈的压入、弹出序列","text":"剑指 Offer 31. 栈的压入、弹出序列输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。 示例1： 12345输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]输出：true解释：我们可以按以下顺序执行：push(1), push(2), push(3), push(4), pop() -&gt; 4,push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1 示例2： 123输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]输出：false解释：1 不能在 2 之前弹出。 提示： 0 &lt;= pushed.length == popped.length &lt;= 1000 0 &lt;= pushed[i], popped[i] &lt; 1000 pushed 是 popped 的排列。 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题只讲思路，至于是用数组、栈、还是链表实现由你。遍历pushed数组，如果当前元素和popped数组当前所指元素相等，则指向pushed数组指针回退一格，指向popped数组指针前进一格，如果不等则指向pushed数组指针继续向前遍历，这里我采用栈结构实现。 具体代码如下： 1234567891011121314class Solution { public boolean validateStackSequences(int[] pushed, int[] popped) { Deque&lt;Integer&gt; stack = new ArrayDeque(); int popIndex = 0; for (int x : pushed) { stack.push(x); while (!stack.isEmpty() &amp;&amp; stack.peek() == popped[popIndex]) { stack.pop(); popIndex++; } } return stack.isEmpty(); }} 链表结构实现： 1234567891011121314class Solution { public boolean validateStackSequences(int[] pushed, int[] popped) { LinkedList&lt;Integer&gt; stack = new LinkedList&lt;&gt;(); int popIndex = 0; for (int x : pushed) { stack.push(x); while (!stack.isEmpty() &amp;&amp; stack.peek() == popped[popIndex]) { stack.pop(); popIndex++; } } return stack.isEmpty(); }} 数组结构实现： 1234567891011121314class Solution { public boolean validateStackSequences(int[] pushed, int[] popped) { int[] stack = new int[pushed.length]; int pushIndex = 0, popIndex = 0; for (int i = 0; i &lt; pushed.length; i++) { stack[pushIndex++] = pushed[i]; while (pushIndex &gt; 0 &amp;&amp; popped[popIndex] == stack[pushIndex - 1]) { pushIndex--; popIndex++; } } return pushIndex == 0; }}","link":"/2020/11/17/LeetCode/%E5%89%91%E6%8C%87%20Offer%2031.%20%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/"},{"title":"LeetCode&#x2F;剑指 Offer 32 - I. 从上到下打印二叉树","text":"剑指 Offer 32 - I. 从上到下打印二叉树从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。 例如:给定二叉树: [3,9,20,null,null,15,7], 12345 3 / \\9 20 / \\ 15 7 返回： 1[3,9,20,15,7] 提示： 节点总数 &lt;= 1000 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题很直接，就是广度优先搜索遍历，直接套用框架即可。 123456789101112131415161718192021222324public class Solution { public int[] levelOrder(TreeNode root) { if (root == null) return new int[]{}; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while (!queue.isEmpty()) { TreeNode temp = queue.poll(); result.add(temp.val); if (temp.left != null) queue.add(temp.left); if (temp.right != null) queue.add(temp.right); } int[] temp = new int[result.size()]; for (int i = 0; i &lt; result.size(); i++) { temp[i] = result.get(i); } return temp; }}","link":"/2020/11/17/LeetCode/%E5%89%91%E6%8C%87%20Offer%2032%20-%20I.%20%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"title":"LeetCode&#x2F;剑指 Offer 32 - II. 从上到下打印二叉树 II","text":"剑指 Offer 32 - II. 从上到下打印二叉树 II从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。 例如:给定二叉树: [3,9,20,null,null,15,7], 12345 3 / \\9 20 / \\ 15 7 返回其层次遍历结果： 12345[ [3], [9,20], [15,7]] 提示： 节点总数 &lt;= 1000 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题很直接，就是广度优先搜索遍历，直接套用框架即可，当然也可以用深度优先搜索遍历来解决。 具体代码如下： 123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) { if (root == null) return new ArrayList&lt;&gt;(); List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while (!queue.isEmpty()) { int len = queue.size(); List&lt;Integer&gt; ele = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; len; i++) { TreeNode temp = queue.poll(); ele.add(temp.val); if (temp.left != null) queue.add(temp.left); if (temp.right != null) queue.add(temp.right); } result.add(ele); } return result; }}","link":"/2020/11/17/LeetCode/%E5%89%91%E6%8C%87%20Offer%2032%20-%20II.%20%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%20II/"},{"title":"LeetCode&#x2F;剑指 Offer 32 - III. 从上到下打印二叉树 III","text":"剑指 Offer 32 - III. 从上到下打印二叉树 III请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。 例如:给定二叉树: [3,9,20,null,null,15,7], 12345 3 / \\9 20 / \\ 15 7 返回其层次遍历结果： 12345[ [3], [20,9], [15,7]] 提示： 节点总数 &lt;= 1000 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题还是基于层序遍历的框架，题目所说的锯齿遍历，就是一行是正序，一行是反序，这种情况设置一个count变量，来隔行判断本行应该正序还是反序存储。 具体代码如下： 12345678910111213141516171819202122232425262728293031323334class Solution { public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) { List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;(); if (root == null) { return result; } Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); int count = 0; while (!queue.isEmpty()) { LinkedList&lt;Integer&gt; temp = new LinkedList&lt;&gt;(); int len = queue.size(); for (int i = 0; i &lt; len; i++) { TreeNode node = queue.poll(); if (count % 2 != 0) { //头插元素，即逆序 temp.add(0, node.val); } else { temp.add(node.val); } if (node.left != null) { queue.add(node.left); } if (node.right != null) { queue.add(node.right); } } count++; result.add(temp); } return result; }}","link":"/2020/11/17/LeetCode/%E5%89%91%E6%8C%87%20Offer%2032%20-%20III.%20%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%20III/"},{"title":"LeetCode&#x2F;剑指 Offer 33. 二叉搜索树的后序遍历序列","text":"剑指 Offer 33. 二叉搜索树的后序遍历序列输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。 参考以下这颗二叉搜索树： 12345 5 / \\ 2 6 / \\1 3 示例1: l12输入: [1,6,3,2,5]输出: false 示例2: 12输入: [1,3,2,6,5]输出: true 提示： 数组长度 &lt;= 1000 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题我们可以从构建二叉树的角度出发，想想利用中序和后序遍历构建二叉树的过程。此题可以类比该过程，后序遍历数组最后一个元素是该二叉树的根结点，第一个大于根结点的数值，到根结点前一个数值是该二叉搜索树的右子树，第一个大于根结点数值的前面就是该树的左子树。我们只需要判断在右子树中有没有小于根结点的数值，如果有则不满足二叉搜索树的条件(这里只判断右子树是因为我们在寻找第一个大于根结点数值的时候，无形之中已经判断了所有前面的数值小于根结点)。递归遍历所有子树即可判断出该树是不是二叉搜索树。 具体代码如下： 1234567891011121314151617181920212223242526272829class Solution { public boolean verifyPostorder(int[] postorder) { return postOder(postorder, 0, postorder.length - 1); } private boolean postOder(int[] postorder, int begin, int end) { //begin大于end说明该子区间所有数均满足要求 if (begin &gt;= end) return true; int mid = begin; //寻找第一个大于根结点的数值 while (postorder[mid] &lt; postorder[end]) { mid++; } int pointer2 = mid; //判断右子区间中是否有数值小于根结点数值 while (pointer2 &lt; end) { if (postorder[pointer2] &lt; postorder[end]) { return false; } pointer2++; } //递归判断左子树和右子树是否满足条件 return postOder(postorder, begin, mid - 1) &amp;&amp; postOder(postorder, mid, end - 1); }}","link":"/2020/11/17/LeetCode/%E5%89%91%E6%8C%87%20Offer%2033.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/"},{"title":"LeetCode&#x2F;剑指 Offer 35. 复杂链表的复制","text":"剑指 Offer 35. 复杂链表的复制请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。 示例1： 12输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]输出：[[7,null],[13,0],[11,4],[10,2],[1,0]] 示例2： 12输入：head = [[1,1],[2,1]]输出：[[1,1],[2,1]] 示例3： 12输入：head = [[3,null],[3,0],[3,null]]输出：[[3,null],[3,0],[3,null]] 示例4： 123输入：head = []输出：[]解释：给定的链表为空（空指针），因此返回 null。 提示： -10000 &lt;= Node.val &lt;= 10000 Node.random 为空（null）或指向链表中的节点。 节点数目不超过 1000 。 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题解法五花八门，我在这里提供一种思路最简单的方法，就是利用HashMap。我们首先遍历一次链表，将每个结点复制一个相同的新结点并存入HashMap中，其中Key为原结点，Value为原结点的复制结点，第一遍遍历不用管每个结点的next和random指针。第二遍遍历链表，我们要利用每个原结点的next和random指针信息来完善新的复制链表，其中，新结点的next指向的就是原始结点next指向的结点对应的复制结点，即map.get(p).next = map.get(p.next);，新结点的random指向的就是原始结点的random所对应的复制结点，即map.get(p).random = map.get(p.random);最后我们返回HashMap中head对应的Value，即新的复制链表的头结点。 具体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041/*// Definition for a Node.class Node { int val; Node next; Node random; public Node(int val) { this.val = val; this.next = null; this.random = null; }}*/class Solution { public Node copyRandomList(Node head) { if (head == null) return head; Node p = head; //创建HashMap用来存放原始链表和新链表的对应关系 Map&lt;Node, Node&gt; map = new HashMap&lt;&gt;(); while (p != null) { Node temp = new Node(p.val); //将每个原始结点拷贝一份，其中原始结点作为Key，复制结点作为Value map.put(p, temp); p = p.next; } p = head; while (p != null) { //新结点的next就是原结点next指向的结点的复制结点 map.get(p).next = map.get(p.next); //新结点的random结点就是原始结点random指向的结点的复制结点 map.get(p).random = map.get(p.random); p = p.next; } //返回新链表的头结点即可 return map.get(head); }}","link":"/2020/11/23/LeetCode/%E5%89%91%E6%8C%87%20Offer%2035.%20%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/"},{"title":"LeetCode&#x2F;剑指 Offer 34. 二叉树中和为某一值的路径","text":"剑指 Offer 34. 二叉树中和为某一值的路径输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。 示例:给定如下二叉树，以及目标和sum = 22， 1234567 5 / \\ 4 8 / / \\ 11 13 4 / \\ \\7 2 1 返回： 1234[ [5,4,11,2], [5,8,4,5]] 提示： 节点总数 &lt;= 10000 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题思想就是深度优先搜索遍历，只不过在遍历的时候需要判断当前路径上的结点数值之和是否等于sum。 具体代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { //存放结果 List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) { //临时链表，用来存放满足条件的一条路径 LinkedList&lt;Integer&gt; temp = new LinkedList&lt;&gt;(); dfs(root, sum, temp); return result; } void dfs(TreeNode node, int sum, LinkedList&lt;Integer&gt; temp) { //当结点为空时返回 if (node == null) return; //如果不为空，将当前结点的值添加到临时链表中，同时sum减去当前结点的值 temp.add(node.val); sum = sum - node.val; //如果当前结点时叶子结点且该路径数值之和等于sum，那么将该条满足条件的路径添加到result数组中 if (node.left == null &amp;&amp; node.right == null &amp;&amp; sum == 0) { result.add(new LinkedList&lt;&gt;(temp)); temp.pollLast(); return; } //递归遍历左右子树 dfs(node.left, sum, temp); dfs(node.right, sum, temp); //最后需要将当前结点弹出以进行下条路径的遍历 temp.pollLast(); }}","link":"/2020/11/23/LeetCode/%E5%89%91%E6%8C%87%20Offer%2034.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/"},{"title":"LeetCode&#x2F;剑指 Offer 36. 二叉搜索树与双向链表","text":"剑指 Offer 36. 二叉搜索树与双向链表输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。 为了让您更好地理解问题，以下面的二叉搜索树为例： 我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。 下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。 特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题要将二叉搜索树变成一个有序的循环双向链表，一提到二叉搜索的有序，一般都是中序遍历，中序遍历可以使二叉搜索树升序排列。然后只需要在每次中序遍历过程中将当前结点的前驱和后继结点相连即可。最后根据题目要求，最后一个结点的后继是头结点，头结点的前驱是最后一个结点，即首位相连。 具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/*// Definition for a Node.class Node { public int val; public Node left; public Node right; public Node() {} public Node(int _val) { val = _val; } public Node(int _val,Node _left,Node _right) { val = _val; left = _left; right = _right; }};*/class Solution { Node pre = null, head = null; public Node treeToDoublyList(Node root) { if (root == null) return root; inOrder(root); head.left = pre; pre.right = head; return head; } private void inOrder(Node curr) { if (curr == null) return; inOrder(curr.left); //如果pre指向为空，即当前结点为头结点，直接让curr指向头结点即可 //如果不为空，则让pre的后继指向当前结点即可 if (pre == null) { head = curr; } else { pre.right = curr; } //curr的前驱为pre，同时pre前移 curr.left = pre; pre = curr; inOrder(curr.right); }}","link":"/2020/11/23/LeetCode/%E5%89%91%E6%8C%87%20Offer%2036.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"},{"title":"LeetCode&#x2F;剑指 Offer 38. 字符串的排列","text":"剑指 Offer 38. 字符串的排列输入一个字符串，打印出该字符串中字符的所有排列。 你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。 示例： 12输入：s = &quot;abc&quot;输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;] 限制： 11 &lt;= s 的长度 &lt;= 8 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题的难点并不在于如何求出全排列，而在于满足题目条条框框的返回值，本题解法可能不是最优的，但我感觉是比较好理解的。由于给定字符串会出现重复字符，所以我们需要使用Set对结果数组进行去重，利用visited数组可以进行剪枝操作。我们递归添加每个字符，当长度为s的长度时，证明完成了一个排列，直接添加到结果数组即可，如果不满足，递归地调用下一层，递归前后，需要用visited标记当前位置已经被访问。 具体代码如下： 12345678910111213141516171819202122232425262728class Solution { Set&lt;String&gt; result = new HashSet&lt;&gt;(); public String[] permutation(String s) { if (s.length() == 0) return new String[]{}; boolean[] visited = new boolean[s.length()]; backtrack(s, \"\", visited); return result.toArray(new String[result.size()]); } private void backtrack(String s, String temp, boolean[] visited) { if (temp.length() == s.length()) { result.add(temp); return; } for (int i = 0; i &lt; s.length(); i++) { if (visited[i]) continue; visited[i] = true; backtrack(s, temp + s.charAt(i), visited); visited[i] = false; } }}","link":"/2020/11/23/LeetCode/%E5%89%91%E6%8C%87%20Offer%2038.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/"},{"title":"LeetCode&#x2F;剑指 Offer 39. 数组中出现次数超过一半的数字","text":"剑指 Offer 39. 数组中出现次数超过一半的数字数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。 你可以假设数组是非空的，并且给定的数组总是存在多数元素。 示例： 12输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]输出: 2 限制： 11 &lt;= 数组长度 &lt;= 50000 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题利用HashMap和经过排序后返回的中位数就是众数其实都比较好像，这个摩尔投票法真的秀的人头皮发麻，这里依次记录三种解法。 具体代码如下： 利用HashMap： 12345678910111213141516171819202122class Solution { public int majorityElement(int[] nums) { int num = nums.length / 2; int result = 0; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); //先遍历一边数组，将元素作为Key，元素出现次数作为Value for (int i = 0; i &lt; nums.length; i++) { map.put(nums[i], map.getOrDefault(nums[i], 0) + 1); } //题目说明只有一个数出现次数大于数组长度一半，找到直接返回即可 Set&lt;Map.Entry&lt;Integer, Integer&gt;&gt; entries = map.entrySet(); for (Map.Entry&lt;Integer, Integer&gt; entry : entries) { if (entry.getValue() &gt; num) { result = entry.getKey(); break; } } return result; }} 利用排序后中位数即是众树： 123456class Solution { public int majorityElement(int[] nums) { Arrays.sort(nums); return nums[nums.length / 2]; }} 利用摩尔投票法： 摩尔投票法有两个推论 若记 众数 的票数为 +1 ，非众数 的票数为 -1 ，则一定有所有数字的 票数和 &gt;0 若数组的前 $a$ 个数字的 票数和 =0 ，则 数组剩余 $(n-a)$ 个数字的 票数和一定仍 &gt;0 ，即后 $(n-a)$ 个数字的 众数仍为 $x$。 所以，我们可以从第一个元素开始，假定第一个元素就是众数，我们每次遇到这个元素就+1​，其他元素就-1，如果votes==0，利用推论可以弃掉前面的元素，重新以当前元素开始，假定当前元素为众数继续向后遍历，最后返回x即是该数组众数。 12345678910class Solution { public int majorityElement(int[] nums) { int x = 0, votes = 0; for (int num : nums) { if (votes == 0) x = num; votes += num == x ? 1 : -1; } return x; }}","link":"/2020/11/23/LeetCode/%E5%89%91%E6%8C%87%20Offer%2039.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/"},{"title":"LeetCode&#x2F;剑指 Offer 40. 最小的k个数","text":"剑指 Offer 40. 最小的k个数输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。 示例1 ： 12输入：arr = [3,2,1], k = 2输出：[1,2] 或者 [2,1] 示例2: 12输入：arr = [0,1,2,1], k = 1输出：[0] 限制： 0 &lt;= k &lt;= arr.length &lt;= 10000 0 &lt;= arr[i] &lt;= 10000 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题提供两种解法，要取出最小的k个数，先对数组进行排序，然后返回前k个数即可。 具体代码如下： 12345678910class Solution { public int[] getLeastNumbers(int[] arr, int k) { Arrays.sort(arr); int[] result = new int[k]; for (int i = 0; i &lt; k; i++) { result[i] = arr[i]; } return result; }} 另一种方法就是利用大顶堆，先将数组中的k个数入堆，然后遍历数组中后面的数，如果当前数值小于堆顶元素，直接将堆顶元素弹出，然后将当前数压入堆，这样，堆中始终维护的是数组中最小的k个数，最后直接返回即可。 具体代码如下： 123456789101112131415161718192021222324class Solution { public int[] getLeastNumbers(int[] arr, int k) { int[] result = new int[k]; if (k == 0) return result; PriorityQueue&lt;Integer&gt; priorityQueue = new PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1); for (int i = 0; i &lt; k; i++) { priorityQueue.add(arr[i]); } for (int i = k; i &lt; arr.length; i++) { if (arr[i] &lt; priorityQueue.peek()) { priorityQueue.poll(); priorityQueue.add(arr[i]); } } for (int i = 0; i &lt; k; i++) { result[i] = priorityQueue.poll(); } return result; }}","link":"/2020/08/09/LeetCode/%E5%89%91%E6%8C%87%20Offer%2040.%20%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/"},{"title":"LeetCode&#x2F;剑指 Offer 42. 连续子数组的最大和","text":"剑指 Offer 42. 连续子数组的最大和输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。 要求时间复杂度为O(n)。 示例： 123输入: nums = [-2,1,-3,4,-1,2,1,-5,4]输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 提示： 1 &lt;= arr.length &lt;= 10^5 -100 &lt;= arr[i] &lt;= 100 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题由于要求局部的连续子数组的最大和，可以立马想到动态规划的方式来解题。因为只需要返回值，我们可以直接在原数组上进行操作，具体来说，如果当前元素的前一个元素小于零，那么加上一个负数势必不能保证当前和最大，所以如果出现这种情况直接跳过；如果当前元素的前一个元素大于零，那么就让当前元素加上前一个位置的值，将新值赋给当前位置。同时创建一个整型变量用来记录当前的连续子数组的最大和，最后返回该变量即可。 具体代码如下： 1234567891011121314151617class Solution { public int maxSubArray(int[] nums) { if (nums.length == 1) return nums[0]; int result = nums[0]; for (int i = 1; i &lt; nums.length; i++) { if (nums[i - 1] &gt; 0) { nums[i] += nums[i - 1]; result = Math.max(result, nums[i]); }else { result = Math.max(result, nums[i]); } } return result; }}","link":"/2020/11/23/LeetCode/%E5%89%91%E6%8C%87%20Offer%2042.%20%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/"},{"title":"LeetCode&#x2F;剑指 Offer 44. 数字序列中某一位的数字","text":"剑指 Offer 44. 数字序列中某一位的数字数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。 请写一个函数，求任意第n位对应的数字。 示例1： 12输入：n = 3输出：3 示例2： 12输入：n = 11输出：0 限制： 0 &lt;= n &lt; 2^31 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题要是面试的话临场还真不一定能找出规律，不过鉴于本题规律还算比较简单，可以参考训练自己的思维。通过找规律可以发现，数值为一位的数字一共有9个(1～9)，数值为二位的数字一共有180个(从10～99)，以此类推，最终可以发现规律即为起始位 * 位数 * 9，通过该规律，首先可以判断出n是几位数，从而定位到一个区间内。然后通过起始的位置可以计算出n位数对应的数字是多少，最后可以通过计算定位n对应该数字中的第几位，就可以得到结果。 具体代码如下： 1234567891011121314151617181920class Solution { public int findNthDigit(int n) { int start = 1; long digit = 1; long count = 9; while (n &gt; count) { n -= count; digit++; start *= 10; count = 9 * digit * start; } //定位n所指向的数字是多少 long num = start + (n - 1) / digit; //定位n所指向的数字是第几位 long reminder = (n - 1) % digit; return Long.toString(num).charAt((int)reminder) - '0'; }}","link":"/2020/11/23/LeetCode/%E5%89%91%E6%8C%87%20Offer%2044.%20%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9F%90%E4%B8%80%E4%BD%8D%E7%9A%84%E6%95%B0%E5%AD%97/"},{"title":"LeetCode&#x2F;剑指 Offer 45. 把数组排成最小的数","text":"剑指 Offer 45. 把数组排成最小的数输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。 示例1： 12输入: [10,2]输出: &quot;102&quot; 示例2： 12输入: [3,30,34,5,9]输出: &quot;3033459&quot; 提示: 0 &lt; nums.length &lt;= 100说明: 输出结果可能非常大，所以你需要返回一个字符串而不是整数 拼接起来的数字可能会有前导 0，最后结果不需要去掉前导 0 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题应该可以直接想到要排序，但是简单的升序排序会出现问题，比如[3,30]，如果单纯按照升序排序，得到的字符串是&quot;330&quot;，很显然有一个&quot;303&quot;比它更小。所以在排序中，需要将两个字符串拼接起来比较大小，即在每次遍历的过程中，需要比较&quot;330&quot;和&quot;303&quot;的大小，这样就不会出现上述问题。具体来说，先将所有的int类型数字转换为String类型，然后对String数组按照拼接后大小进行排序，最后组装字符串即可。 具体代码如下： 1234567891011121314class Solution { public String minNumber(int[] nums) { List&lt;String&gt; temp = new ArrayList&lt;&gt;(); for (int num : nums) { temp.add(String.valueOf(num)); } temp.sort((o1, o2) -&gt; (o1 + o2).compareTo(o2 + o1)); StringBuilder result = new StringBuilder(); for (String s : temp) { result.append(s); } return result.toString(); }}","link":"/2020/11/23/LeetCode/%E5%89%91%E6%8C%87%20Offer%2045.%20%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/"},{"title":"LeetCode&#x2F;剑指 Offer 46. 把数字翻译成字符串","text":"剑指 Offer 46. 把数字翻译成字符串给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。 示例1： 123输入: 12258输出: 5解释: 12258有5种不同的翻译，分别是&quot;bccfi&quot;, &quot;bwfi&quot;, &quot;bczi&quot;, &quot;mcfi&quot;和&quot;mzi&quot; 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：由于一共二十六个字母，所以最大可翻译的字母就是a~z，最大可翻译位数为两位，所以最多需要考虑的就是两位，也就是说，我们当前位置能翻译的字符串个数，最多只和前两个位置的数有关系。由这点，就可以想到动态规划的方法，一共有两种情况，当前数字自己可以翻译成一种字母；以及当前数字和前一个数字组合起来可以翻译成一种字母，就是说，当前位置能翻译字母的组合个数为两种情况之和。需要注意的是，一共只有二十六个字母，所以数字能翻译的范围是0~25，超过这个范围将不能被视为是一种翻译。 具体代码如下： 1234567891011121314151617181920212223class Solution { public int translateNum(int num) { String n = String.valueOf(num); int[] dp = new int[n.length()]; dp[0] = 1; for (int i = 1; i &lt; n.length(); i++) { int temp = (n.charAt(i - 1) - '0') * 10 + (n.charAt(i) - '0'); if (temp &gt;= 10 &amp;&amp; temp &lt;= 25) { if (i == 1) //开始特殊值处理 dp[i] = 2; else dp[i] = dp[i - 1] + dp[i - 2]; } else { dp[i] = dp[i - 1]; } } return dp[n.length() - 1]; }} 因为当前位置只和前两个位置有关，所以可以压缩空间。 具体代码如下： 1234567891011121314151617181920class Solution { public int translateNum(int num) { String n = String.valueOf(num); int curr = 1; int pre = 1; for (int i = 2; i &lt;= n.length(); i++) { int temp = (n.charAt(i - 2) - '0') * 10 + (n.charAt(i - 1) - '0'); if (temp &gt;= 10 &amp;&amp; temp &lt;= 25) { int t = curr; curr += pre; pre = t; } else { pre = curr; } } return curr; }} 还有大佬想出了递归的方法，具体来说，因为最多只和两位数字有关，我们可以一次递归两个分支，一个分支只考虑一个位置的情况，另一个分支考虑两个位置的情况。 具体代码如下： 1234567891011121314class Solution { public int translateNum(int num) { //结束条件 if (num &lt; 10) return 1; //取出两位数字，如果在翻译范围内，分别递归一位和两位的情况，如果不在只需要递归一位 int temp = num % 100; if (temp &lt; 10 || temp &gt; 25) return translateNum(num / 10); else return translateNum(num / 10) + translateNum(num / 100); }}","link":"/2020/12/01/LeetCode/%E5%89%91%E6%8C%87%20Offer%2046.%20%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"title":"LeetCode&#x2F;剑指 Offer 47. 礼物的最大价值","text":"剑指 Offer 47. 礼物的最大价值在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？ 示例1： 12345678输入: [ [1,3,1], [1,5,1], [4,2,1]]输出: 12解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物 提示： 0 &lt; grid.length &lt;= 200 0 &lt; grid[0].length &lt;= 200 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题有两种解法，一种是动态规划，一种是深度优先搜索遍历。对于动态规划，在当前位置的最大值，取决于该位置的上边和右边的值中较大的值，加上当前位置上的值。这里需要注意的是，我们应该先初始化第一行和第一列，每一行当前位置的最大值仅取决于该位置左边相邻的值，每一列当前位置的最大值仅取决于该位置上边相邻的值，然后向右下角进行搜索即可，最后最大值就是右下角的值。 具体代码如下： 1234567891011121314151617class Solution { public int maxValue(int[][] grid) { for (int i = 1; i &lt; grid.length; i++) { grid[i][0] += grid[i - 1][0]; } for (int i = 1; i &lt; grid[0].length; i++) { grid[0][i] += grid[0][i - 1]; } for (int i = 1; i &lt; grid.length; i++) { for (int j = 1; j &lt; grid[0].length; j++) { grid[i][j] += Math.max(grid[i - 1][j], grid[i][j - 1]); } } return grid[grid.length - 1][grid[0].length - 1]; }} 如果用常规的深度优先搜索遍历会超时，所以需要一个记忆数组用于存放之前已经遍历过的位置，具体做法就是先递归到最右下角，然后往(0,0)方向开始递归返回值(DFS和动态规划正好是相反的过程)，最后返回起点值即为所求值。 具体代码如下： 12345678910111213141516171819202122232425262728class Solution { int[][] memo; public int maxValue(int[][] grid) { memo = new int[grid.length][grid[0].length]; return dfs(grid, 0, 0); } private int dfs(int[][] grid, int row, int column) { if (memo[row][column] &gt; 0) { return memo[row][column]; } int rightVal = grid[row][column], downVal = grid[row][column]; //如果没到最右边一直向右递归 if (column + 1 &lt; grid[0].length) rightVal += +dfs(grid, row, column + 1); //如果没到最下边一直向下递归 if (row + 1 &lt; grid.length) downVal += dfs(grid, row + 1, column); //存储当前位置的较大值 memo[row][column] = Math.max(rightVal, downVal); return memo[row][column]; }}","link":"/2020/12/03/LeetCode/%E5%89%91%E6%8C%87%20Offer%2047.%20%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/"},{"title":"LeetCode&#x2F;剑指 Offer 48. 最长不含重复字符的子字符串","text":"剑指 Offer 48. 最长不含重复字符的子字符串请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。 示例 1: 123输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例 2: 123输入: &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 示例 3: 1234输入: &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 提示： s.length &lt;= 40000 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题其实就是滑动窗口，但是每一步需要将当前字母存储在HashMap中，其中Key为当前字母，Value为当前字母的索引+1（这里加一是为了定位到重复字母的下一个位置），然后就是快指针不断后移，如果出现原先出现过的字母，就将慢指针移到最后一次出现重复字母位置的下一位，每次获取相对较大值，每次将当前字母索引加入HashMap中。 具体代码如下： 12345678910111213141516171819class Solution { public int lengthOfLongestSubstring(String s) { if (s.length() == 0) return 0; int n = s.length(); int left = 0, right = 0; int maxLength = 1; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); for (; right &lt; n; right++) { char temp = s.charAt(right); if (map.containsKey(temp)) { left = Math.max(left, map.get(temp)); } maxLength = Math.max(maxLength, right - left + 1); map.put(temp, right + 1); } return maxLength; }}","link":"/2020/12/03/LeetCode/%E5%89%91%E6%8C%87%20Offer%2048.%20%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"title":"LeetCode&#x2F;剑指 Offer 49. 丑数","text":"剑指 Offer 49. 丑数我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。 示例 : 123输入: n = 10输出: 12解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。 说明: 1 是丑数。 n 不超过1690。 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题说实话，没啥意思，就是先把可能结果全算出来然后返回需要的结果，美其名曰动态规划、堆，其实就是面向测试用例编程。这里用动态规划的思想构造结果数据，因为丑数是以2、3、5为质因子的，所以使用三个指针，分别是对应质数2、3、5，每次取三个指针之一乘以对应质数存入相应的位置。 具体代码如下： 1234567891011121314151617class Solution { public int nthUglyNumber(int n) { int[] nums = new int[1690]; nums[0] = 1; int p2 = 0, p3 = 0, p5 = 0, temp = 0; for (int i = 1; i &lt; 1690; i++) { temp = Math.min(Math.min(nums[p2] * 2, nums[p3] * 3), nums[p5] * 5); nums[i] = temp; if (temp == nums[p2] * 2) p2++; if (temp == nums[p3] * 3) p3++; if (temp == nums[p5] * 5) p5++; } return nums[n - 1]; }}","link":"/2020/12/03/LeetCode/%E5%89%91%E6%8C%87%20Offer%2049.%20%E4%B8%91%E6%95%B0/"},{"title":"LeetCode&#x2F;剑指 Offer 50. 第一个只出现一次的字符","text":"剑指 Offer 50. 第一个只出现一次的字符在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。 示例 : 12345s = &quot;abaccdeff&quot;返回 &quot;b&quot;s = &quot;&quot; 返回 &quot; &quot; 限制： 10 &lt;= s 的长度 &lt;= 50000 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题思路很简单，就是先遍历一遍字符串，算出每个字母出现的次数，然后在进行一次遍历，找到出现次数为1的字母返回即可。这里不管你是用char数组还是Map还是其他的都可以。 具体代码如下： 1234567891011121314151617181920class Solution { public char firstUniqChar(String s) { if (s == null) return ' '; char result = ' '; Map&lt;Character, Integer&gt; map = new LinkedHashMap&lt;&gt;(); for (int i = 0; i &lt; s.length(); i++) { char temp = s.charAt(i); map.put(temp, map.getOrDefault(temp, 0) + 1); } for (Character c : map.keySet()) { if (map.get(c) == 1) { result = c; break; } } return result; }}","link":"/2020/12/03/LeetCode/%E5%89%91%E6%8C%87%20Offer%2050.%20%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/"},{"title":"LeetCode&#x2F;剑指 Offer 52. 两个链表的第一个公共节点","text":"剑指 Offer 52. 两个链表的第一个公共节点输入两个链表，找出它们的第一个公共节点。 如下面的两个链表： 在节点 c1 开始相交。 示例 1： 123输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3输出：Reference of the node with value = 8输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 示例 2： 123输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1输出：Reference of the node with value = 2输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 示例 3： 1234输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2输出：null输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。解释：这两个链表不相交，因此返回 null。 注意： 如果两个链表没有交点，返回 null. 在返回结果后，两个链表仍须保持原有的结构。 可假定整个链表结构中没有循环。 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题是左神讲过的原题，要判断两个链表是否相交，就需要消除两个链表的长度差(如果两链表长度相等可以忽略这一步)，具体做法就是定义两个指针分别指向两个链表，如果两个指针所指的当前结点不想等，则向后遍历。如果其中一个指针指向了链表的尾部，这时候另一个指针一定指向的是较长链表，我们把指向空的指针重新指向长链表的头结点(注意这里是指向长链表的头结点，即现在两个指针指向同一个链表)，然后再让两个指针一次一步继续向后走，当最开始指向长链表的指针到链表尾部的时候，将它指向短链表的头结点。此刻，两个指针交换了最初指向的链表，而且从此刻开始出发的话，两个指针距离链表尾部的距离是一样的，然后两个指针都向后遍历，如果遇到相等的结点，则证明两个链表相交，如果不相等则不相交。 具体代码如下： 1234567891011121314151617181920212223/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { ListNode p1 = headA, p2 = headB; while (p1 != p2) { p1 = p1 == null ? headB : p1.next; p2 = p2 == null ? headA : p2.next; } return p1; }}","link":"/2020/12/03/LeetCode/%E5%89%91%E6%8C%87%20Offer%2052.%20%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/"},{"title":"LeetCode&#x2F;剑指 Offer 53 - I. 在排序数组中查找数字 I","text":"剑指 Offer 53 - I. 在排序数组中查找数字 I统计一个数字在排序数组中出现的次数。 示例 1: 12输入: nums = [5,7,7,8,8,10], target = 8输出: 2 示例 2: 12输入: nums = [5,7,7,8,8,10], target = 6输出: 0 限制： 10 &lt;= 数组长度 &lt;= 50000 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题一看到排序数组四个大字，我啪的一下就站起来了，很快啊，直接二分查找，套用模板，这里唯一需要注意的一个细节就是，target有可能在nums数组中重复，只需要在找到目标值后，向前向后搜索，把所有满足要求的结果都找到。 具体代码如下： 1234567891011121314151617181920212223242526272829class Solution { public int search(int[] nums, int target) { if (nums.length == 0) return 0; int left = 0, right = nums.length, result = 0; int mid; while (left &lt; right) { mid = left + (right - left) / 2; if (nums[mid] == target) { result++; int temp = mid - 1; while (temp &gt;= 0 &amp;&amp; nums[temp] == target) { result++; temp--; } temp = mid + 1; while (temp &lt; nums.length &amp;&amp; nums[temp] == target) { result++; temp++; } break; } else if (nums[mid] &gt; target) { right = mid; } else { left = mid + 1; } } return result; }}","link":"/2020/12/03/LeetCode/%E5%89%91%E6%8C%87%20Offer%2053%20-%20I.%20%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97%20I/"},{"title":"LeetCode&#x2F;剑指 Offer 53 - II. 0～n-1中缺失的数字","text":"剑指 Offer 53 - II. 0～n-1中缺失的数字一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。 示例 1: 12输入: [0,1,3]输出: 2 示例 2: 12输入: [0,1,2,3,4,5,6,7,9]输出: 8 限制： 11 &lt;= 数组长度 &lt;= 10000 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题一看到递增排序数组，那直接二分查找的基调就定了下来，然后再思考，满足条件的数组应该是什么样子。我们举个例子，数组为[0,1,3]，这是一个长度为n - 1的数组，完整的长度为n的数组应该是[0,1,2,3]，缺失了2，所以应该返回2。仔细观察，可以发现满足条件nums[i] = i的时候，[0,i]之间一定都是满足条件的，所以缺失值出现在[i + 1, n - 1]，当nums[i] != i时，缺失情况出现，此时left值即为缺失值，由于需要跳出循环，所以我们需要让右边界缩小。 具体代码如下： 1234567891011121314class Solution { public int missingNumber(int[] nums) { int left = 0, mid = 0, right = nums.length; while (left &lt; right) { mid = left + ((right - left) &gt;&gt; 1); if (nums[mid] == mid) { left = mid + 1; } else { right = mid; } } return left; }}","link":"/2020/12/03/LeetCode/%E5%89%91%E6%8C%87%20Offer%2053%20-%20II.%200%EF%BD%9En-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/"},{"title":"LeetCode&#x2F;面试题 08.03. 魔术索引","text":"面试题 08.03. 魔术索引魔术索引。 在数组A[0...n-1]中，有所谓的魔术索引，满足条件A[i] = i。给定一个有序整数数组，编写一种方法找出魔术索引，若有的话，在数组A中找出一个魔术索引，如果没有，则返回-1。若有多个魔术索引，返回索引值最小的一个。 示例1 ： 123输入：nums = [0, 2, 3, 4, 5]输出：0说明: 0下标的元素为0 示例2： 12输入：nums = [1, 1, 1]输出：1 说明: nums长度在[1, 1000000]之间。 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题比较简单，可以遍历数组，这个就不解释了，直接上代码 具体代码如下： 123456789class Solution { public int findMagicIndex(int[] nums) { for (int i = 0; i &lt; nums.length; i++) { if (nums[i] == i) return i; } return -1; }}","link":"/2020/07/31/LeetCode/%E9%9D%A2%E8%AF%95%E9%A2%98%2008.03.%20%E9%AD%94%E6%9C%AF%E7%B4%A2%E5%BC%95/"},{"title":"LeetCode&#x2F;剑指 Offer 54. 二叉搜索树的第k大节点","text":"剑指 Offer 54. 二叉搜索树的第k大节点给定一棵二叉搜索树，请找出其中第k大的节点。 示例 1: 1234567输入: root = [3,1,4,null,2], k = 1 3 / \\ 1 4 \\ 2输出: 4 示例 2: 123456789输入: root = [5,3,6,2,4,null,null,1], k = 3 5 / \\ 3 6 / \\ 2 4 / 1输出: 4 限制： 11 ≤ k ≤ 二叉搜索树元素个数 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题一开始我绕了弯路，我一开始的想法是通过维护一个小顶堆，堆的大小为k，通过遍历二叉树，如果堆大小不足k，直接往进添加结点；如果堆大小为k，则比较当前结点值和堆顶结点值，如果当前结点值大于堆顶结点值，则将堆顶结点弹出，将当前结点加入小顶堆，这样最后直接返回堆顶元素的值即可。 很显然，上面思路绕了很大的弯路，需要遍历完整个二叉搜索树，没有利用到二叉搜索树中序遍历升序的特性，由于要找第k大的元素，我们可以直接逆中序遍历二叉树，设置一个counter用来记录当前是第几个结点，如果counter等于k，则直接返回即可。 具体代码如下： 123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { int counter; int result; public int kthLargest(TreeNode root, int k) { inOrder(root, k); return result; } private void inOrder(TreeNode root, int k) { if (root == null) return; inOrder(root.right, k); if (++counter == k) { result = root.val; return; } inOrder(root.left, k); }}","link":"/2020/12/03/LeetCode/%E5%89%91%E6%8C%87%20Offer%2054.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9/"},{"title":"LeetCode&#x2F;面试题16.11.跳水版","text":"面试题 16.11. 跳水板你正在使用一堆木板建造跳水板。有两种类型的木板，其中长度较短的木板长度为shorter，长度较长的木板长度为longer。你必须正好使用k块木板。编写一个方法，生成跳水板所有可能的长度。 返回的长度需要从小到大排列。 示例： 12345输入：shorter = 1longer = 2k = 3输出： {3,4,5,6} 提示： 0 &lt; shorter &lt;= longer 0 &lt;= k &lt;= 100000 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题思想比较简单，就是三种情况： k为0的时候，此时长度的可能为0，直接返回0 shorter 等于longer时，这时只有一种可能性，就是k块shorter或者longer拼接而成的长度 普通情况，有shorter有longer且两者不相等，这里一共有k+1种情况，所以将shorter和longer的组合填入result数组即可 这里有两点问题需要说明： 为什么一共有k+1种可能？ 假设这种情况，有shorter和longer两种板子，一共有k块板子，那么在长度组合中，longer的个数应该是从0块递增到k块，即0,1,2,….k，总共k+1块 实现代码中result[i] = (k - i) * shorter + i * longer;如果写成result[i] = i * shorter + (k - i) * longer;就会报错？具体错误如下： 该问题确切的说不是问题，只是因为 result 数组顺序是逆序，所以造成 LeetCode 判断结果为错误，我们可以打印出result[i] = i * shorter + (k - i) * longer;最后一个值和result[i] = (k - i) * shorter + i * longer;值作比较来证明，结果是一样的 具体代码如下： 12345678910111213141516171819202122class Solution { public int[] divingBoard(int shorter, int longer, int k) { //若一共需要0块模板，则直接返回空 if (k == 0) return new int[0]; //题目说了0 &lt; shorter &lt;= longer，所以shorter == longer这种情况存在 //这种情况下直接返回k个shorter或者longer拼接的长度即可 if (shorter == longer) { int[] result = new int[1]; result[0] = shorter * k; return result; } //这里用k块模板拼接一共有k+1种可能 int[] result = new int[k + 1]; for (int i = 0; i &lt; k + 1; i++) { result[i] = (k - i) * shorter + i * longer; } return result; }}","link":"/2020/07/08/LeetCode/%E9%9D%A2%E8%AF%95%E9%A2%9816.11.%E8%B7%B3%E6%B0%B4%E7%89%88/"},{"title":"LeetCode&#x2F;面试题17.13.恢复空格","text":"面试题 17.13. 恢复空格哦，不！你不小心把一个长篇文章中的空格、标点都删掉了，并且大写也弄成了小写。像句&quot;I reset the computer. It still didn’t boot!&quot;已经变成了&quot;iresetthecomputeritstilldidntboot&quot;。在处理标点符号和大小写之前，你得先把它断成词语。当然了，你有一本厚厚的词典dictionary，不过，有些词没在词典里。假设文章用sentence表示，设计一个算法，把文章断开，要求未识别的字符最少，返回未识别的字符数。 注意：本题相对原题稍作改动，只需返回未识别的字符数 示例： 12345输入：dictionary = [&quot;looked&quot;,&quot;just&quot;,&quot;like&quot;,&quot;her&quot;,&quot;brother&quot;]sentence = &quot;jesslookedjustliketimherbrother&quot;输出： 7解释： 断句后为&quot;jess looked just like tim her brother&quot;，共7个未识别字符。 提示： 0 &lt;= len(sentence) &lt;= 1000 dictionary中总字符数不超过 150000。 你可以认为dictionary和sentence中只包含小写字母。 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解：本题直接借鉴官方题解，就是字符串+动态规划，其他的方法都不够通俗易懂。基本思想就是，用一个 dp 数组存储前i个字符中最少未识别的字符的数量，定义两个指针i,j，判断 sentence 中 j-1 到 i-1 的子串是否在 dictionary 中，如果在 dictionary 中，那么状态转移方程为 $dp[i]=min(dp[i], dp[j-1])$ ；如果不存在，状态转移方程为$dp[i]=dp[i-1]+1$，即为前 i-1 个未识别的字符数量，加上当前 i 结点的一个字符。 关于如何存储 dictionary 中的单词，由于暴力破解每次都需要重复遍历，浪费了大量的时间，所以这里官方采用 Trie (字典树) 来存储字典中的单词，将单词的每个字母逆序插入到字典树中，每次状态转移的时候就从 Trie 的根节点出发，如果 sentence[j] 在 Trie 没有出现，则 sentence[j…i-1] 不在字典中，否则需要判断该字串是不是 dictionary 中的一个单词，通过加入 isEnd 标记来判断是否成词。 具体代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Solution { public int respace(String[] dictionary, String sentence) { //获取句子长度 int len = sentence.length(); //建立字典树 Trie root = new Trie(); for (String word : dictionary) { root.buildTrie(word); } int[] dp = new int[len + 1]; //定义dp数组，用来存放最少未识别的字符的个数 Arrays.fill(dp, Integer.MAX_VALUE); //由于后面需要比较，所以这里先将dp数组的默认值设置为最大 dp[0] = 0; //dp[0] = 0表示空字符串的最少未识别字符个数为0个 for (int i = 1; i &lt;= len; i++) { //默认没有找到字串在dictionary中出现 //所以就是前i-1的状态再加上当前未识别的字符 dp[i] = dp[i - 1] + 1; Trie curr = root; for (int j = i; j &gt;= 1; j--) { int t = sentence.charAt(j - 1) - 'a'; //当前元素根本不在字典树中，直接跳出循环 if (curr.next[t] == null) break; //这种情况表示sentence中[j-1,i-1]字串是dictionary中的一个单词 //这时只需要判断dp[i]和dp[j-1]中较小值即可 if (curr.next[t].isEnd == true) dp[i] = Math.min(dp[i], dp[j - 1]); curr = curr.next[t]; } } return dp[len]; }}class Trie { public Trie[] next; public boolean isEnd; //添加isEnd标志是为了判断当前字母在字典树中是否为最后一个单词的字母 public Trie() { next = new Trie[26]; //这里因为全是小写字母，所以一个结点的子结点最多有26个 isEnd = false; } public void buildTrie(String s) { Trie currentPoints = this; //将所有的单词，逆序插入字典树中 for (int i = s.length() - 1; i &gt;= 0; i--) { int temp = s.charAt(i) - 'a'; //将字符转换为整数方便处理 if (currentPoints.next[temp] == null) currentPoints.next[temp] = new Trie(); currentPoints = currentPoints.next[temp]; } currentPoints.isEnd = true; //将该单词的最后一个字母标记为结尾单词 }}","link":"/2020/07/09/LeetCode/%E9%9D%A2%E8%AF%95%E9%A2%9817.13.%E6%81%A2%E5%A4%8D%E7%A9%BA%E6%A0%BC/"},{"title":"Docker&#x2F;1.Docker简介","text":"Docker 简介Docker 是什么为什么会有 Docker 出现？一款产品从开发到上线，从操作系统，到运行环境，再到应用配置。作为开发+运维之间的协作我们需要关心很多东西，这也是很多互联网公司都不得不面对的问题，特别是各种版本的迭代之后，不同版本环境的兼容，对运维人员都是考验 Docker 之所以发展如此迅速，也是因为它对此给出了一个标准化的解决方案。 环境配置如此麻烦，换一台机器，就要重来一次，费力费时。很多人想到，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。开发人员利用 Docker 可以消除协作编码时“在我的机器上可正常工作”的问题。 之前在服务器配置一个应用的运行环境，要安装各种软件，就拿尚硅谷电商项目的环境来说吧，Java/Tomcat/MySQL/JDBC 驱动包等。安装和配置这些东西有多麻烦就不说了，它还不能跨平台。假如我们是在 Windows 上安装的这些环境，到了 Linux 又得重新装。况且就算不跨操作系统，换另一台同样操作系统的服务器，要移植应用也是非常麻烦的。 传统上认为，软件编码开发/测试结束后，所产出的成果即是程序或是能够编译执行的二进制字节码等(Java 为例)。而为了让这些程序可以顺利执行，开发团队也得准备完整的部署文件，让维运团队得以部署应用程式，开发需要清楚的告诉运维部署团队，用的全部配置文件+所有软件环境。不过，即便如此，仍然常常发生部署失败的状况。Docker 镜像的设计，使得 Docker 得以打破过去「程序即应用」的观念。透过镜像(images)将作业系统核心除外，运作应用程式所需要的系统环境，由下而上打包，达到应用程式跨平台间的无缝接轨运作。 Docker 理念Docker 是基于 Go 语言实现的云开源项目。 Docker 的主要目标是“Build，Ship and Run Any App,Anywhere”，也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的 APP（可以是一个 WEB 应用或数据库应用等等）及其运行环境能够做到“一次封装，到处运行”。 Linux 容器技术的出现就解决了这样一个问题，而 Docker 就是在它的基础上发展过来的。将应用运行在 Docker 容器上面，而 Docker 容器在任何操作系统上都是一致的，这就实现了跨平台、跨服务器。只需要一次配置好环境，换到别的机子上就可以一键部署好，大大简化了操作。 Docker 解决了运行环境和配置问题软件容器，方便做持续集成并有助于整体发布的容器虚拟化技术。 Docker 能干什么Docker 出现之前的虚拟机技术虚拟机（Virtual Machine）就是带环境安装的一种解决方案。 它可以在一种操作系统里面运行另一种操作系统，比如在 Windows 系统里面运行 Linux 系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。这类虚拟机完美的运行了另一套系统，能够使应用程序，操作系统和硬件三者之间的逻辑不变。 虚拟机的缺点： 资源占用多 冗余步骤多 启动慢 容器虚拟化技术由于前面虚拟机存在这些缺点，Linux 发展出了另一种虚拟化技术：Linux 容器（Linux Containers，缩写为 LXC）。 Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。有了容器，就可以将软件运行所需的所有资源打包到一个隔离的容器中。容器与虚拟机不同，不需要捆绑一整套操作系统，只需要软件工作所需的库资源和设置。系统因此而变得高效轻量并保证部署在任何环境中的软件都能始终如一地运行。 比较了 Docker 和传统虚拟化方式的不同之处： 传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程； 而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。 每个容器之间互相隔离，每个容器有自己的文件系统 ，容器之间进程不会相互影响，能区分计算资源。 开发和运维一次构建、随处运行 更快速的应用交付和部署传统的应用开发完成后，需要提供一堆安装程序和配置说明文档，安装部署后需根据配置文档进行繁杂的配置才能正常运行。Docker 化之后只需要交付少量容器镜像文件，在正式生产环境加载镜像并运行即可，应用安装配置在镜像里已经内置好，大大节省部署配置和测试验证时间。 更便捷的升级和扩缩容随着微服务架构和 Docker 的发展，大量的应用会通过微服务方式架构，应用的开发构建将变成搭乐高积木一样，每个 Docker 容器将变成一块“积木”，应用的升级将变得非常容易。当现有的容器不足以支撑业务处理时，可通过镜像运行新的容器进行快速扩容，使应用系统的扩容从原先的天级变成分钟级甚至秒级。 更简单的系统运维应用容器化运行后，生产环境运行的应用可与开发、测试环境的应用高度一致，容器会将应用程序相关的环境和状态完全封装起来，不会因为底层基础架构和操作系统的不一致性给应用带来影响，产生新的 BUG。当出现程序异常时，也可以通过测试环境的相同容器进行快速定位和修复。 更高效的计算资源利用Docker 是内核级虚拟化，其不像传统的虚拟化技术一样需要额外的 Hypervisor 支持，所以在一台物理机上可以运行很多个容器实例，可大大提升物理服务器的 CPU 和内存的利用率。 Hypervisor，又称虚拟机监视器（英语：Virtual Machine Monitor，缩写为 VMM），是用来建立与执行虚拟机器的软件、固件或硬件。 被 Hypervisor 用来执行一个或多个虚拟机器的电脑称为主体机器（Host Machine），这些虚拟机器则称为客体机器（Guest Machine）。Hypervisor 提供虚拟的作业平台来执行客体操作系统（Guest Operating Systems），负责管理其他客体操作系统的执行阶段；这些客体操作系统，共同分享虚拟化后的硬件资源。 企业级新浪 美团 蘑菇街 Docker 官方网址Docker 官网：http://www.docker.com Docker 中文网站：https://www.docker-cn.com/ Docker Hub 官网: https://hub.docker.com/","link":"/2020/11/06/Docker/1.Docker%E7%AE%80%E4%BB%8B/"},{"title":"Docker&#x2F;2.Docker安装","text":"Docker 安装前提说明CentOS Docker 安装Docker 支持以下的 CentOS 版本： CentOS 7 (64-bit) CentOS 6.5 (64-bit) 或更高的版本 前提条件目前，CentOS 仅发行版本中的内核支持 Docker。 Docker 运行在 CentOS 7 上，要求系统为64位、系统内核版本为 3.10 以上。 Docker 运行在 CentOS 6.5 或更高的版本的 CentOS 上，要求系统为64位、系统内核版本为 2.6.32-431 或者更高版本。 查看自己的内核uname 命令用于打印当前系统相关信息（内核版本号、硬件架构、主机名称和操作系统类型等）。 查看已安装的 CentOS 版本信息（CentOS 6.8 有，CentOS 7 无该命令） Docker 的基本组成镜像(Image)Docker 镜像（Image）就是一个只读的模板。镜像可以用来创建 Docker 容器，一个镜像可以创建很多容器。 容器(Container)Docker 利用容器（Container）独立运行的一个或一组应用。容器是用镜像创建的运行实例。 它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。 可以把容器看做是一个简易版的 Linux 环境（包括 root 用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。 容器的定义和镜像几乎一模一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的。 仓库(Repository)仓库（Repository）是集中存放镜像文件的场所。 仓库（Repository）和仓库注册服务器（Registry）是有区别的。仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（Tag）。 仓库分为公开仓库（Public）和私有仓库（Private）两种形式。 最大的公开仓库是 Docker Hub(https://hub.docker.com/)， 存放了数量庞大的镜像供用户下载。国内的公开仓库包括阿里云 、网易云等 总结需要正确的理解仓储/镜像/容器这几个概念: Docker 本身是一个容器运行载体或称之为管理引擎。我们把应用程序和配置依赖打包好形成一个可交付的运行环境，这个打包好的运行环境就是 Image 镜像文件。只有通过这个镜像文件才能生成 Docker 容器。Image 文件可以看作是容器的模板。Docker 根据 Image 文件生成容器的实例。同一个 Image 文件，可以生成多个同时运行的容器实例。 Image 文件生成的容器实例，本身也是一个文件，称为镜像文件。 一个容器运行一种服务，当我们需要的时候，就可以通过 Docker 客户端创建一个对应的运行实例，也就是我们的容器。 至于仓储，就是放了一堆镜像的地方，我们可以把镜像发布到仓储中，需要的时候从仓储中拉下来就可以了。 Docker 架构图 安装步骤CentOS 6.8 安装 Docker yum install -y epel-release Docker 使用 EPEL 发布，RHEL 系的 OS 首先要确保已经持有 EPEL 仓库，否则先检查 OS 的版本，然后安装相应的 EPEL 包。 yum install -y docker-io 安装后的配置文件：/etc/sysconfig/docker 启动 Docker 后台服务：service docker start docker version 验证 CentOS 7 安装 Docker 官网中文安装参考手册：https://docs.docker.com/install/linux/docker-ce/centos/ 确认系统版本，为了安装 Docker，你需要一个 CentOS 7.x 以上的版本 删除旧版本 Docker 12345678$ sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 配置 stable 镜像仓库：yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 安装需要的软件包 1$ sudo yum install -y yum-utils device-mapper-persistent-data lvm2 安装 Docker 1$ sudo yum install docker-ce docker-ce-cli containerd.io 启动 Docker 1$ sudo systemctl start docker 测试 Docker 是否安装成功 1$ docker version 1$ docker run hello-world 配置镜像加速 1234$ mkdir -p /etc/docker$ vim /etc/docker/daemon.json$ systemctl daemon-reload$ systemctl restart docker 登录阿里云容器镜像服务配置镜像加速 卸载 Docker 123$ systemctl stop docker$ yum -y remove docker-ce$ rm -rf /var/lib/docker Hello World阿里云镜像加速 是什么 https://dev.aliyun.com/search.html 注册一个阿里云账户(可复用支付宝账户) 获得加速器地址链接 登录阿里云开发者平台 获取加速器地址 配置本机 Docker 运行镜像加速器 鉴于国内网络问题，后续拉取 Docker 镜像十分缓慢，我们可以需要配置加速器来解决， 我使用的是阿里云的本人自己账号的镜像地址(需要自己注册有一个属于你自己的)： https://xxxx.mirror.aliyuncs.com vim /etc/sysconfig/docker 将获得的自己账户下的阿里云加速地址配置进other_args=”—registry-mirror=https://你自己的账号加速信息.mirror.aliyuncs.com“ 重启 Docker 后台服务 Linux 系统下配置完加速器需要检查是否生效 网易云加速 { &quot;registry-mirrors&quot;: [&quot;http://hub-mirror.c.163.com&quot;] } 启动 Docker 后台容器(测试运行 hello-world) docker run hello-world 输出这段提示以后，hello world 就会停止运行，容器自动终止。 run 干了什么 底层原理Docker 是怎么工作的Docker 是一个 Client-Server 结构的系统，Docker 守护进程运行在主机上， 然后通过 Socket 连接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器。 容器，是一个运行时环境，就是我们前面说到的集装箱。 为什么 Docker 比 VM 快 Docker 有着比虚拟机更少的抽象层。由于 Docker 不需要 Hypervisor 实现硬件资源虚拟化，运行在Docker 容器上的程序直接使用的都是实际物理机的硬件资源。因此在 CPU、内存利用率上 Docker 将会在效率上有明显优势。 Docker 利用的是宿主机的内核，而不需要 Guest OS。因此，当新建一个容器时，Docker 不需要和虚拟机一样重新加载一个操作系统内核。仍而避免引寻、加载操作系统内核返个比较费时费资源的过程，当新建一个虚拟机时，虚拟机软件需要加载 Guest OS，返个新建过程是分钟级别的。而 Docker 由于直接利用宿主机的操作系统，则省略了返个过程，因此新建一个 Docker 容器只需要几秒钟。","link":"/2020/11/17/Docker/2.Docker%E5%AE%89%E8%A3%85/"},{"title":"Docker&#x2F;3.Docker常用命令","text":"Docker 常用命令帮助命令docker version docker info docker —help 镜像命令docker image列出本地主机上的镜像 OPTIONS 说明： -a：列出本地所有的镜像（含中间映像层） -q：只显示镜像ID —digests：显示镜像的摘要信息 —no-trunc：显示完整的镜像信息 docker search 镜像名称网站https://hub.docker.com 命令docker search [OPTIONS] 镜像名字 OPTIONS 说明： —no-trunc：显示完整的镜像描述 -s：列出收藏数不小于指定值的镜像 —automated：只列出 automated build 类型的镜像 docker pull 镜像名称 下载镜像 docker rmi 镜像名称或 ID 删除镜像 删除单个 docker rmi -f 镜像 ID 删除多个 docker rmi -f 镜像名1:TAG 镜像名2:TAG 删除全部 docker rmi -f $(docker images -qa) 容器命令有镜像才能创建容器，这是根本前提(下载一个 CentOS 镜像演示) docker pull centos 新建并启动容器 docker run [OPTIONS] IMAGE [COMMAND] [ARG…] OPTIONS 说明 OPTIONS 说明（常用）：有些是一个减号，有些是两个减号 —name=”容器新名字”: 为容器指定一个名称； -d: 后台运行容器，并返回容器 ID，也即启动守护式容器； -i：以交互模式运行容器，通常与 -t 同时使用； -t：为容器重新分配一个伪输入终端，通常与 -i 同时使用； -P(大写): 随机端口映射； -p: 指定端口映射，有以下四种格式 ip:hostPort:containerPort ip::containerPort hostPort:containerPort containerPort 启动交互式容器 使用镜像 centos:latest 以交互模式启动一个容器,在容器内执行 /bin/bash 命令。 docker run -it centos /bin/bash 列出当前所有正在运行的容器 docker ps [OPTIONS] OPTIONS说明 OPTIONS 说明（常用）： -a :列出当前所有正在运行的容器+历史上运行过的 -l :显示最近创建的容器。 -n：显示最近n个创建的容器。 -q :静默模式，只显示容器编号。 —no-trunc :不截断输出。 退出容器退出容器的两种方式 exite：容器停止退出 Ctrl + P + Q：容器不停止退出 启动容器 docker start 容器 ID 或者容器名 重启容器 docker restart 容器 ID 或者容器名 停止容器 docker stop 容器 ID 或者容器名 强制停止容器 docker kill 容器 ID 或者容器名 删除已停止的容器 docker rm 容器 ID 一次性删除多个容器 docker rm -f $(docker ps -a -q) docker ps -a -q | xargs docker rm 重要启动守护式容器 docker run -d 容器名 使用镜像 centos:latest 以后台模式启动一个容器 docker run -d centos 问题：然后 docker ps -a 进行查看, 会发现容器已经退出 很重要的要说明的一点: Docker 容器后台运行，就必须有一个前台进程 容器运行的命令如果不是那些一直挂起的命令（比如运行top，tail），就是会自动退出的。 这个是 Docker 的机制问题，比如你的 web 容器,我们以 nginx 为例，正常情况下，我们配置启动服务只需要启动响应的 service 即可。例如service nginx start，但是这样做，nginx 为后台进程模式运行，就导致Docker 前台没有运行的应用，这样的容器后台启动后，会立即自杀因为他觉得他没事可做了。 所以，最佳的解决方案是，将你要运行的程序以前台进程的形式运行。 查看容器日志 docker log -f -t —tail 容器 ID -t 是加入时间戳 -f 跟随最新的日志打印 —tail 数字显示最后多少条 查看容器内运行的进程 docker top 容器 ID 查看容器内部细节 docker inspect 容器 ID 进入正在运行的容器并以命令行交互 docker exec -it 容器 ID bashShell 重新进入docker attach 容器 ID 上述两个区别 attach 直接进入容器启动命令的终端，不会启动新的进程 exec 是在容器中打开新的终端，并且可以启动新的进程 从容器内拷贝文件到主机上 docker cp 容器 ID:容器内路径 目的主机路径 总结 attach Attach to a running container # 当前 shell 下 attach 连接指定运行镜像 build Build an image from a Dockerfile # 通过 Dockerfile 定制镜像 commit Create a new image from a container changes # 提交当前容器为新的镜像 cp Copy files/folders from the containers filesystem to the host path #从容器中拷贝指定文件或者目录到宿主机中 create Create a new container # 创建一个新的容器，同 run，但不启动容器 diff Inspect changes on a container’s filesystem # 查看 docker 容器变化 events Get real time events from the server # 从 docker 服务获取容器实时事件 exec Run a command in an existing container # 在已存在的容器上运行命令 export Stream the contents of a container as a tar archive # 导出容器的内容流作为一个 tar 归档文件[对应 import ] history Show the history of an image # 展示一个镜像形成历史 images List images # 列出系统当前镜像 import Create a new filesystem image from the contents of a tarball # 从tar包中的内容创建一个新的文件系统映像[对应export] info Display system-wide information # 显示系统相关信息 inspect Return low-level information on a container # 查看容器详细信息 kill Kill a running container # kill 指定 docker 容器 load Load an image from a tar archive # 从一个 tar 包中加载一个镜像[对应 save] login Register or Login to the docker registry server # 注册或者登陆一个 docker 源服务器 logout Log out from a Docker registry server # 从当前 Docker registry 退出 logs Fetch the logs of a container # 输出当前容器日志信息 port Lookup the public-facing port which is NAT-ed to PRIVATE_PORT # 查看映射端口对应的容器内部源端口 pause Pause all processes within a container # 暂停容器 ps List containers # 列出容器列表 pull Pull an image or a repository from the docker registry server # 从docker镜像源服务器拉取指定镜像或者库镜像 push Push an image or a repository to the docker registry server # 推送指定镜像或者库镜像至docker源服务器 restart Restart a running container # 重启运行的容器 rm Remove one or more containers # 移除一个或者多个容器 rmi Remove one or more images # 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除] run Run a command in a new container # 创建一个新的容器并运行一个命令 save Save an image to a tar archive # 保存一个镜像为一个 tar 包[对应 load] search Search for an image on the Docker Hub # 在 docker hub 中搜索镜像 start Start a stopped containers # 启动容器 stop Stop a running containers # 停止容器 tag Tag an image into a repository # 给源中镜像打标签 top Lookup the running processes of a container # 查看容器中运行的进程信息 unpause Unpause a paused container # 取消暂停容器 version Show the docker version information # 查看 docker 版本号 wait Block until a container stops, then print its exit code # 截取容器停止时的退出状态值","link":"/2020/11/06/Docker/3.Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"title":"Docker&#x2F;4.Docker镜像","text":"Docker 镜像定义镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。 UnionFS（联合文件系统）UnionFS（联合文件系统）：Union 文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union 文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。 特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录 Docker 镜像加载原理Docker 镜像加载原理： Docker 的镜像实际上由一层一层的文件系统组成，这种层级的文件系统 UnionFS。 BootFS(Boot File System) 主要包含 Bootloader 和 Kernel，Bootloader 主要是引导加载 Kernel，Linux 刚启动时会加载 BootFS 文件系统，在 Docker 镜像的最底层是 BootFS 。这一层与我们典型的 Linux/Unix 系统是一样的，包含 Boot 加载器和内核。当 Boot 加载完成之后整个内核就都在内存中了，此时内存的使用权已由BootFS 转交给内核，此时系统也会卸载 BootFS。 RootFS (Root File System) ，在 BootFS 之上。包含的就是典型 Linux 系统中的 /dev, /proc, /bin, /etc 等标准目录和文件。RootFS 就是各种不同的操作系统发行版，比如 Ubuntu，CentOS 等等。 平时我们安装进虚拟机的 CentOS 都是好几个 G，为什么 Docker 这里才 200M？ 对于一个精简的 OS，RootFS 可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接用Host 的 Kernel，自己只需要提供 RootFS 就行了。由此可见对于不同的 Linux 发行版，BootFS 基本是一致的，RootFS 会有差别，因此不同的发行版可以公用 BootFS。 分层的镜像以 docker pull 为例，在下载的过程中我们可以看到 Docker 的镜像好像是在一层一层的下载 为什么 Docker 镜像要采用这种分层结构最大的一个好处就是——共享资源 比如：有多个镜像都从相同的 base 镜像构建而来，那么宿主机只需在磁盘上保存一份 base 镜像，同时内存中也只需加载一份 base 镜像，就可以为所有容器服务了，而且镜像的每一层都可以被共享。 特点Docker 镜像都是只读的，当容器启动时，一个新的可写层被加载到镜像的顶部，这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。 Docker 镜像 commit 操作补充 docker commit 提交容器副本使之成为一个新的镜像 docker commit -m=“提交的描述信息” -a=“作者” 容器ID 要创建的目标镜像名:[标签名] 案例演示 从 Hub 上下载 Tomcat 镜像到本地并成功运行 1234567docker run -it -p 8080:8080 tomcat参数说明：-p 主机端口:docker容器端口-P 随机分配端口i:交互t:终端 第一次访问有可能出现404情况，直接使用 docker exec -it 容器 ID /bin/bash 进入Tomcat，将其中的webapps 文件夹删除，将 webapps.dist 名称改为 webapps，然后重启 Tomcat 就可以正常访问了。 具体解决方法参考https://www.cnblogs.com/xiaozhang666/p/12382114.html 故意删除上一步镜像生产 Tomcat 容器的文档 也即当前的 Tomcat 运行实例是一个没有文档内容的容器，以它为模板 commit 一个没有 docs 的 Tomcat新镜像 codedragon/tomcat02 启动新镜像并和原来的对比 启动 codedragon/tomcat02，它没有 docs 新启动原来的 Tomcat，它有 docs","link":"/2020/11/06/Docker/4.Docker%E9%95%9C%E5%83%8F/"},{"title":"Docker&#x2F;5.Docker容器数据卷","text":"Docker 容器数据卷定义先来看看 Docker 的理念： 将运用与运行的环境打包形成容器运行 ，运行可以伴随着容器，但是我们对数据的要求希望是持久化的 容器之间希望有可能共享数据 Docker 容器产生的数据，如果不通过 docker commit 生成新的镜像，使得数据作为镜像的一部分保存下来， 那么当容器删除后，数据自然也就没有了，为了能保存数据在 Docker 中我们使用卷。 用途卷就是目录或文件，存在于一个或多个容器中，由 Docker 挂载到容器，但不属于联合文件系统，因此能够绕过Union File System 提供一些用于持续存储或共享数据的特性： 卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此 Docker 不会在容器删除时删除其挂载的数据卷 特点： 数据卷可在容器之间共享或重用数据 卷中的更改可以直接生效 数据卷中的更改不会包含在镜像的更新中 数据卷的生命周期一直持续到没有容器使用它为止 容器的持久化 容器间继承+共享数据 数据卷直接命令添加 docker run -it -v /宿主机绝对路径目录:/容器内目录 镜像名 查看数据卷是否挂载成功 容器和宿主机之间数据共享 容器停止退出后，主机修改后数据是否同步 docker run -it -v /宿主机绝对路径目录:/容器内目录:ro 镜像名 DockerFile添加 根目录下新建 mydocker 文件夹并进入 可在 DockerFile中使用 VOLUME 指令来给镜像添加一个或多个数据卷 VOLUME[“/dataVolumeContainer”,”/dataVolumeContainer2”,”/dataVolumeContainer3”] 说明： 出于可移植和分享的考虑，用 -v 主机目录:容器目录这种方法不能够直接在 DockerFile中实现。 由于宿主机目录是依赖于特定宿主机的，并不能够保证在所有的宿主机上都存在这样的特定目录。 File构建 build 后生成镜像 注意：命令最后有一个”.” run 容器 通过上述步骤，容器内的卷目录地址已经知道对应的主机目录地址 主机对应默认地址 可以看到 Docker 会为我们自动生成主机的默认地址 备注Docker 挂载主机目录 Docker 访问出现 cannot open directory .: Permission denied 解决办法：在挂载目录后多加一个 —privileged=true 参数即可 数据卷容器定义命名的容器挂载数据卷，其它容器通过挂载这个(父容器)实现数据共享，挂载数据卷的容器，称之为数据卷容器 介绍 以上一步新建的镜像 codedragon/centos 为模板并运行容器 dc01/dc02/dc03 它们已经具有容器卷 /dataVolumeContainer1 /dataVolumeContainer2 容器间传递共享(—volumes-from) 先启动一个父容器 dc01，在dataVolumeContainer2新增内容 dc02/dc03 继承自 dc01 —volumes-from dc02/dc03 分别在 dataVolumeContainer2 各自新增内容 docker run -it —name dc02 —volumes-from dc01 codedragon/centos docker run -it —name dc03 —volumes-from dc01 codedragon/centos 回到 dc01 可以看到 02/03 各自添加的都能共享了 删除 dc01，dc02 修改后 dc03 可否访问 删除 dc02 后 dc03 可否访问 新建 dc04 继承 dc03 后再删除 dc03 结论：容器之间配置信息的传递，数据卷的生命周期一直持续到没有容器使用它为止","link":"/2020/11/09/Docker/5.Docker%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E5%8D%B7/"},{"title":"Docker&#x2F;6.DockerFile解析","text":"DockerFile解析定义 DockerFile 是用来构建 Docker 镜像的构建文件，是由一系列命令和参数构成的脚本 构建三步骤 编写 DockerFile 文件 docker build docker run DockerFile 构建过程解析DockerFile 内容基础知识 每条保留字指令都必须为大写字母且后面要跟随至少一个参数 指令按照从上到下，顺序执行 #表示注释 每条指令都会创建一个新的镜像层，并对镜像进行提交 Docker 执行 DockerFile 的大致流程 Docker 从基础镜像运行一个容器 执行一条指令并对容器作出修改 执行类似 docker commit 的操作提交一个新的镜像层 Docker 再基于刚提交的镜像运行一个新容器 执行 DockerFile 中的下一条指令直到所有指令都执行完成 总结从应用软件的角度来看，DockerFile、Docker 镜像与 Docker 容器分别代表软件的三个不同阶段， DockerFile 是软件的原材料 Docker 镜像是软件的交付品 Docker 容器则可以认为是软件的运行态 DockerFile 面向开发，Docker 镜像成为交付标准，Docker 容器则涉及部署与运维，三者缺一不可，合力充当 Docker 体系的基石。 DockerFile，需要定义一个 DockerFile，DockerFile 定义了进程需要的一切东西。DockerFile 涉及的内容包括执行代码或者是文件、环境变量、依赖包、运行时环境、动态链接库、操作系统的发行版、服务进程和内核进程(当应用进程需要和系统服务和内核进程打交道，这时需要考虑如何设计 namespace 的权限控制)等等; Docker 镜像，在用 DockerFile 定义一个文件之后，docker build 时会产生一个 Docker 镜像，当运行 Docker 镜像时，会真正开始提供服务; Docker 容器，容器是直接提供服务的。 DockerFile 体系结构FROM 基础镜像，当前新镜像是基于哪个镜像的 MAINTAINER 镜像维护者的姓名和邮箱地址 RUN 容器构建时需要运行的命令 EXPOSE 当前容器对外暴露出的端口 WORKDIR 指定在创建容器后，终端默认登陆的进来工作目录，一个落脚点 ENV 用来在构建镜像过程中设置环境变量 ENV MY_PATH /usr/mytest 这个环境变量可以在后续的任何RUN指令中使用，这就如同在命令前面指定了环境变量前缀一样； 也可以在其它指令中直接使用这些环境变量， 比如：WORKDIR $MY_PATH ADD将宿主机目录下的文件拷贝进镜像且 ADD 命令会自动处理 URL 和解压 tar 压缩包 COPY类似 ADD，拷贝文件和目录到镜像中。将从构建上下文目录中 &lt;源路径&gt; 的文件/目录复制到新的一层的镜像内的 &lt;目标路径&gt; 位置 COPY src dest COPY [“src”, “dest”] VOLUME容器数据卷，用于数据保存和持久化工作 CMD 指定一个容器启动时要运行的命令 DockerFile 中可以有多个 CMD 指令，但只有最后一个生效，CMD 会被 docker run 之后的参数替换 ENTRYPOINT 指定一个容器启动时要运行的命令 ENTRYPOINT 的目的和 CMD 一样，都是在指定容器启动程序及参数 ONBUILD当构建一个被继承的 DockerFile 时运行命令，父镜像在被子继承后父镜像的 onbuild 被触发 总结 案例Base 镜像(scratch) Docker Hub 中 99% 的镜像都是通过在 base 镜像中安装和配置需要的软件构建出来的 自定义镜像 mycentos编写 Hub 默认 CentOS 镜像情况 自定义 mycentos 目的使我们自己的镜像具备如下： ​ 登陆后的默认路径 ​ vim 编辑器 ​ 查看网络配置 ifconfig 支持 准备编写 DockerFile 文件 myCentOS 内容 DockerFile 构建 docker build -t 新镜像名字:TAG 运行 docker run -it 新镜像名字:TAG 可以看到，我们自己的新镜像已经支持 vim/ifconfig 命令，扩展成功了。 列出镜像的变更历史docker history 镜像名 CMD/ENTRYPOINT 镜像案例都是指定一个容器启动时要运行的命令CMD DockerFile 中可以有多个 CMD 指令，但只有最后一个生效，CMD 会被 docker run 之后的参数替换 Case Tomcat 的讲解演示：docker run -it -p 8888:8080 tomcat ls -l ENTRYPOINT docker run 之后的参数会被当做参数传递给 ENTRYPOINT，之后形成新的命令组合 制作 CMD 版可以查询 IP 信息的容器 FROM centosRUN yum install -y curlCMD [ “curl”, “-s”, “http://ip.cn“ ] ￼ crul 命令解释： curl 命令可以用来执行下载、发送各种 HTTP 请求，指定 HTTP 头部等操作。 如果系统没有 curl 可以使用 yum install curl 安装，也可以下载安装。 curl 是将下载文件输出到 stdout 使用命令：curl http://www.baidu.com 执行后，www.baidu.com的 html 就会显示在屏幕上了 这是最简单的使用方法。用这个命令获得了http://curl.haxx.se指向的页面，同样，如果这里的URL指向的是一个文件或者一幅图都可以直接下载到本地。如果下载的是 HTML 文档，那么缺省的将只显示文件头部，即 HTML 文档的 header。要全部显示，请加参数 -i 如果我们希望显示 HTTP 头信息，就需要加上 -i 参数 WHY 我们可以看到可执行文件找不到的报错，executable file not found。 之前我们说过，跟在镜像名后面的是 command，运行时会替换 CMD 的默认值。 因此这里的 -i 替换了原来的 CMD，而不是添加在原来的 curl -s http://ip.cn 后面。而 -i 根本不是命令，所以自然找不到。 那么如果我们希望加入 -i 这参数，我们就必须重新完整的输入这个命令： $ docker run myip curl -s http://ip.cn -i 制作 ENTROYPOINT 版查询IP信息的容器 FROM centos RUN yum install -y curl ENTRYPOINT [ “curl”, “-s”, “http://ip.cn“ ] 自定义镜像 Tomcat9 mkdir -p /zzyyuse/mydockerfile/tomcat9 在上述目录下 touch c.txt 将 JDK 和 Tomcat 安装的压缩包拷贝进上一步目录 apache-tomcat-9.0.8.tar.gz jdk-8u171-linux-x64.tar.gz ￼￼ 在/zzyyuse/mydockerfile/tomcat9目录下新建 DockerFile 文件 123456789101112131415161718192021222324FROM centosMAINTAINER zzyy#把宿主机当前上下文的c.txt拷贝到容器/usr/local/路径下COPY c.txt /usr/local/cincontainer.txt#把java与tomcat添加到容器中ADD jdk-8u171-linux-x64.tar.gz /usr/local/ADD apache-tomcat-9.0.8.tar.gz /usr/local/#安装vim编辑器RUN yum -y install vim#设置工作访问时候的WORKDIR路径，登录落脚点ENV MYPATH /usr/localWORKDIR $MYPATH#配置java与tomcat环境变量ENV JAVA_HOME /usr/local/jdk1.8.0_171ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarENV CATALINA_HOME /usr/local/apache-tomcat-9.0.8ENV CATALINA_BASE /usr/local/apache-tomcat-9.0.8ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin#容器运行时监听的端口EXPOSE 8080#启动时运行tomcat# ENTRYPOINT [\"/usr/local/apache-tomcat-9.0.8/bin/startup.sh\" ]# CMD [\"/usr/local/apache-tomcat-9.0.8/bin/catalina.sh\",\"run\"]CMD /usr/local/apache-tomcat-9.0.8/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-9.0.8/bin/logs/catalina.out 构建 run docker run -d -p 9080:8080 —name myt9 -v /zzyyuse/mydockerfile/tomcat9/test:/usr/local/apache-tomcat-9.0.8/webapps/test -v /zzyyuse/mydockerfile/tomcat9/tomcat9logs/:/usr/local/apache-tomcat-9.0.8/logs —privileged=true zzyytomcat9 ￼ 备注： Docker 挂载主机目录 Docker 访问出现cannot open directory .: Permission denied 解决办法：在挂载目录后多加一个 —privileged=true 参数即可 验证 结合前述的容器卷将测试的 web 服务 test 发布 总体概述 web.xml 1234xmlns=\"http://java.sun.com/xml/ns/javaee\"xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"id=\"WebApp_ID\" version=\"2.5\"&gt;test a.jsp 1-----------welcome------------ 测试 总结","link":"/2020/11/09/Docker/6.DockerFile%E8%A7%A3%E6%9E%90/"},{"title":"Docker&#x2F;7.Docker常用安装","text":"Docker 常用安装总体步骤 搜索镜像 拉取镜像 查看镜像 启动镜像 停止容器 移除容器 安装 Tomcatdocker hub 上面查找 Tomcat 镜像 docker search tomcat 从 docker hub 上拉取 Tomcat 镜像到本地 docker pull tomcat 官网命令 拉取完成 docker images 查看是否有拉取到的 Tomcat 使用 Tomcat 镜像创建容器(也叫运行镜像) docker run -it -p 8080:8080 tomcat -p：主机端口:docker容器端口 -P：随机分配端口 i：交互 t：终端 安装 MySQLdocker hub 上面查找 MySQL 镜像 从 docker hub 上(阿里云加速器)拉取 MySQL 镜像到本地标签为5.6 使用 MySQL 5.6 镜像创建容器(也叫运行镜像)使用 mysql 镜像 docker run -p 12345:3306 —name mysql -v /zzyyuse/mysql/conf:/etc/mysql/conf.d -v /zzyyuse/mysql/logs:/logs -v /zzyyuse/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.6 命令说明：-p 12345:3306：将主机的 12345 端口映射到 docker 容器的 3306 端口。—name mysql：运行服务名字-v /zzyyuse/mysql/conf:/etc/mysql/conf.d ：将主机/zzyyuse/mysql录下的conf/my.cnf 挂载到容器的 /etc/mysql/conf.d-v /zzyyuse/mysql/logs:/logs：将主机/zzyyuse/mysql目录下的 logs 目录挂载到容器的 /logs。-v /zzyyuse/mysql/data:/var/lib/mysql ：将主机/zzyyuse/mysql目录下的data目录挂载到容器的 /var/lib/mysql-e MYSQL_ROOT_PASSWORD=123456：初始化 root 用户的密码。-d mysql:5.6 : 后台程序运行mysql5.6 docker exec -it MySQL 运行成功后的容器ID /bin/bash ￼ 外部 Win10 也来连接运行在 Dokcer 上的 MySQL 服务 数据备份小测试(可以不做)docker exec myql 服务容器ID sh -c ‘ exec mysqldump —all-databases -uroot -p”123456” ‘ &gt; /zzyyuse/all-databases.sql 安装 Redis从 docker hub上 (阿里云加速器)拉取 Redis 镜像到本地标签为3.2 使用 Redis 3.2 镜像创建容器(也叫运行镜像)使用镜像 docker run -p 6379:6379 -v /codedragon/myredis/data:/data -v /codedragon/myredis/conf/redis.conf:/usr/local/etc/redis/redis.conf -d redis:3.2 redis-server /usr/local/etc/redis/redis.conf —appendonly yes 在主机 /codedragon/myredis/conf/redis.conf 目录下新建 redis.conf 文件 vim /codedragon/myredis/conf/redis.conf/redis.conf123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961# Redis configuration file example.## Note that in order to read the configuration file, Redis must be# started with the file path as first argument:## ./redis-server /path/to/redis.conf# Note on units: when memory size is needed, it is possible to specify# it in the usual form of 1k 5GB 4M and so forth:## 1k =&gt; 1000 bytes# 1kb =&gt; 1024 bytes# 1m =&gt; 1000000 bytes# 1mb =&gt; 1024*1024 bytes# 1g =&gt; 1000000000 bytes# 1gb =&gt; 1024*1024*1024 bytes## units are case insensitive so 1GB 1Gb 1gB are all the same.################################## INCLUDES #################################### Include one or more other config files here. This is useful if you# have a standard template that goes to all Redis servers but also need# to customize a few per-server settings. Include files can include# other files, so use this wisely.## Notice option &quot;include&quot; won't be rewritten by command &quot;CONFIG REWRITE&quot;# from admin or Redis Sentinel. Since Redis always uses the last processed# line as value of a configuration directive, you'd better put includes# at the beginning of this file to avoid overwriting config change at runtime.## If instead you are interested in using includes to override configuration# options, it is better to use include as the last line.## include /path/to/local.conf# include /path/to/other.conf################################## NETWORK ###################################### By default, if no &quot;bind&quot; configuration directive is specified, Redis listens# for connections from all the network interfaces available on the server.# It is possible to listen to just one or multiple selected interfaces using# the &quot;bind&quot; configuration directive, followed by one or more IP addresses.## Examples:## bind 192.168.1.100 10.0.0.1# bind 127.0.0.1 ::1## ~~~ WARNING ~~~ If the computer running Redis is directly exposed to the# internet, binding to all the interfaces is dangerous and will expose the# instance to everybody on the internet. So by default we uncomment the# following bind directive, that will force Redis to listen only into# the IPv4 lookback interface address (this means Redis will be able to# accept connections only from clients running into the same computer it# is running).## IF YOU ARE SURE YOU WANT YOUR INSTANCE TO LISTEN TO ALL THE INTERFACES# JUST COMMENT THE FOLLOWING LINE.# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#bind 127.0.0.1# Protected mode is a layer of security protection, in order to avoid that# Redis instances left open on the internet are accessed and exploited.## When protected mode is on and if:## 1) The server is not binding explicitly to a set of addresses using the# &quot;bind&quot; directive.# 2) No password is configured.## The server only accepts connections from clients connecting from the# IPv4 and IPv6 loopback addresses 127.0.0.1 and ::1, and from Unix domain# sockets.## By default protected mode is enabled. You should disable it only if# you are sure you want clients from other hosts to connect to Redis# even if no authentication is configured, nor a specific set of interfaces# are explicitly listed using the &quot;bind&quot; directive.protected-mode yes# Accept connections on the specified port, default is 6379 (IANA #815344).# If port 0 is specified Redis will not listen on a TCP socket.port 6379# TCP listen() backlog.## In high requests-per-second environments you need an high backlog in order# to avoid slow clients connections issues. Note that the Linux kernel# will silently truncate it to the value of /proc/sys/net/core/somaxconn so# make sure to raise both the value of somaxconn and tcp_max_syn_backlog# in order to get the desired effect.tcp-backlog 511# Unix socket.## Specify the path for the Unix socket that will be used to listen for# incoming connections. There is no default, so Redis will not listen# on a unix socket when not specified.## unixsocket /tmp/redis.sock# unixsocketperm 700# Close the connection after a client is idle for N seconds (0 to disable)timeout 0# TCP keepalive.## If non-zero, use SO_KEEPALIVE to send TCP ACKs to clients in absence# of communication. This is useful for two reasons:## 1) Detect dead peers.# 2) Take the connection alive from the point of view of network# equipment in the middle.## On Linux, the specified value (in seconds) is the period used to send ACKs.# Note that to close the connection the double of the time is needed.# On other kernels the period depends on the kernel configuration.## A reasonable value for this option is 300 seconds, which is the new# Redis default starting with Redis 3.2.1.tcp-keepalive 300################################# GENERAL ###################################### By default Redis does not run as a daemon. Use 'yes' if you need it.# Note that Redis will write a pid file in /var/run/redis.pid when daemonized.#daemonize no# If you run Redis from upstart or systemd, Redis can interact with your# supervision tree. Options:# supervised no - no supervision interaction# supervised upstart - signal upstart by putting Redis into SIGSTOP mode# supervised systemd - signal systemd by writing READY=1 to $NOTIFY_SOCKET# supervised auto - detect upstart or systemd method based on# UPSTART_JOB or NOTIFY_SOCKET environment variables# Note: these supervision methods only signal &quot;process is ready.&quot;# They do not enable continuous liveness pings back to your supervisor.supervised no# If a pid file is specified, Redis writes it where specified at startup# and removes it at exit.## When the server runs non daemonized, no pid file is created if none is# specified in the configuration. When the server is daemonized, the pid file# is used even if not specified, defaulting to &quot;/var/run/redis.pid&quot;.## Creating a pid file is best effort: if Redis is not able to create it# nothing bad happens, the server will start and run normally.pidfile /var/run/redis_6379.pid# Specify the server verbosity level.# This can be one of:# debug (a lot of information, useful for development/testing)# verbose (many rarely useful info, but not a mess like the debug level)# notice (moderately verbose, what you want in production probably)# warning (only very important / critical messages are logged)loglevel notice# Specify the log file name. Also the empty string can be used to force# Redis to log on the standard output. Note that if you use standard# output for logging but daemonize, logs will be sent to /dev/nulllogfile &quot;&quot;# To enable logging to the system logger, just set 'syslog-enabled' to yes,# and optionally update the other syslog parameters to suit your needs.# syslog-enabled no# Specify the syslog identity.# syslog-ident redis# Specify the syslog facility. Must be USER or between LOCAL0-LOCAL7.# syslog-facility local0# Set the number of databases. The default database is DB 0, you can select# a different one on a per-connection basis using SELECT where# dbid is a number between 0 and 'databases'-1databases 16################################ SNAPSHOTTING ################################## Save the DB on disk:## save ## Will save the DB if both the given number of seconds and the given# number of write operations against the DB occurred.## In the example below the behaviour will be to save:# after 900 sec (15 min) if at least 1 key changed# after 300 sec (5 min) if at least 10 keys changed# after 60 sec if at least 10000 keys changed## Note: you can disable saving completely by commenting out all &quot;save&quot; lines.## It is also possible to remove all the previously configured save# points by adding a save directive with a single empty string argument# like in the following example:## save &quot;&quot;save 120 1save 300 10save 60 10000# By default Redis will stop accepting writes if RDB snapshots are enabled# (at least one save point) and the latest background save failed.# This will make the user aware (in a hard way) that data is not persisting# on disk properly, otherwise chances are that no one will notice and some# disaster will happen.## If the background saving process will start working again Redis will# automatically allow writes again.## However if you have setup your proper monitoring of the Redis server# and persistence, you may want to disable this feature so that Redis will# continue to work as usual even if there are problems with disk,# permissions, and so forth.stop-writes-on-bgsave-error yes# Compress string objects using LZF when dump .rdb databases?# For default that's set to 'yes' as it's almost always a win.# If you want to save some CPU in the saving child set it to 'no' but# the dataset will likely be bigger if you have compressible values or keys.rdbcompression yes# Since version 5 of RDB a CRC64 checksum is placed at the end of the file.# This makes the format more resistant to corruption but there is a performance# hit to pay (around 10%) when saving and loading RDB files, so you can disable it# for maximum performances.## RDB files created with checksum disabled have a checksum of zero that will# tell the loading code to skip the check.rdbchecksum yes# The filename where to dump the DBdbfilename dump.rdb# The working directory.## The DB will be written inside this directory, with the filename specified# above using the 'dbfilename' configuration directive.## The Append Only File will also be created inside this directory.## Note that you must specify a directory here, not a file name.dir ./################################# REPLICATION ################################## Master-Slave replication. Use slaveof to make a Redis instance a copy of# another Redis server. A few things to understand ASAP about Redis replication.## 1) Redis replication is asynchronous, but you can configure a master to# stop accepting writes if it appears to be not connected with at least# a given number of slaves.# 2) Redis slaves are able to perform a partial resynchronization with the# master if the replication link is lost for a relatively small amount of# time. You may want to configure the replication backlog size (see the next# sections of this file) with a sensible value depending on your needs.# 3) Replication is automatic and does not need user intervention. After a# network partition slaves automatically try to reconnect to masters# and resynchronize with them.## slaveof # If the master is password protected (using the &quot;requirepass&quot; configuration# directive below) it is possible to tell the slave to authenticate before# starting the replication synchronization process, otherwise the master will# refuse the slave request.## masterauth # When a slave loses its connection with the master, or when the replication# is still in progress, the slave can act in two different ways:## 1) if slave-serve-stale-data is set to 'yes' (the default) the slave will# still reply to client requests, possibly with out of date data, or the# data set may just be empty if this is the first synchronization.## 2) if slave-serve-stale-data is set to 'no' the slave will reply with# an error &quot;SYNC with master in progress&quot; to all the kind of commands# but to INFO and SLAVEOF.#slave-serve-stale-data yes# You can configure a slave instance to accept writes or not. Writing against# a slave instance may be useful to store some ephemeral data (because data# written on a slave will be easily deleted after resync with the master) but# may also cause problems if clients are writing to it because of a# misconfiguration.## Since Redis 2.6 by default slaves are read-only.## Note: read only slaves are not designed to be exposed to untrusted clients# on the internet. It's just a protection layer against misuse of the instance.# Still a read only slave exports by default all the administrative commands# such as CONFIG, DEBUG, and so forth. To a limited extent you can improve# security of read only slaves using 'rename-command' to shadow all the# administrative / dangerous commands.slave-read-only yes# Replication SYNC strategy: disk or socket.## -------------------------------------------------------# WARNING: DISKLESS REPLICATION IS EXPERIMENTAL CURRENTLY# -------------------------------------------------------## New slaves and reconnecting slaves that are not able to continue the replication# process just receiving differences, need to do what is called a &quot;full# synchronization&quot;. An RDB file is transmitted from the master to the slaves.# The transmission can happen in two different ways:## 1) Disk-backed: The Redis master creates a new process that writes the RDB# file on disk. Later the file is transferred by the parent# process to the slaves incrementally.# 2) Diskless: The Redis master creates a new process that directly writes the# RDB file to slave sockets, without touching the disk at all.## With disk-backed replication, while the RDB file is generated, more slaves# can be queued and served with the RDB file as soon as the current child producing# the RDB file finishes its work. With diskless replication instead once# the transfer starts, new slaves arriving will be queued and a new transfer# will start when the current one terminates.## When diskless replication is used, the master waits a configurable amount of# time (in seconds) before starting the transfer in the hope that multiple slaves# will arrive and the transfer can be parallelized.## With slow disks and fast (large bandwidth) networks, diskless replication# works better.repl-diskless-sync no# When diskless replication is enabled, it is possible to configure the delay# the server waits in order to spawn the child that transfers the RDB via socket# to the slaves.## This is important since once the transfer starts, it is not possible to serve# new slaves arriving, that will be queued for the next RDB transfer, so the server# waits a delay in order to let more slaves arrive.## The delay is specified in seconds, and by default is 5 seconds. To disable# it entirely just set it to 0 seconds and the transfer will start ASAP.repl-diskless-sync-delay 5# Slaves send PINGs to server in a predefined interval. It's possible to change# this interval with the repl_ping_slave_period option. The default value is 10# seconds.## repl-ping-slave-period 10# The following option sets the replication timeout for:## 1) Bulk transfer I/O during SYNC, from the point of view of slave.# 2) Master timeout from the point of view of slaves (data, pings).# 3) Slave timeout from the point of view of masters (REPLCONF ACK pings).## It is important to make sure that this value is greater than the value# specified for repl-ping-slave-period otherwise a timeout will be detected# every time there is low traffic between the master and the slave.## repl-timeout 60# Disable TCP_NODELAY on the slave socket after SYNC?## If you select &quot;yes&quot; Redis will use a smaller number of TCP packets and# less bandwidth to send data to slaves. But this can add a delay for# the data to appear on the slave side, up to 40 milliseconds with# Linux kernels using a default configuration.## If you select &quot;no&quot; the delay for data to appear on the slave side will# be reduced but more bandwidth will be used for replication.## By default we optimize for low latency, but in very high traffic conditions# or when the master and slaves are many hops away, turning this to &quot;yes&quot; may# be a good idea.repl-disable-tcp-nodelay no# Set the replication backlog size. The backlog is a buffer that accumulates# slave data when slaves are disconnected for some time, so that when a slave# wants to reconnect again, often a full resync is not needed, but a partial# resync is enough, just passing the portion of data the slave missed while# disconnected.## The bigger the replication backlog, the longer the time the slave can be# disconnected and later be able to perform a partial resynchronization.## The backlog is only allocated once there is at least a slave connected.## repl-backlog-size 1mb# After a master has no longer connected slaves for some time, the backlog# will be freed. The following option configures the amount of seconds that# need to elapse, starting from the time the last slave disconnected, for# the backlog buffer to be freed.## A value of 0 means to never release the backlog.## repl-backlog-ttl 3600# The slave priority is an integer number published by Redis in the INFO output.# It is used by Redis Sentinel in order to select a slave to promote into a# master if the master is no longer working correctly.## A slave with a low priority number is considered better for promotion, so# for instance if there are three slaves with priority 10, 100, 25 Sentinel will# pick the one with priority 10, that is the lowest.## However a special priority of 0 marks the slave as not able to perform the# role of master, so a slave with priority of 0 will never be selected by# Redis Sentinel for promotion.## By default the priority is 100.slave-priority 100# It is possible for a master to stop accepting writes if there are less than# N slaves connected, having a lag less or equal than M seconds.## The N slaves need to be in &quot;online&quot; state.## The lag in seconds, that must be # the last ping received from the slave, that is usually sent every second.## This option does not GUARANTEE that N replicas will accept the write, but# will limit the window of exposure for lost writes in case not enough slaves# are available, to the specified number of seconds.## For example to require at least 3 slaves with a lag ## min-slaves-to-write 3# min-slaves-max-lag 10## Setting one or the other to 0 disables the feature.## By default min-slaves-to-write is set to 0 (feature disabled) and# min-slaves-max-lag is set to 10.# A Redis master is able to list the address and port of the attached# slaves in different ways. For example the &quot;INFO replication&quot; section# offers this information, which is used, among other tools, by# Redis Sentinel in order to discover slave instances.# Another place where this info is available is in the output of the# &quot;ROLE&quot; command of a masteer.## The listed IP and address normally reported by a slave is obtained# in the following way:## IP: The address is auto detected by checking the peer address# of the socket used by the slave to connect with the master.## Port: The port is communicated by the slave during the replication# handshake, and is normally the port that the slave is using to# list for connections.## However when port forwarding or Network Address Translation (NAT) is# used, the slave may be actually reachable via different IP and port# pairs. The following two options can be used by a slave in order to# report to its master a specific set of IP and port, so that both INFO# and ROLE will report those values.## There is no need to use both the options if you need to override just# the port or the IP address.## slave-announce-ip 5.5.5.5# slave-announce-port 1234################################## SECURITY #################################### Require clients to issue AUTH before processing any other# commands. This might be useful in environments in which you do not trust# others with access to the host running redis-server.## This should stay commented out for backward compatibility and because most# people do not need auth (e.g. they run their own servers).## Warning: since Redis is pretty fast an outside user can try up to# 150k passwords per second against a good box. This means that you should# use a very strong password otherwise it will be very easy to break.## requirepass foobared# Command renaming.## It is possible to change the name of dangerous commands in a shared# environment. For instance the CONFIG command may be renamed into something# hard to guess so that it will still be available for internal-use tools# but not available for general clients.## Example:## rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52## It is also possible to completely kill a command by renaming it into# an empty string:## rename-command CONFIG &quot;&quot;## Please note that changing the name of commands that are logged into the# AOF file or transmitted to slaves may cause problems.################################### LIMITS ##################################### Set the max number of connected clients at the same time. By default# this limit is set to 10000 clients, however if the Redis server is not# able to configure the process file limit to allow for the specified limit# the max number of allowed clients is set to the current file limit# minus 32 (as Redis reserves a few file descriptors for internal uses).## Once the limit is reached Redis will close all the new connections sending# an error 'max number of clients reached'.## maxclients 10000# Don't use more memory than the specified amount of bytes.# When the memory limit is reached Redis will try to remove keys# according to the eviction policy selected (see maxmemory-policy).## If Redis can't remove keys according to the policy, or if the policy is# set to 'noeviction', Redis will start to reply with errors to commands# that would use more memory, like SET, LPUSH, and so on, and will continue# to reply to read-only commands like GET.## This option is usually useful when using Redis as an LRU cache, or to set# a hard memory limit for an instance (using the 'noeviction' policy).## WARNING: If you have slaves attached to an instance with maxmemory on,# the size of the output buffers needed to feed the slaves are subtracted# from the used memory count, so that network problems / resyncs will# not trigger a loop where keys are evicted, and in turn the output# buffer of slaves is full with DELs of keys evicted triggering the deletion# of more keys, and so forth until the database is completely emptied.## In short... if you have slaves attached it is suggested that you set a lower# limit for maxmemory so that there is some free RAM on the system for slave# output buffers (but this is not needed if the policy is 'noeviction').## maxmemory # MAXMEMORY POLICY: how Redis will select what to remove when maxmemory# is reached. You can select among five behaviors:## volatile-lru -&gt; remove the key with an expire set using an LRU algorithm# allkeys-lru -&gt; remove any key according to the LRU algorithm# volatile-random -&gt; remove a random key with an expire set# allkeys-random -&gt; remove a random key, any key# volatile-ttl -&gt; remove the key with the nearest expire time (minor TTL)# noeviction -&gt; don't expire at all, just return an error on write operations## Note: with any of the above policies, Redis will return an error on write# operations, when there are no suitable keys for eviction.## At the date of writing these commands are: set setnx setex append# incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd# sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby# zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby# getset mset msetnx exec sort## The default is:## maxmemory-policy noeviction# LRU and minimal TTL algorithms are not precise algorithms but approximated# algorithms (in order to save memory), so you can tune it for speed or# accuracy. For default Redis will check five keys and pick the one that was# used less recently, you can change the sample size using the following# configuration directive.## The default of 5 produces good enough results. 10 Approximates very closely# true LRU but costs a bit more CPU. 3 is very fast but not very accurate.## maxmemory-samples 5############################## APPEND ONLY MODE ################################ By default Redis asynchronously dumps the dataset on disk. This mode is# good enough in many applications, but an issue with the Redis process or# a power outage may result into a few minutes of writes lost (depending on# the configured save points).## The Append Only File is an alternative persistence mode that provides# much better durability. For instance using the default data fsync policy# (see later in the config file) Redis can lose just one second of writes in a# dramatic event like a server power outage, or a single write if something# wrong with the Redis process itself happens, but the operating system is# still running correctly.## AOF and RDB persistence can be enabled at the same time without problems.# If the AOF is enabled on startup Redis will load the AOF, that is the file# with the better durability guarantees.## Please check http://redis.io/topics/persistence for more information.appendonly no# The name of the append only file (default: &quot;appendonly.aof&quot;)appendfilename &quot;appendonly.aof&quot;# The fsync() call tells the Operating System to actually write data on disk# instead of waiting for more data in the output buffer. Some OS will really flush# data on disk, some other OS will just try to do it ASAP.## Redis supports three different modes:## no: don't fsync, just let the OS flush the data when it wants. Faster.# always: fsync after every write to the append only log. Slow, Safest.# everysec: fsync only one time every second. Compromise.## The default is &quot;everysec&quot;, as that's usually the right compromise between# speed and data safety. It's up to you to understand if you can relax this to# &quot;no&quot; that will let the operating system flush the output buffer when# it wants, for better performances (but if you can live with the idea of# some data loss consider the default persistence mode that's snapshotting),# or on the contrary, use &quot;always&quot; that's very slow but a bit safer than# everysec.## More details please check the following article:# http://antirez.com/post/redis-persistence-demystified.html## If unsure, use &quot;everysec&quot;.# appendfsync alwaysappendfsync everysec# appendfsync no# When the AOF fsync policy is set to always or everysec, and a background# saving process (a background save or AOF log background rewriting) is# performing a lot of I/O against the disk, in some Linux configurations# Redis may block too long on the fsync() call. Note that there is no fix for# this currently, as even performing fsync in a different thread will block# our synchronous write(2) call.## In order to mitigate this problem it's possible to use the following option# that will prevent fsync() from being called in the main process while a# BGSAVE or BGREWRITEAOF is in progress.## This means that while another child is saving, the durability of Redis is# the same as &quot;appendfsync none&quot;. In practical terms, this means that it is# possible to lose up to 30 seconds of log in the worst scenario (with the# default Linux settings).## If you have latency problems turn this to &quot;yes&quot;. Otherwise leave it as# &quot;no&quot; that is the safest pick from the point of view of durability.no-appendfsync-on-rewrite no# Automatic rewrite of the append only file.# Redis is able to automatically rewrite the log file implicitly calling# BGREWRITEAOF when the AOF log size grows by the specified percentage.## This is how it works: Redis remembers the size of the AOF file after the# latest rewrite (if no rewrite has happened since the restart, the size of# the AOF at startup is used).## This base size is compared to the current size. If the current size is# bigger than the specified percentage, the rewrite is triggered. Also# you need to specify a minimal size for the AOF file to be rewritten, this# is useful to avoid rewriting the AOF file even if the percentage increase# is reached but it is still pretty small.## Specify a percentage of zero in order to disable the automatic AOF# rewrite feature.auto-aof-rewrite-percentage 100auto-aof-rewrite-min-size 64mb# An AOF file may be found to be truncated at the end during the Redis# startup process, when the AOF data gets loaded back into memory.# This may happen when the system where Redis is running# crashes, especially when an ext4 filesystem is mounted without the# data=ordered option (however this can't happen when Redis itself# crashes or aborts but the operating system still works correctly).## Redis can either exit with an error when this happens, or load as much# data as possible (the default now) and start if the AOF file is found# to be truncated at the end. The following option controls this behavior.## If aof-load-truncated is set to yes, a truncated AOF file is loaded and# the Redis server starts emitting a log to inform the user of the event.# Otherwise if the option is set to no, the server aborts with an error# and refuses to start. When the option is set to no, the user requires# to fix the AOF file using the &quot;redis-check-aof&quot; utility before to restart# the server.## Note that if the AOF file will be found to be corrupted in the middle# the server will still exit with an error. This option only applies when# Redis will try to read more data from the AOF file but not enough bytes# will be found.aof-load-truncated yes################################ LUA SCRIPTING ################################ Max execution time of a Lua script in milliseconds.## If the maximum execution time is reached Redis will log that a script is# still in execution after the maximum allowed time and will start to# reply to queries with an error.## When a long running script exceeds the maximum execution time only the# SCRIPT KILL and SHUTDOWN NOSAVE commands are available. The first can be# used to stop a script that did not yet called write commands. The second# is the only way to shut down the server in the case a write command was# already issued by the script but the user doesn't want to wait for the natural# termination of the script.## Set it to 0 or a negative value for unlimited execution without warnings.lua-time-limit 5000################################ REDIS CLUSTER ################################# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++# WARNING EXPERIMENTAL: Redis Cluster is considered to be stable code, however# in order to mark it as &quot;mature&quot; we need to wait for a non trivial percentage# of users to deploy it in production.# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++## Normal Redis instances can't be part of a Redis Cluster; only nodes that are# started as cluster nodes can. In order to start a Redis instance as a# cluster node enable the cluster support uncommenting the following:## cluster-enabled yes# Every cluster node has a cluster configuration file. This file is not# intended to be edited by hand. It is created and updated by Redis nodes.# Every Redis Cluster node requires a different cluster configuration file.# Make sure that instances running in the same system do not have# overlapping cluster configuration file names.## cluster-config-file nodes-6379.conf# Cluster node timeout is the amount of milliseconds a node must be unreachable# for it to be considered in failure state.# Most other internal time limits are multiple of the node timeout.## cluster-node-timeout 15000# A slave of a failing master will avoid to start a failover if its data# looks too old.## There is no simple way for a slave to actually have a exact measure of# its &quot;data age&quot;, so the following two checks are performed:## 1) If there are multiple slaves able to failover, they exchange messages# in order to try to give an advantage to the slave with the best# replication offset (more data from the master processed).# Slaves will try to get their rank by offset, and apply to the start# of the failover a delay proportional to their rank.## 2) Every single slave computes the time of the last interaction with# its master. This can be the last ping or command received (if the master# is still in the &quot;connected&quot; state), or the time that elapsed since the# disconnection with the master (if the replication link is currently down).# If the last interaction is too old, the slave will not try to failover# at all.## The point &quot;2&quot; can be tuned by user. Specifically a slave will not perform# the failover if, since the last interaction with the master, the time# elapsed is greater than:## (node-timeout * slave-validity-factor) + repl-ping-slave-period## So for example if node-timeout is 30 seconds, and the slave-validity-factor# is 10, and assuming a default repl-ping-slave-period of 10 seconds, the# slave will not try to failover if it was not able to talk with the master# for longer than 310 seconds.## A large slave-validity-factor may allow slaves with too old data to failover# a master, while a too small value may prevent the cluster from being able to# elect a slave at all.## For maximum availability, it is possible to set the slave-validity-factor# to a value of 0, which means, that slaves will always try to failover the# master regardless of the last time they interacted with the master.# (However they'll always try to apply a delay proportional to their# offset rank).## Zero is the only value able to guarantee that when all the partitions heal# the cluster will always be able to continue.## cluster-slave-validity-factor 10# Cluster slaves are able to migrate to orphaned masters, that are masters# that are left without working slaves. This improves the cluster ability# to resist to failures as otherwise an orphaned master can't be failed over# in case of failure if it has no working slaves.## Slaves migrate to orphaned masters only if there are still at least a# given number of other working slaves for their old master. This number# is the &quot;migration barrier&quot;. A migration barrier of 1 means that a slave# will migrate only if there is at least 1 other working slave for its master# and so forth. It usually reflects the number of slaves you want for every# master in your cluster.## Default is 1 (slaves migrate only if their masters remain with at least# one slave). To disable migration just set it to a very large value.# A value of 0 can be set but is useful only for debugging and dangerous# in production.## cluster-migration-barrier 1# By default Redis Cluster nodes stop accepting queries if they detect there# is at least an hash slot uncovered (no available node is serving it).# This way if the cluster is partially down (for example a range of hash slots# are no longer covered) all the cluster becomes, eventually, unavailable.# It automatically returns available as soon as all the slots are covered again.## However sometimes you want the subset of the cluster which is working,# to continue to accept queries for the part of the key space that is still# covered. In order to do so, just set the cluster-require-full-coverage# option to no.## cluster-require-full-coverage yes# In order to setup your cluster make sure to read the documentation# available at http://redis.io web site.################################## SLOW LOG #################################### The Redis Slow Log is a system to log queries that exceeded a specified# execution time. The execution time does not include the I/O operations# like talking with the client, sending the reply and so forth,# but just the time needed to actually execute the command (this is the only# stage of command execution where the thread is blocked and can not serve# other requests in the meantime).## You can configure the slow log with two parameters: one tells Redis# what is the execution time, in microseconds, to exceed in order for the# command to get logged, and the other parameter is the length of the# slow log. When a new command is logged the oldest one is removed from the# queue of logged commands.# The following time is expressed in microseconds, so 1000000 is equivalent# to one second. Note that a negative number disables the slow log, while# a value of zero forces the logging of every command.slowlog-log-slower-than 10000# There is no limit to this length. Just be aware that it will consume memory.# You can reclaim memory used by the slow log with SLOWLOG RESET.slowlog-max-len 128################################ LATENCY MONITOR ############################### The Redis latency monitoring subsystem samples different operations# at runtime in order to collect data related to possible sources of# latency of a Redis instance.## Via the LATENCY command this information is available to the user that can# print graphs and obtain reports.## The system only logs operations that were performed in a time equal or# greater than the amount of milliseconds specified via the# latency-monitor-threshold configuration directive. When its value is set# to zero, the latency monitor is turned off.## By default latency monitoring is disabled since it is mostly not needed# if you don't have latency issues, and collecting data has a performance# impact, that while very small, can be measured under big load. Latency# monitoring can easily be enabled at runtime using the command# &quot;CONFIG SET latency-monitor-threshold &quot; if needed.latency-monitor-threshold 0############################# EVENT NOTIFICATION ############################### Redis can notify Pub/Sub clients about events happening in the key space.# This feature is documented at http://redis.io/topics/notifications## For instance if keyspace events notification is enabled, and a client# performs a DEL operation on key &quot;foo&quot; stored in the Database 0, two# messages will be published via Pub/Sub:## PUBLISH __keyspace@0__:foo del# PUBLISH __keyevent@0__:del foo## It is possible to select the events that Redis will notify among a set# of classes. Every class is identified by a single character:## K Keyspace events, published with __keyspace@__ prefix.# E Keyevent events, published with __keyevent@__ prefix.# g Generic commands (non-type specific) like DEL, EXPIRE, RENAME, ...# $ String commands# l List commands# s Set commands# h Hash commands# z Sorted set commands# x Expired events (events generated every time a key expires)# e Evicted events (events generated when a key is evicted for maxmemory)# A Alias for g$lshzxe, so that the &quot;AKE&quot; string means all the events.## The &quot;notify-keyspace-events&quot; takes as argument a string that is composed# of zero or multiple characters. The empty string means that notifications# are disabled.## Example: to enable list and generic events, from the point of view of the# event name, use:## notify-keyspace-events Elg## Example 2: to get the stream of the expired keys subscribing to channel# name __keyevent@0__:expired use:## notify-keyspace-events Ex## By default all notifications are disabled because most users don't need# this feature and the feature has some overhead. Note that if you don't# specify at least one of K or E, no events will be delivered.notify-keyspace-events &quot;&quot;############################### ADVANCED CONFIG ################################ Hashes are encoded using a memory efficient data structure when they have a# small number of entries, and the biggest entry does not exceed a given# threshold. These thresholds can be configured using the following directives.hash-max-ziplist-entries 512hash-max-ziplist-value 64# Lists are also encoded in a special way to save a lot of space.# The number of entries allowed per internal list node can be specified# as a fixed maximum size or a maximum number of elements.# For a fixed maximum size, use -5 through -1, meaning:# -5: max size: 64 Kb # -4: max size: 32 Kb # -3: max size: 16 Kb # -2: max size: 8 Kb # -1: max size: 4 Kb # Positive numbers mean store up to _exactly_ that number of elements# per list node.# The highest performing option is usually -2 (8 Kb size) or -1 (4 Kb size),# but if your use case is unique, adjust the settings as necessary.list-max-ziplist-size -2# Lists may also be compressed.# Compress depth is the number of quicklist ziplist nodes from *each* side of# the list to *exclude* from compression. The head and tail of the list# are always uncompressed for fast push/pop operations. Settings are:# 0: disable all list compression# 1: depth 1 means &quot;don't start compressing until after 1 node into the list,# going from either the head or tail&quot;# So: [head]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[tail]# [head], [tail] will always be uncompressed; inner nodes will compress.# 2: [head]-&gt;[next]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[prev]-&gt;[tail]# 2 here means: don't compress head or head-&gt;next or tail-&gt;prev or tail,# but compress all nodes between them.# 3: [head]-&gt;[next]-&gt;[next]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[prev]-&gt;[prev]-&gt;[tail]# etc.list-compress-depth 0# Sets have a special encoding in just one case: when a set is composed# of just strings that happen to be integers in radix 10 in the range# of 64 bit signed integers.# The following configuration setting sets the limit in the size of the# set in order to use this special memory saving encoding.set-max-intset-entries 512# Similarly to hashes and lists, sorted sets are also specially encoded in# order to save a lot of space. This encoding is only used when the length and# elements of a sorted set are below the following limits:zset-max-ziplist-entries 128zset-max-ziplist-value 64# HyperLogLog sparse representation bytes limit. The limit includes the# 16 bytes header. When an HyperLogLog using the sparse representation crosses# this limit, it is converted into the dense representation.## A value greater than 16000 is totally useless, since at that point the# dense representation is more memory efficient.## The suggested value is ~ 3000 in order to have the benefits of# the space efficient encoding without slowing down too much PFADD,# which is O(N) with the sparse encoding. The value can be raised to# ~ 10000 when CPU is not a concern, but space is, and the data set is# composed of many HyperLogLogs with cardinality in the 0 - 15000 range.hll-sparse-max-bytes 3000# Active rehashing uses 1 millisecond every 100 milliseconds of CPU time in# order to help rehashing the main Redis hash table (the one mapping top-level# keys to values). The hash table implementation Redis uses (see dict.c)# performs a lazy rehashing: the more operation you run into a hash table# that is rehashing, the more rehashing &quot;steps&quot; are performed, so if the# server is idle the rehashing is never complete and some more memory is used# by the hash table.## The default is to use this millisecond 10 times every second in order to# actively rehash the main dictionaries, freeing memory when possible.## If unsure:# use &quot;activerehashing no&quot; if you have hard latency requirements and it is# not a good thing in your environment that Redis can reply from time to time# to queries with 2 milliseconds delay.## use &quot;activerehashing yes&quot; if you don't have such hard requirements but# want to free memory asap when possible.activerehashing yes# The client output buffer limits can be used to force disconnection of clients# that are not reading data from the server fast enough for some reason (a# common reason is that a Pub/Sub client can't consume messages as fast as the# publisher can produce them).## The limit can be set differently for the three different classes of clients:## normal -&gt; normal clients including MONITOR clients# slave -&gt; slave clients# pubsub -&gt; clients subscribed to at least one pubsub channel or pattern## The syntax of every client-output-buffer-limit directive is the following:## client-output-buffer-limit ## A client is immediately disconnected once the hard limit is reached, or if# the soft limit is reached and remains reached for the specified number of# seconds (continuously).# So for instance if the hard limit is 32 megabytes and the soft limit is# 16 megabytes / 10 seconds, the client will get disconnected immediately# if the size of the output buffers reach 32 megabytes, but will also get# disconnected if the client reaches 16 megabytes and continuously overcomes# the limit for 10 seconds.## By default normal clients are not limited because they don't receive data# without asking (in a push way), but just after a request, so only# asynchronous clients may create a scenario where data is requested faster# than it can read.## Instead there is a default limit for pubsub and slave clients, since# subscribers and slaves receive data in a push fashion.## Both the hard or the soft limit can be disabled by setting them to zero.client-output-buffer-limit normal 0 0 0client-output-buffer-limit slave 256mb 64mb 60client-output-buffer-limit pubsub 32mb 8mb 60# Redis calls an internal function to perform many background tasks, like# closing connections of clients in timeout, purging expired keys that are# never requested, and so forth.## Not all tasks are performed with the same frequency, but Redis checks for# tasks to perform according to the specified &quot;hz&quot; value.## By default &quot;hz&quot; is set to 10. Raising the value will use more CPU when# Redis is idle, but at the same time will make Redis more responsive when# there are many keys expiring at the same time, and timeouts may be# handled with more precision.## The range is between 1 and 500, however a value over 100 is usually not# a good idea. Most users should use the default of 10 and raise this up to# 100 only in environments where very low latency is required.hz 10# When a child rewrites the AOF file, if the following option is enabled# the file will be fsync-ed every 32 MB of data generated. This is useful# in order to commit the file to the disk more incrementally and avoid# big latency spikes.aof-rewrite-incremental-fsync yes 测试 redis-cli 连接上来 docker exec -it 运行着 Redis 服务的容器ID redis-cli 测试持久化文件生成","link":"/2020/11/09/Docker/7.Docker%E5%B8%B8%E7%94%A8%E5%AE%89%E8%A3%85/"},{"title":"Docker&#x2F;8.本地镜像发布到阿里云","text":"本地镜像发布到阿里云本地镜像发布到阿里云流程 镜像的生成方法 前面的 DockerFile 从容器创建一个新的镜像 docker commit [OPTIONS] 容器ID [REPOSITORY[:TAG]] OPTIONS说明： -a :提交的镜像作者； -m :提交时的说明文字； 将本地镜像推送到阿里云 本地镜像素材原型 阿里云开发者平台：https://dev.aliyun.com/search.html 创建仓库镜像：命名空间、仓库名称 将镜像推送到 registry 公有云可以查询到 查看详情 将阿里云上的镜像下载到本地","link":"/2020/11/09/Docker/8.%E6%9C%AC%E5%9C%B0%E9%95%9C%E5%83%8F%E5%8F%91%E5%B8%83%E5%88%B0%E9%98%BF%E9%87%8C%E4%BA%91/"},{"title":"IDEA使用技巧&#x2F;IDEA热部署","text":"在 File -&gt; Settings -&gt; Build, Execution, Deployment -&gt; Compiler 中勾选 Build project automatically，如下图所示 同时按住 Ctrl + Shift + Alt + / 进入Registry，同时勾选以下三项 开启热部署策略，在Edit Configurations中选择运行策略 引入pom依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 最后需要关闭浏览器缓存，如下图","link":"/2020/07/06/IDEA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/IDEA%E7%83%AD%E9%83%A8%E7%BD%B2/"},{"title":"Spring框架&#x2F;Spring+SpringMVC+MyBatis整合","text":"此次SSM整合基于黑马教程SSM整合基于黑马教程（使用druid连接池） 创建一个带web的Maven工程，基于JDK 1.8，这里就不赘述； 引入Maven依赖，此次主要用到的有Spring家族 5.2.6 版本、MyBatis 3.5.4 版本、MyBatis-Spring 2.0.4版本、Druid数据库连接池、MySQL驱动、Servlet、JSTL等，具体如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;5.2.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.2.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.2.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.22&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.20&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.30&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;5.2.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.6.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建基础Controller层、Service层、Dao层和Domain层； Account实体类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import java.io.Serializable;import java.util.Objects;public class Account implements Serializable { private Integer id; private String name; private Double money; public Account() { } public Account(Integer id, String name, Double money) { this.id = id; this.name = name; this.money = money; } @Override public String toString() { return \"Account{\" + \"id=\" + id + \", name='\" + name + '\\'' + \", money=\" + money + '}'; } @Override public boolean equals(Object o) { if (this == o) return true; if (!(o instanceof Account)) return false; Account account = (Account) o; return Objects.equals(getId(), account.getId()) &amp;&amp; Objects.equals(getName(), account.getName()) &amp;&amp; Objects.equals(getMoney(), account.getMoney()); } @Override public int hashCode() { return Objects.hash(getId(), getName(), getMoney()); } public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Double getMoney() { return money; } public void setMoney(Double money) { this.money = money; }} 这里可以使用 Lombok 化简过程。 AccountService 接口 1234567891011import cn.itcast.domain.Account;import java.util.List;public interface AccountService { //查询数据库所有数据 List&lt;Account&gt; findAll(); //存储指定 Account 类型数据 void saveAccount(Account account);} AccountServiceImpl 实现类 123456789101112131415161718//这里需要添加Service注解，括号里面可以起别名@Service(\"accountService\")public class AccountServiceImpl implements AccountService { //使用 Autowired 自动注入 @Autowired private AccountDao accountDao; public List&lt;Account&gt; findAll() { System.out.println(\"业务层，查询所有账户\"); return accountDao.findAll() ; } public void saveAccount(Account account) { System.out.println(\"业务层：保存账户\"); accountDao.saveAccount(account); }} AccountDao 操作数据库接口 123456789101112131415import cn.itcast.domain.Account;import org.apache.ibatis.annotations.Insert;import org.apache.ibatis.annotations.Select;import org.springframework.stereotype.Repository;import java.util.List;@Repositorypublic interface AccountDao { @Select(\"select * from account\") List&lt;Account&gt; findAll(); @Insert(\"insert into account (name, money) values(#{name},#{money})\") void saveAccount(Account account);} AccountController 123456789101112131415161718192021222324import cn.itcast.domain.Account;import cn.itcast.service.AccountService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import java.util.List;@Controller@RequestMapping(\"/account\")public class AccountController { @Autowired private AccountService accountService; @RequestMapping(\"/findAll\") public String findAll(Model model){ System.out.println(\"表现层：查询所有账户\"); List&lt;Account&gt; list = accountService.findAll(); model.addAttribute(\"list\", list); return \"list\"; }} 创建数据库和account表 1234567create table account( id int auto_increment primary key, name varchar(20) null, money double null); 添加如下测试数据： 配置 web.xml 文件 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app version=\"2.4\" xmlns=\"http://java.sun.com/xml/ns/j2ee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd\"&gt;&lt;!--Spring监听器，默认只加载WEB-INF目录下的applicationContext.xml配置文件--&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;&lt;!-- 设置配置文件路径--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt;&lt;!--SpringMVC前端控制器--&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;!-- 解决中文乱码--&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 配置 applicationContext.xml(Spring 配置文件) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!--开启注解扫描,controller不需要Spring处理--&gt; &lt;context:component-scan base-package=\"cn.itcast\"&gt; &lt;context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/&gt; &lt;/context:component-scan&gt; &lt;!-- Spring整合MyBatis框架--&gt; &lt;!-- 配置连接池--&gt; &lt;bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\"&gt; &lt;!-- 基本属性 url、user、password --&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/ssm\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"3570\"/&gt; &lt;!-- 配置初始化大小、最小、最大 --&gt; &lt;property name=\"initialSize\" value=\"1\"/&gt; &lt;property name=\"minIdle\" value=\"3\"/&gt; &lt;property name=\"maxActive\" value=\"20\"/&gt; &lt;!-- 配置获取连接等待超时的时间 --&gt; &lt;property name=\"maxWait\" value=\"60000\"/&gt; &lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt; &lt;property name=\"timeBetweenEvictionRunsMillis\" value=\"60000\"/&gt; &lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt; &lt;property name=\"minEvictableIdleTimeMillis\" value=\"300000\"/&gt; &lt;/bean&gt; &lt;!-- 配置SqlSessionFactory工厂--&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;/bean&gt; &lt;!-- 配置AccountDao接口--&gt; &lt;bean id=\"mapperScanner\" class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"basePackage\" value=\"cn.itcast.dao\"/&gt; &lt;/bean&gt; &lt;!--配置Spring框架声明式事务管理--&gt; &lt;!--1. 配置事务管理器--&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;/bean&gt; &lt;!-- 2. 配置事务属性 --&gt; &lt;!--&lt;tx:advice&gt;元素声明事务通知--&gt; &lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt; &lt;tx:attributes&gt; &lt;!-- 根据方法名指定事务的属性 --&gt; &lt;tx:method name=\"*\"/&gt; &lt;!--propagation配置事务传播行为--&gt; &lt;tx:method name=\"purchase\" propagation=\"REQUIRES_NEW\"/&gt; &lt;!--isolation配置事务的隔离级别--&gt; &lt;tx:method name=\"update*\" isolation=\"SERIALIZABLE\"/&gt; &lt;!--rollback-for配置事务遇到异常必须回滚，no-rollback-for配置事务遇到异常必须不能回滚--&gt; &lt;tx:method name=\"add*\" rollback-for=\"java.io.IOException\" no-rollback-for=\"com.dmsd.spring.tx.BookStockException\"/&gt; &lt;!--read-only配置事务只读属性--&gt; &lt;tx:method name=\"find*\" read-only=\"true\"/&gt; &lt;!--timeout配置事务的超时属性--&gt; &lt;tx:method name=\"get*\" timeout=\"3\"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 3. 配置事务切入点, 以及把事务切入点和事务属性关联起来 --&gt; &lt;aop:config&gt; &lt;aop:pointcut expression=\"execution(* cn.itcast.service.*.*(..))\" id=\"txPointCut\"/&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"txPointCut\"/&gt; &lt;/aop:config&gt;&lt;/beans&gt; 配置 springmvc.xml (SpringMVC配置文件) 1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;!--开启注解扫描--&gt; &lt;context:component-scan base-package=\"cn.itcast\"&gt; &lt;context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/&gt; &lt;/context:component-scan&gt; &lt;!-- 配置视图解析器--&gt; &lt;bean id=\"internalResourceViewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/pages/\"/&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt; &lt;!-- 过滤静态资源--&gt; &lt;mvc:resources location=\"/css/\" mapping=\"/css/**\"/&gt; &lt;mvc:resources location=\"/images/\" mapping=\"/images/**\"/&gt; &lt;mvc:resources location=\"/js/\" mapping=\"/js/**\"/&gt; &lt;!-- 开启springmvc注解支持--&gt; &lt;mvc:annotation-driven/&gt;&lt;/beans&gt; 创建JSP页面 index.jsp 12345678910111213141516171819202122&lt;%-- Created by IntelliJ IDEA. User: sxl Date: 2020/5/30 Time: 22:05 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;a href=\"account/findAll\"&gt;测试&lt;/a&gt;&lt;h3&gt;测试保存&lt;/h3&gt;&lt;form action=\"/account/save\" method=\"post\"&gt; 姓名：&lt;input type=\"text\" name=\"name\"/&gt;&lt;br&gt; 金额：&lt;input type=\"text\" name=\"money\"/&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"保存\"&gt;&lt;br&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; list.jsp 1234567891011121314151617181920&lt;%-- Created by IntelliJ IDEA. User: sxl Date: 2020/5/30 Time: 22:07 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" isELIgnored=\"false\" %&gt;&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;查询所有账户信息&lt;/h3&gt; &lt;c:forEach items=\"${list}\" var=\"account\"&gt; ${account.name} &lt;/c:forEach&gt;&lt;/body&gt;&lt;/html&gt; 配置 Tomcat 服务器，配置如下图所示： 配置完成后目录结构如下图所示： 启动服务器，测试查询和保存功能，页面显示出 数据库中用户信息则证明整合成功。","link":"/2020/06/01/Spring%E6%A1%86%E6%9E%B6/Spring+SpringMVC+MyBatis%E6%95%B4%E5%90%88/"},{"title":"图解机器学习&#x2F;第一章 什么是机器学习","text":"学习的种类 监督学习 是指学生从老师那里获取知识、信息，老师提供对错指示、告知最终答案的学习过程。这一类机器学习的典型任务包括：预测数值型数据的回归、预测分类标签的分类、预测顺序的排序等。 无监督学习 是指在没有老师的情况下，学生自学的过程。这一类机器学习的典型任务包括：聚类、异常检测等。 强化学习 是指在没有老师提示的情况下，自己对预测的结果进行评估的方法。这一类机器学习的典型任务包括：回归、分类、聚类和降维等。 机器学习任务的例子 回归（连续） 是指把实函数在样本点附近加以近似的有监督的函数近似问题。 分类（离散） 是指对于指定的模式进行识别的有监督的模式识别问题。 异常检测 是指寻找输入样本$\\lbrace x_i \\rbrace_{i=1}^n$中所包含的异常数据的问题。在已知正常数据与异常数据的例子的情况下， 其与有监督的分类问题是相同的。 聚类 与分类问题相同，也是模式识别问题，但是属于无监督学习的一种。 降维 是指从高纬度数据中提取关键信息，将其转换为易于计算的低纬度问题进而求解的方法。降维根据数据种类的不同，可以分为监督学习和无监督学习。 机器学习的方法生成的分类和识别的分类&emsp;在已知模式$x$的时候，如果能求得使分类类别$y$的条件概率$p(y|x)$达到最大值的类别$\\hat{y}$的话，就可以进行模式识别了。 \\hat{y}=\\mathop{argmax}_y p(y|x)其中，$”argmax”$是取得最大值时的参数的意思，条件概率$p(y|x)$通常也称为后验概率，联合概率$p(x,y)$也称为数据生成概率，通过预测数据生成概率$p(x,y)$来进行模式识别的分类方法，称为生成的分类。 &emsp;应用训练集直接对后验概率$p(y|x)$进行学习的过程，称为判别式分类 统计概率和朴素贝叶斯&emsp;在统计概率的机器学习方法中，将模式$\\theta$作为决定论的变量，使用手头的训练样本$\\mathcal{D}=\\lbrace (x_i,y_i) \\rbrace_{i=1}^n$对模式$\\theta$进行学习，如何由训练集$\\mathcal{D}$得到高精度的模式$\\theta$是主要的研究课题。 &emsp;在朴素贝叶斯方法中，将模式$\\theta$作为概率变量，对其先验概率$p(\\theta)$加以考虑，计算与训练集$\\mathcal{D}$相对应的后验概率$p(\\theta|\\mathcal{D})$。通过运用贝叶斯定理，就可以使用先验概率$p(\\theta)$来求解后验概率$p(\\theta|\\mathcal{D})$，如下所示： p(\\theta|\\mathcal{D}) = \\frac{p(\\mathcal{D}|\\theta) p(\\theta)}{p(\\mathcal{D})}=\\frac{\\prod_{i=1}^n q(x_i,y_i|\\theta)p(\\theta)}{\\int \\prod_{i=1}^n q(x_i,y_i|\\theta)p(\\theta) d\\theta}在朴素贝叶斯算法中，如何精确的计算后验概率是一个主要的研究课题。","link":"/2020/05/09/%E5%9B%BE%E8%A7%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"title":"图解机器学习&#x2F;第七章 基于最小二乘法的分类","text":"模式识别是指，对于输入的模式$x \\in \\mathbb{R}^d$，将其分类到它所属的类别$y \\in \\lbrace 1,\\dots,c \\rbrace$的方法，$c$表示的是类别的数目。 最小二乘分类&emsp;测试模式$x$所对应的类别$y$的预测值$\\hat{y}$，是由学习后的输出结果的符号决定的 \\hat{y}=sign(f_{\\hat{\\theta}}(x))= \\begin{cases} +1, &(f_{\\hat{\\theta}}>0) \\\\0,&(f_{\\hat{\\theta}}=0) \\\\-1,&(f_{\\hat{\\theta}}","link":"/2020/07/30/%E5%9B%BE%E8%A7%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E5%9F%BA%E4%BA%8E%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95%E7%9A%84%E5%88%86%E7%B1%BB/"},{"title":"图解机器学习&#x2F;第三章 最小二乘学习法","text":"最小二乘学习法&emsp;最小二乘学习法是对模型的输出$f_{\\theta}(x_i)$和训练集输出$\\lbrace y_i \\rbrace_{i=1}^n$的平方误差 J_{LS}(\\theta)=\\frac{1}{2}\\sum_{i=1}^n(f_{\\theta}(x_i) - y_i)^2为最小时的参数$\\theta$进行学习 \\hat{\\theta}_{LS}=\\mathop{argmin}_{\\theta} J_{LS}(\\theta)平方误差$(f_{\\theta}(x_i)-y_i)^2$是残差$f_{\\theta}(x_i) - y_i$的$\\mathcal{l}_2$范数，因此最小二乘学习法有时也称为$\\mathcal{l}_2$损失最小化学习法。 &emsp;如果使用线性模型 f_{\\theta}(x_i)=\\sum_{j=1}^b \\theta_i \\phi_i (x)=\\theta^{\\intercal}\\phi(x)训练样本的平方差 J_{LS}(\\theta)=\\frac{1}{2}||\\Phi \\theta - y||^2其中，$y=(y_1,\\dots,y_n)^{\\intercal}$是训练输出的$n$维向量，$\\Phi$是下式中定义的$n\\times b$阶矩阵，也称为设计矩阵 \\Phi=\\left[ \\begin{matrix} \\phi_1(x_1) & \\cdots & \\phi_b(x_1) \\\\ \\vdots & \\ddots & \\vdots \\\\ \\phi_1(x_n) & \\cdots & \\phi_b(x_n) \\\\ \\end{matrix} \\right]训练样本的平方差$J_{LS}$的参数向量$\\theta$的偏微分 \\nabla_{\\theta}J_{LS}=(\\frac{\\partial J_{LS}}{\\partial \\theta_1},\\dots,\\frac{\\partial J_{LS}}{\\partial \\theta_b})^{\\intercal} = \\Phi^{\\intercal}\\Phi \\theta - \\Phi^{\\intercal}y将其微分设置为0，则 \\hat{\\theta}_{LS} = (\\Phi^{\\intercal}\\Phi)^{-1}\\Phi^{\\intercal}y对顺序为$i$的训练样本的平方差通过权重$\\omega_i \\ge 0$进行加权，然后采用最小二乘学习，这称为加权最小二乘学习法 \\mathop{min}_{\\theta} \\frac{1}{2}\\sum_{i=1}^n \\omega_i (f_{\\theta}(x_i)-y_i)^2 最小二乘解的性质&emsp;设计矩阵$\\Phi$的奇异值分解 \\Phi = \\sum_{k=1}^{min(n,b)} \\kappa_k \\psi_k \\varphi_k^{\\intercal}$\\kappa_k、\\psi_k、\\varphi_k$分别称为奇异值、左奇异向量、右奇异向量。奇异值全部是非负的，奇异向量满足正交性。 线性模型的最小二乘学习法中，训练输出向量$y$是由$\\Phi$的值域$\\mathcal{R}(\\Phi)$的正投影得到的。 大规模数据的学习算法&emsp;随机梯度算法是指，沿着训练平方误差$J_{LS}$梯度下降，对参数$\\theta$依次进行学习的算法。 凸函数 对于任意的两点$\\theta_1、\\theta2$和任意的$t\\in [0,1]$ J(t\\theta_1 + (1-t)\\theta_2) \\le tJ(\\theta_1) + (1-t)J(\\theta_2)凸函数是只有一个峰值的函数，所以通过梯度法就可以得到训练平方误差$J_{LS}$在值域范围内的最优解，即全局最优解。 使用随机梯度算法对线性模型进行最小二乘学习算法 给$\\theta$以适当的初值 随机选择一个训练样本 对于选定的训练样本，采用使其梯度下降的方式，对参数$\\theta$进行更新 \\theta \\leftarrow \\theta- \\epsilon \\nabla J_{LS}^{(i)}(\\theta)在这里，$\\epsilon$是名为学习系数的正标量，表示梯度下降的步幅。$\\nabla J_{LS}^{(i)}(\\theta)$是顺序为$i$的训练样本相对应的训练平方误差的梯度，表示梯度下降的方向。 \\nabla J_{LS}^{(i)}(\\theta)=\\phi(x_i)(f_{\\theta}(x_i)-y_i) 直到解$\\theta$达到收敛精度为止，重复上述2、3步的计算。","link":"/2020/05/09/%E5%9B%BE%E8%A7%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E5%AD%A6%E4%B9%A0%E6%B3%95/"},{"title":"图解机器学习&#x2F;第九章 集成分类","text":"集成学习，是指把性能较低的多种弱学习器，通过适当组合而形成高性能的强学习器的方法。本章有介绍两种集成学习法，一种是对多个弱学习器独立进行学习的Bagging学习法，一种是对多个弱学习器依次进行学习的Boosting学习法。 剪枝分类剪枝分类是属于弱学习器的一种单纯分类器。是指对于$d$次维的输入变量$x=(x^{(1)},\\dots,x^{(d)})^{\\intercal}$，任意选定其中的一维，通过将其值与给定的阈值相比较来进行分类的线性分类器。即以输入空间内的坐标轴与超平面进行正交的方式对模式进行分类。 剪枝分类器的自由度很低，但是具有计算成本低的优点。 Bagging学习法统计学上的Bootstrap一般称为自助法，是指从$n$个训练样本$\\lbrace (x_i,y_i) \\rbrace_{i=1}^n$中随机选取$n$个，允许重复，生成与原始的训练样本集有些许差异的样本集的方法。 在Bagging学习中，首先经由自助法生成虚拟的训练样本，并对这些样本进行学习。然后，反复重复这一过程，对得到的多个分类器的输出求平均值。通过上述方法，就可以从大量略有不同的训练样本集合，得到多个稍微不同的弱分类器，然后再对这些分类器加以统合，就可以得到稳定、可靠的强分类器。 一般而言，像剪枝分类器这样非常单一的弱分类器，对其进行集成学习很少会发生过拟合现象，因此将Bagging学习的重复次数设置为较大的值是比较好的选择。在这种情况下，因为多个弱分类器的学习是个并行的过程，因此使用多台计算机并行处理，会使计算效率得到巨大的提升。 Bagging学习算法： 对$j=1,\\dots,b$重复进行如下计算 从$n$个训练样本$\\lbrace (x_i,y_i) \\rbrace_{i=1}^n$中随机选取$n$个，允许重复，生成若干个与原始的训练样本集有些许差异的新样本集。 使用上述得到的样本集求得弱学习器$\\varphi_j$ 对所有的弱学习器$\\lbrace \\varphi_j \\rbrace_{j=1}^b$，求平均值，得到一个强学习器$f$ f(x) \\leftarrow \\frac{1}{b}\\sum_{j=1}^b \\varphi_j(x) 剪枝分类器不断地生长、积累，形成多层级的模型，该模型就称为决策树分类器。对决策树分类器进行Bagging学习的时候，通过随机选择输入变量中的某个维度进行学习，可以大幅提高分类器的性能，这种手法也称为随机森林学习。 Boosting学习法AdaboostBoosting学习，首先使用一个原始的学习算法，对训练样本 \\lbrace (x_i,y_i)| x_i \\in \\mathbb{R}^d,y_i \\in \\lbrace +1,-1 \\rbrace \\rbrace_{i=1}^n进行普通分类器的学习。如果原始算法的学习性能不高，就不能对所有的训练样本进行正确的分类。因此，对于不能正确分类的困难样本就加大其权重（反之，对于能正确分类的简单样本则减少其权重），再重新进行学习。然后，再循环多次进行加权学习，慢慢地就可以对所有的训练样本都进行正确的分类了。然而另一方面，在进行加权的过程中，最开始就能够正确分类的样本的权重会慢慢变小，有可能造成简单的样本反而不能正确分类的情况。 因此，Boosting学习应该边学习边更新样本的权重，并把学习过程中得到的所有分类器放在一起，对其可信度进行平均后训练得到最终的强分类器。 样本的加权方法多种多样，最为标准的就是Adaboost算法 Adaboost学习算法： 把训练样本$\\lbrace (x_i,y_i) \\rbrace_{i=1}^n$对应的各个权重$\\lbrace \\omega_i \\rbrace_{i=1}^n$设置为均等，即1/n，并把强分类器$f$的初始值设为零 \\omega_1,\\dots,\\omega_n \\leftarrow 1/n, f\\leftarrow0 对$j=1,\\dots,b$重复进行如下计算 对于现在的样本权重$\\lbrace \\omega_i \\rbrace_{i=1}^n$，对加权的误分类率（0/1损失的权重之和）$R(\\varphi)$为最小的弱分类器$\\varphi_j$进行学习 \\varphi_j = \\mathop{argmin}_{\\varphi}R(\\varphi),R(\\varphi)=\\sum_{i=1}^n \\frac{\\omega_i}{2}(1-\\varphi(x_i)y_i) 通过下式 定义弱分类器$\\varphi_i$的权重$\\theta_j$由下 \\theta_j = \\frac{1}{2}log\\frac{1-R(\\varphi_j)}{R(\\varphi_j)} 通过下式更新强分类器$f$ f \\leftarrow f+ \\theta_j \\varphi_j 通过下式更新样本权重$\\lbrace \\omega_i \\rbrace_{i=1}^n$ \\omega_i \\leftarrow \\frac{exp(-f(x_i)y_i)}{\\sum_{i'=1}^n exp(-f(x_{i'})y_i)},\\forall i=1,\\dots,n ​","link":"/2020/05/09/%E5%9B%BE%E8%A7%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E9%9B%86%E6%88%90%E5%88%86%E7%B1%BB/"},{"title":"图解机器学习&#x2F;第二章 学习模型","text":"线性模型&emsp;在对函数$f$进行近似时，最简单的模型就是线性模型$\\theta \\times x$。$\\theta$表示模型的参数，通过对参数进行学习，完成函数的近似计算。在实际应用中，经常会对线性模型进行扩展，使其变成基于参数的线性模型： f_{\\theta}(x)=\\sum_{j=1}^b \\theta_j \\phi_j(x)=\\theta^{\\intercal}\\phi(x)&emsp;乘法模型是指，把一维基函数作为因子，通过使其相乘而获得多维基函数的方法： f_{\\theta}(x)=\\sum_{j_1=1}^{b'} \\dots \\sum_{j_d=1}^{b'} \\theta_{j1,\\dots,j_d}\\phi_{j1}(x^{(1)} \\dots\\phi_{jd}(x^{(d)})) 由于乘法模型随着维数的增加，计算量呈指数级增长的现象，称为维数灾难。 &emsp;加法模型是指，把一维的基函数作为因子，通过使其相加而获得多维基函数的方法： f_{\\theta}(x)=\\sum_{k=1}^d \\sum_{j=1}^{b'} \\theta_{k,j} \\phi_j(x^{(k)}) 加法模型只会随着输入维数线性增长，但是，由于加法模型只考虑了一维基函数相加的情况，因此表现力要比乘法模型逊色许多。 核模型&emsp;核模型，是以使用被称为核函数的二元函数$K(.,.)$，以$K(x,x_j)_{j=1}^n$的线性结合方式加以定义的 f_{\\theta}(x)=\\sum_{j=1}^n \\theta_j K(x,x_j)在众多核函数中，以高斯核函数的使用最为广泛 K(x,c)=exp(-\\frac{||x-c||^2}{2h^2})在上式中，$||\\cdot||$表示2范数，即$||x||=\\sqrt{x^{\\intercal}x}$。$h$和$c$分别对应于高斯核函数的带宽和均值。 由于只能在训练集的输入样本附近对函数进行近似，所以从某种程度上来说也减轻了维数灾难的影响。 &emsp;在核模型里，参数的个数不依赖于输入变量$x$的维数$d$，只由训练样本数$n$决定。在统计学中，通常把与基于参数的线性模型称为参数模型，把核模型称为非参数模型。 &emsp;核模型的另一个特征是：当输入样本$x$不是向量的时候，也能很容易实现扩展。目前已经有人提出了输入样本$x$是字符串、决策树或图表等的核函数，这样的核函数进行的机器学习算法，称为核映射方法。 层级模型&emsp;层级模型是非线性模型。","link":"/2020/05/09/%E5%9B%BE%E8%A7%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B/"},{"title":"图解机器学习&#x2F;第五章 稀疏学习","text":"$l_1$约束的最小二乘学习法 \\mathop{min}_{\\theta}J_{LS}(\\theta) \\quad 约束条件 \\quad ||\\theta||_1 \\le R \\\\ ||\\theta||_1 = \\sum_{j=1}^b|\\theta_j|&emsp;$l_1$约束的最小二乘学习法，在有些著作中也成为Lasso回归。 $l_1$约束的最小二乘学习的求解方法&emsp;因为$l_1$范数中包含在原点处不能微分的绝对值，因此不能像$l_2$约束那样简单地进行求解。近年来产生了许多求解$l_1$约束的最小二乘学习法的算法，特别是当参数b使非常大的数值的时候，$l_1$约束的最小二乘学习法可以获得比$l_2$约束的最小二乘学习法更高的求解速度。 &emsp;使用由$l_1$约束的上限$R$决定的拉格朗日乘子$\\lambda$，来考虑最优化问题： \\mathop{min}_{\\theta}J(\\theta),J(\\theta)=J_{LS}(\\theta)+\\lambda||\\theta||_1另外，对于$l_1$范数中包含的不能进行微分的绝对值函数，使用可以微分的二次函数进行控制 |\\theta_j| \\le \\frac{\\theta_j^2}{2c_j} + \\frac{c_j}{2}对于c_j >0上述的二次函数就是该绝对值函数的上界，与绝对值函数在点$\\theta_j = ±c_j$处相切。 &emsp;通过反复迭代来对其进行求解，可以用现在的解$|\\tilde{\\theta_j}| \\not= 0$来替换$c_j$，以构成上界约束 |\\theta_j| \\le \\frac{\\theta_j^2}{2|\\tilde{\\theta_j}|} + \\frac{|\\tilde{\\theta_j}|}{2}据此可以得到$l_2$正则化最小二乘学习法的一般表达式 \\hat{\\theta}=\\mathop{argmin}_{\\theta} \\tilde{J}(\\theta),\\tilde{J}(\\theta) = J_{LS}(\\theta)+ \\frac{\\lambda}{2}\\theta^{\\intercal}\\tilde{\\Theta}^{\\dagger}\\theta+C上式中，$\\tilde{\\Theta}$是对角元素为$|\\tilde{\\theta_1}|,\\dots,|\\tilde{\\theta_b}|$的对角矩阵，$C=\\sum_{j=1}^b|\\tilde{\\theta_1}|/2$是不依赖于$\\theta$的常数。 使用一般$l_2$约束的最小二乘学习法求解$l_1$约束的最小二乘学习法的迭代方法 给初始值$\\theta$以适当的值 通过现在的解$\\theta$来计算矩阵$\\Theta$ \\Theta \\leftarrow diag(|\\theta_1|,\\dots,|\\theta_b|)其中，$diag(a,b,\\dots,c)$是以$a,b,\\dots,c$为对角元素的对角矩阵 使用矩阵$\\Theta$来计算解$\\theta$ \\theta \\leftarrow (\\Phi^{\\intercal}\\Phi+\\lambda\\Theta^{\\dagger})^{-1}\\Theta^{\\intercal}y 直到解$\\theta$达到收敛精度为止，重复上述2、3步的计算 通过稀疏学习进行特征选择&emsp;使用$l_1$约束的稀疏学习进行特征选择，可以在一定程度上考虑到各个特征之间的相互联系。 $l_p$约束的最小二乘学习法&emsp;$p \\ge 0$的$l_p$范数的约束方法 ||\\theta||_p = (\\sum_{j=1}^b|\\theta_j|^p)^{\\frac{1}{p}} \\le R但是，当$p=\\infty$的时候 ||\\theta||_{\\infty} = max \\lbrace|\\theta_1|,\\dots,|\\theta_b| \\rbrace因此，$l_{\\infty}$范数表示的是向量元素绝对值中的最大值，$l_{\\infty}$范数也成为最大值范数。$l_0$范数表示的是非零的向量元素个数。 在坐标轴上呈有峰值的尖形是存在稀疏解的秘诀，满足约束条件的空间如果不是凸形的话，可能存在局部最优解。当$p=1$时，稀疏解存在唯一的凸形，由此可知，$l_1$约束的最小二乘学习法是非常特殊的一种学习方法。 $l_1+l_2$约束的最小二乘学习法&emsp;通过利用$l_1+l_2$范数的凸结合来进行约束 (1-\\tau)||\\theta||_1 + \\tau||\\theta||^2 \\le R&emsp;$l_1+l_2$约束的最小二乘学习法，也成为弹性网回归学习法。","link":"/2020/05/09/%E5%9B%BE%E8%A7%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E7%A8%80%E7%96%8F%E5%AD%A6%E4%B9%A0/"},{"title":"图解机器学习&#x2F;第八章 支持向量机分类","text":"间隔最大化分类从线性2类别分类问题说明 f_{\\omega,\\gamma}(x) = \\omega^{\\intercal}x+\\gamma上式中的$\\omega$为把正负样本分割开的超平面的法线，$\\gamma$为截距。只要能够对各个训练样本的间隔$m_i=f_{\\omega,\\gamma}(x_i)y_i$为正时的$\\omega$和$\\gamma$进行学习，就可以利用这个模型对所有的训练样本进行正确的分类。 当存在满足条件的$\\omega$和$\\gamma$，使得$(\\omega^{\\intercal}x+\\gamma)y_i \\ge1 \\quad \\forall i=1,\\dots,n$，称这样的训练样本为线性可分的样本，一般选取能够最充裕地把正样本和负样本进行分离的超平面作为最优解。“最充裕”是指与正则化后地间隔$m_i=(\\omega^{\\intercal}x+\\gamma)y_i/||\\omega||$地最大值对应的。从几何学上讲，间隔为两端的两个超平面$\\omega^{\\intercal}x+\\gamma=+1$和$\\omega^{\\intercal}x+\\gamma = -1$地间距的一半，使这个间隔最大的超平面对应的分类器，成为硬间隔支持向量机分类器。 软间隔支持向量机分类器的基本思路是，允许在间隔的计算中出现少许的误差$\\xi=(\\xi_1,\\dots,\\xi_n)^{\\intercal}$ 支持向量机分类器的求解方法支持向量机分类器的最优化问题，是目标函数为二次函数、约束条件为线性的典型的二次规划问题。 二次规划问题，始于矩阵$F、G$以及向量$f、g$相对应的由下式定义的最优化问题 \\mathop{min}_{\\theta}[\\frac{1}{2}\\theta^{\\intercal}F\\theta+f^{\\intercal}\\theta)] \\quad 约束条件 \\quad G\\theta \\le g这里把向量不等式$G\\theta \\le g$分解，表示为各个元素的不等式 \\tbinom{a}{b} \\le \\tbinom{c}{d} \\iff f(n)=\\begin{cases} a\\le c \\\\ b \\le d \\end{cases}假定矩阵$F$是正定值（即所有的固有值都为正），当条件不充分，数值不稳定时，为$F$的对角元素加上一个特别小的正值，从而使其稳定性得以提高。 稀疏性 Karush-Kuhn-Tucker最优化条件，经常简称为KKT条件 可微分的凸函数$f:\\mathbb{R}^d \\rightarrow \\mathbb{R}^p$的约束条件的最小化问题 \\mathop{min}_t f(t) \\quad 约束条件 \\quad g(t) \\le 0的解，满足如下的KKT最优化条件 \\frac{\\partial L}{\\partial t}=0,g(t)\\le0, \\lambda \\ge 0, \\lambda_{i}g_i(t)=0,\\forall i=1,\\dots,n在上式中，$L(t,\\lambda)=f(t)+\\lambda^{\\intercal}g(t)$为拉格朗日函数，$\\lambda=(\\lambda_1,\\dots,\\lambda_p)$为拉格朗日乘子。最后的条件式$\\lambda_{i}g_i(t)=0$，是指参数$\\lambda_i$和$g_i(t)$中至少一个为零，因此也将其称为互补性条件。 对偶变量和约束条件应该满足如下的互补条件 \\alpha_i (m_i-1+\\xi_i)=0,\\beta_i\\xi_i=0,\\forall i =1,\\dots,n当$\\alpha_i =0$时，训练样本$x_i$位于间隔边界上或边界内侧，可充裕地进行正确分类。当$0&lt;\\alpha_i &lt; C$的时候，$x_i$刚好位于间隔边界上，可正确分类。当$\\alpha_i =C$的时候，$x_i$位于间隔边界上或边界外侧，如果其间隔误差$\\xi_i$大于1，则间隔为负，训练样本$x_i$就不能得到正确的分类。另外，如果训练样本$x_i$位于间隔边界内侧，就有$\\alpha_i=0$如果位于间隔边界外侧，就有$\\alpha_i=C$。 与$0&lt;\\alpha_i &lt; C$相对应的训练样本$x_i$称为支持向量。 使用核映射的非线性模型首先使用非线性函数$\\psi$，对训练输入样本$\\lbrace x_i \\rbrace_{i=1}^n$的特征空间进行描述；然后，对特征空间内的训练输入样本$\\lbrace \\psi(x_i) \\rbrace_{i=1}^n$，适用线性的支持向量机分类器。通过这种方式得到的特征空间内的线性分类器， 在原始的输入空间是非线性分类器。 如果选择比原始的输入维数d维数更高的空间作为特征空间，则训练样本为线性可分的可能性就比较高。然而，如果特征空间的维数过大的话，计算时间也会相应的增加。 利用核映射求解支持向量机分类器的非线性模型。直接通过核函数$K(x,x’)$定义内积$\\langle \\psi(x), \\psi(x’) \\rangle$数，而不需要明确地知道特征变换$\\psi$是什么的方法，就称为核映射方法。如果核函数的值与特征空间的维数无关、相互独立，非线性支持向量机的全体学习时间就完全不依赖于特征空间的维数了，例如常用的多项式核函数以及高斯核函数。 核映射方法的另一个重要特征是，即使输入$x$不是向量，也可以正确地进行分类。 使用Hinge损失最小化学习来解释使用如下Hinge损失作为代理损失 max \\lbrace 0,1-m \\rbrace当$m \\ge 1$的时候，与0/1损失相同，其损失为0，当$m &lt; 1$的时候，其损失为$1-m &gt; 0$。当其损失为正的时候，与$m$相关的函数有倾向于负的趋势。 使用Ramp损失的鲁棒学习Hinge损失没有上界，因此当间隔比较大的负数值时，损失就会变得非常大。所以在训练样本中包含异常值的情况下，支持向量机分类器非常容易受影响。 Ramp损失： min \\lbrace 1,max(0,1-m) \\rbrace = \\begin{cases} 1 &\\text{(m1)} \\end{cases}Ramp损失是指，在Hinge损失的左侧以范围1做截断的损失。因为Ramp有损失边界，对异常值有非常强的鲁棒性，但是Ramp损失为非凸函数，很难求得最优解。","link":"/2020/07/30/%E5%9B%BE%E8%A7%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%E5%88%86%E7%B1%BB/"},{"title":"图解机器学习&#x2F;第六章 鲁棒学习","text":"最小二乘学习法具有易受异常值影响的特点 在统计学领域和机器学习领域，对异常值也能保持稳定、可靠的性质，称为鲁棒性。 $l_1$损失最小化学习&emsp;对训练样本的合理性，一般使用$l_2$损失$J_{LS}(\\theta)$来测定 J_{LS}(\\theta)=\\frac{1}{2} \\sum_{i=1}^n r_i^2这里的$r_i$是顺序为$i$的训练样本所对应的残差 r_i = f_{\\theta}(x_i) -y_i&emsp;使用$l_1$损失对残差的增幅加以抑制的学习算法 \\hat{\\theta}_{LA} = \\mathop{argmin}_{\\theta}J_{LA}(\\theta), J_{LA}(\\theta)=\\sum_{i=1}^n|r_i|&emsp;对于常数模型$f_{\\theta}(x)=\\theta$，最小二乘学习的最终输出结果是训练样本输出值$\\lbrace y_i \\rbrace _{i=1}^n$的平均值 \\hat{\\theta}_{LS}=\\mathop{argmin}_{\\theta}\\sum_{i=1}^n (\\theta-y_i)^2 = mean(\\lbrace y_i \\rbrace _{i=1}^n)&emsp;最小绝对值偏差学习的最终输出结果则是训练样本输出值$\\lbrace y_i \\rbrace _{i=1}^n$的中间值 \\hat{\\theta}_{LA}=\\mathop{argmin}_{\\theta}\\sum_{i=1}^n |\\theta-y_i| = median(\\lbrace y_i \\rbrace _{i=1}^n) Huber损失最小化学习&emsp;Huber损失混合使用了$l_2$损失和$l_1$损失 \\rho Huber(r)=\\begin{cases} r^2 /2,&\\text{|r| $\\le \\eta$}\\\\\\eta |r|- \\eta^2/2,&\\text{|r| >$ \\eta$}\\end{cases} 如果残差的绝对值$|r|$小于阈值$\\eta$的话，上式就变成了$l_2$损失；如果残差的绝对值$|r|$大于阈值$\\eta$的话，就变成了$l_1$损失，但是，为了与$l_2$损失平滑地连接，在$l_1$损失中减去了常数$\\eta^2/2$ 使用加权最小二乘学习法对Huber损失最小化学习进行反复迭代计算的方法 给$\\theta$以适当的初始值 通过现在的解$\\theta$来计算权重矩阵$W$ W \\leftarrow diag(\\omega_1,\\dots,\\omega_n),\\omega_i=\\begin{cases} 1,&\\text{ $|r_i|\\le \\eta$}\\\\\\eta/|r_i|,&\\text{$ |r_i| >\\eta$}\\end{cases}其中，$r_i=f_{\\theta}(x_i)-y_i$为残差 使用权重矩阵$W$来计算解$\\theta$ \\theta \\leftarrow(\\Phi^{\\intercal}W \\Phi)^{\\dagger}\\Phi^{\\intercal}Wy 直到解$\\theta$达到收敛精度为止，重复上述2、3步的计算 &emsp;将阈值$\\eta$设定为非常小的数值时，Huber损失可以认为是$l_1$损失的平滑近似。因此，可通过反复加权最小二乘学习法，对$l_1$损失最小二乘学习法进行近似的求解。 图基损失最小化学习&emsp;使用$l_1$损失对异常值进行处理，就会使得 异常值对结果的影响非常巨大，在实际应用中，Huber损失最小化学习的权重$\\tilde{\\omega}_i$即使对于大的残差也不会变为零。采用图基(Tukey)损失法可以解决上述问题。 \\rho Tukey(r)=\\begin{cases} (1-[1-r^2 /\\eta^2]^3)\\eta^2/6,&\\text{|r| $\\le \\eta$}\\\\\\eta^2/6,&\\text{|r| >$ \\eta$}\\end{cases}图基损失中，如果残差的绝对值$|r|$大于阈值$\\eta$的话，就以$\\eta^2/6$的形式输出，因此图基损失最小化学习一般具有非常高的鲁棒性。但是，因为图基损失并不是凸函数，一般拥有多个局部最优解，所以在整个值域范围内求得最优解非常困难。 &emsp;将以下权重应用到实际问题中就可以求出局部最优解 \\omega =\\begin{cases} (1-r^2 /\\eta^2)^2,&\\text{|r| $\\le \\eta$}\\\\ 0,&\\text{|r| >$ \\eta$}\\end{cases}当$|r|&gt;\\eta$的时候，权重完全变为零，因此图基损失最小化学习完全不受显著异常值的影响。 使用图基损失最小化学习可以得到鲁棒性更强的结果，但是数据中的噪声稍微发生变化都会产生其他的局部最优解。 $l_1$约束的Huber损失最小化学习 \\mathop{min}_{\\theta}\\sum_{i=1}^n \\rho Huber(r_i) \\quad 约束条件 \\quad ||\\theta||_1 \\le R $l_1$约束的Huber损失最小化学习的迭代解法 给$\\theta$以适当的初始值 通过现在的解$\\theta$来计算权重矩阵$W$和矩阵$\\Theta$ W \\leftarrow diag(\\omega_1,\\dots,\\omega_n),\\Theta \\leftarrow diag(|\\theta_1|,\\dots,|\\theta_b|)其中，权重$\\omega_i$使用残差$r_i=f_{\\theta}(x_i)-y_i$由下式加以定义 \\omega_i = \\begin{cases} 1, &\\text{($|r_i| \\le \\eta$)} \\\\ \\eta/|r_i|, &\\text{($|r_i|>\\eta$)} \\end{cases} 使用权重矩阵$W$和矩阵$\\Theta$来计算解$\\theta$ \\theta \\leftarrow (\\Phi^{\\intercal}W \\Phi + \\lambda \\Theta^{\\dagger})^{-1}\\Phi^{\\intercal}Wy 直到解$\\theta$达到收敛精度为止，重复上述2、3步的计算","link":"/2020/07/07/%E5%9B%BE%E8%A7%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E9%B2%81%E6%A3%92%E5%AD%A6%E4%B9%A0/"},{"title":"图解机器学习&#x2F;第十一章 序列数据的分类","text":"字符串的分类问题，比起将字符串拆分为独立的文字，并分别对各个文字进行识别，对字符串整体同时进行识别的话，因为能充分利用文字的前后关系，所以识别精度会更高。 序列数据的模型化将顺序为$k$的模式定义为$x^{(k)}$，该模式所属的类别定义为$y^{(k)}$，然后将这样的$m$个模式的序列分别用$\\overline{x}$和$\\overline{y}$进行表示 \\overline{x} = (x^{(1)}, \\dots, x^{(m)}), \\overline{y} = (y^{(1)}, \\dots,y^{(m)})如果对各个模式$x^{(k)}$进行独立的识别，那么$c$个类别的模式识别问题进行$m$次求解就可以完成对此模式序列的识别。然而，这样的识别方式并没有充分利用各个模式的前后关系。 在个模式的类别为$c$个的情况下，如果对连续的$m$个模式同时进行识别的话，就需要对$\\overline{c} = c^m$个类别的模式识别问题进行求解。然而，在这种方式中，由于类别个数$\\overline{c}$和参数$\\overline{\\theta}$的维度是以模式序列的长度$m$为基数呈指数级增长的，因此直接对其进行学习往往很困难。 假定只有前一个模式所属的类别$y^{(k-1)}$会对现在的模式$x^{(k)}$所属的类别$y^{(k)}$有影响，通过把连续的两个模式的识别加以组合，对模式序列全体进行识别。这样的方法，并不是简单地对连续的两种模式所对应的$c^2$个类别的识别问题进行单独求解，而是尽可能地对模式序列全体同时进行识别。这种方法称为条件随机场。 q(\\overline{y}|\\overline{x};\\zeta) = \\frac{exp(\\zeta^{\\intercal} \\varphi(\\overline{x},\\overline{y}))}{\\sum_{\\overline{y}'=1}^{\\overline{c}} exp(\\zeta^{\\intercal} \\varphi(\\overline{x},\\overline{y'}))}这里的$\\varphi(\\overline{x},\\overline{y})$表示的是基函数的向量。 条件随机场模型的学习 使用随机梯度算法的条件随机场的算法流程： 给$\\zeta$以适当的值 随机选择一个训练样本(假设选择了顺序为$i$的训练样本$(\\overline{x},\\overline{y})$) 对于选定的训练样本，以梯度上升的方向对参数$\\zeta$进行更新 \\zeta \\leftarrow \\zeta + \\epsilon(\\varphi(\\overline{x},\\overline{y}) - \\frac{ \\sum_{\\overline{y}=1}^{\\overline{c}_i} exp(\\zeta^{\\intercal} \\varphi(\\overline{x}_i,\\overline{y}))\\varphi(\\overline{x}_i,\\overline{y})}{\\sum_{\\overline{y}'=1}^{\\overline{c}_i} exp(\\zeta^{\\intercal} \\varphi(\\overline{x}_i,\\overline{y'}))})在这里，$\\epsilon$为表示梯度向上的幅度的正常数。$\\overline{c_i}=c^{m_i}$是长度为$m_i$的模式序列所对应的类别个数。 直到解$\\zeta$达到收敛精度为止，重复上述2、3步的计算","link":"/2020/05/09/%E5%9B%BE%E8%A7%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%20%E5%BA%8F%E5%88%97%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%86%E7%B1%BB/"},{"title":"图解机器学习&#x2F;第十七章 监督降维","text":"监督降维算法的目的，是通过将输入$x$变换为低维的$z$，使输出$y$的预测更加容易。假设输入样本$x$的维度为$d$，低纬度下的$z$的维度为$m$，$d\\times m$阶矩阵为$T$ z = Tx并预先对训练样本$\\lbrace (x_i) \\rbrace_{i=1}^n$进行中心化处理 x_i \\leftarrow x_i-\\frac{1}{n}\\sum_{i'=1}^n x_{i'}与分类问题相对应的判别分析Fisher判别分析Fisher判别分析，是寻找能够使相同类别的样本尽量靠近，不同类别的样本尽量远离的矩阵$T$的方法。 定义组内分散矩阵$S^{(w)}$和组间分散矩阵$S^{(b)}$ S^{(w)} = \\sum_{y=1}^c \\sum_{i:y_i = y}(x_i-\\mu_y)(x_i-\\mu_y)^{\\intercal} \\in \\mathbb{R}^{(d \\times d)}\\\\ S^{(b)}=\\sum_{y=1}^n n_y \\mu_y \\mu_y^{\\intercal} \\in \\mathbb{R}^{d \\times d}“w”和“b”分别是“within-class”和“between-class”的首字母。$\\sum_{i:y_i = y}$是所有满足$y_i = y$的$y$的和，$\\mu_y$是所有属于类别$y$的输入样本的平均值 \\mu_y = \\frac{1}{n_y}\\sum_{i:y_i = y}x_i$n_y$是属于类别$y$的训练样本总数。使用这样的分散矩阵，Fisher判别分析的投影矩阵可由下式定义 \\mathop{max}_{T\\in \\mathbb{R}^{m \\times d}} tr((TS^{(w)}T^{\\intercal})^{-1}TS^{(b)}T^{\\intercal}) Fisher判别分析，是通过使投影后的组间分散矩阵$TS^{(b)}T$变大，组内分散矩阵$TS^{(w)}T$变小，来决定矩阵$T$的*。 考虑对与矩阵对$(S^{(b)},S^{(w)})$相关的一般化特征值问题 S^{(b)}\\xi = \\lambda S^{(W)} \\xi与一般化特征值对应的一般化特征向量分别用$\\lambda_1 \\ge,\\dots,\\ge \\lambda_d \\ge 0$和$\\xi_1,\\dots,\\xi_d$来表示。这样，Fisher判别分析即可进行解析求解。 \\hat{T} = (\\xi_1,\\dots,\\xi_m)^{\\intercal}即Fisher判别分析的投影矩阵，是依据与矩阵对$(S^{(b)},S^{(w)})$的较大的$m$个一般化特征值相对应的一般化特征向量来确定的。 局部Fisher判别分析当某些类别的输入样本具有多峰值特性的时候，往往不能得到理想的结果。Fisher判别分析也会无视簇构造，强行把它们撮合为相同的类别，这样有时就不能得到理想的降维效果。 为了解决上述问题，局部Fisher判别分析使用如下的局部组内分散矩阵$S^{(lw)}$和局部组间分散矩阵$S^{(lb)}$ S^{(lw)}=\\frac{1}{2}\\sum_{i:i'=1}^n Q_{i:i'}^{(lw)}(x_i-x_{i'})(x_i-x_{i'})^{\\intercal} S^{(lb)}=\\frac{1}{2}\\sum_{i:i'=1}^n Q_{i:i'}^{(lb)}(x_i-x_{i'})(x_i-x_{i'})^{\\intercal}其中，$Q_{i:i’}^{(lw)}$和$Q_{i:i’}^{(lb)}$由下式定义 Q_{i:i'}^{(lw)}= \\begin{cases} W_{i,i'}/n_y &\\text{$(y_i=y_{i'}=y)$} \\\\ 0 &\\text{$(y_i \\not= y_{i'})$}\\end{cases} Q_{i:i'}^{(lb)}= \\begin{cases} W_{i,i'}(1/n-1/n_y) &\\text{$(y_i=y_{i'}=y)$} \\\\ 1/n &\\text{$(y_i \\not= y_{i'})$}\\end{cases}其中$0 \\le W_{i,i’} \\le 1$为训练样本$x_i$和$x_{i’}$的相似度。通过这样的方法，对于属于相同类别但不相似的样本，强行把他们撮合为相同类别的能力就会变弱，簇构造就可以得到保护。 局部Fisher判别分析的投影矩阵可由下式进行定义 \\mathop{max}_{T\\in \\mathbb{R}^{m \\times d}} tr((TS^{(lw)}T^{\\intercal})^{-1}TS^{(lb)}T^{\\intercal})上式与原始Fisher判别分析形式完全一致，故对局部Fisher判别分析求解 \\hat{T} = (\\xi_1,\\dots,\\xi_m)^{\\intercal}半监督局部Fisher判别分析半监督局部Fisher判别分析，是把无监督的降维方法中的主成分分析法和局部Fisher判别分析法组合起来进行学习的一种方法。主成分分析的解，对应的是分散矩阵 S^{(t)} = \\sum_{i=1}^{n+n'} (x_i-\\mu^{(t)})(x_i-\\mu^{(t)})^{\\intercal},\\mu^{(t)}=\\frac{1}{n+n'}\\sum_{i=1}^{n+n'}x_i的较大的特征值所对应的特征向量。其中$\\mu^{(t)}$表示的是全部输入样本$\\lbrace x_i \\rbrace_{i=n+1}^{n+n’}$的平均值。 半监督局部Fisher判别分析将对特征值问题加以组合，具体而言就是采用半监督分散矩阵 S^{(slw)}=(1-\\beta)S^{(lw)}+\\beta S^{(t)},S^{(slb)}=(1-\\beta)S^{(lb)}+\\beta I半监督局部Fisher判别分析的解$\\hat{T}$，可以使用与一般化特征值问题 S^{(slb)}\\xi = \\lambda S^{(slw)} \\xi的一般化特征值$\\lambda_1 \\ge,\\dots,\\ge \\lambda_d \\ge 0$和对应的一般化特征向量$\\xi_1,\\dots,\\xi_d$进行解析求解 \\hat{T} = (\\xi_1,\\dots,\\xi_m)^{\\intercal}这个解在$\\beta =0$的时候与局部Fisher判别分析的解一致，在$\\beta = 1$的时候与主成分分析的解一致。 充分降维充分降维是一种适用于回归问题的监督降维算法，主要着眼于输入和输出的依赖关系。就是在给定投影后的数据$z=Tx$的时候，使原始的输入$x$和输出$y$条件独立，以此来确定投影矩阵$T$ p(x,y|z)=p(x|z)p(y|z)在给定$z$之后，$x$和$y$在统计上是相互独立的，$y$中包含的所有信息在$z$中均可以找到。这种条件独立性，是通过确定$z=Tx$和$y$最相互依存时对应的矩阵$T$来实现的。通过引入平方损失互信息，来确定下式为最大值时所对应的$T$，这时候$z$和$y$的从属关系也将达到最大 \\frac{1}{2} \\iint p(z)p(y)(\\frac{p(z,y)}{p(z)p(y)}-1)^2dzdy利用最小二乘互信息估计法来计算平方损失互信息，可以得到 J(T)=\\frac{1}{2}\\hat{h}^{\\intercal}(\\hat{G}+ \\lambda I)^{-1}\\hat{h}-\\frac{1}{2}上式中， \\hat{G}=\\frac{1}{n^2}\\sum_{i:i'=1}^n \\psi(z_i,y_{i'})\\psi(z_i,y_{i'})^{\\intercal},\\hat{h}=\\frac{1}{n}\\sum_{i=1}^n \\psi(z_i,y_i)$\\psi(z,y)\\in \\mathbb{R}^b$表示的是基函数 与上式的规则$J$中的$T$中编号为$(j,j’)$的元素$T_{j,j’}$相关的微分为 \\hat{h}^{\\intercal}(\\hat{G}+\\lambda I)^{-1} \\frac{\\part \\hat{h}}{\\part T_{j.j'}}-\\frac{1}{2}\\hat{h}^{\\intercal}(\\hat{G}+\\lambda I)^{-1}\\frac{\\part \\hat{G}}{\\part T_{j,j'}}(\\hat{G}+\\lambda I)^{-1} \\hat{h}使用这样的表示方式，通过梯度法就可以求得$J$的局部最优解。","link":"/2020/07/30/%E5%9B%BE%E8%A7%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0%20%E7%9B%91%E7%9D%A3%E9%99%8D%E7%BB%B4/"},{"title":"图解机器学习&#x2F;第十三章 无监督降维","text":"高维数据的处理是相当困难的，一般称为维数灾难。为了使机器学习算法从维数灾难中解放出来，一般采取的有效方法是尽量保持输入数据中包含的所有信息，并对其维数进行削减。 线性降维的原理无监督降维的目的，是把高维的训练输入样本$\\lbrace x_i \\rbrace_{i=1}^n$变换为低维的训练样本$\\lbrace z_i \\rbrace_{i=1}^n$，并在降维后还能尽可能地保持其原本包含的所有信息。 通过$x_i$的线性变换求解$z_i$的时候，即使用维数为$m \\times d$的投影矩阵$T$根据下式 z_i = Tx_i来求解$z_i$的时候，称为线性降维。 中心化： $x_i \\leftarrow x_i \\frac{1}{n} \\sum_{i’=1}^n x_{i’}$ 主成分分析主成分分析法，是尽可能地忠实再现原始数据地所有信息地降维方法。具体而言，就是在降维后地输入$z_i$是原始训练输入样本$x_i$地正投影这一约束条件下，设计投影矩阵$T$，让$z_i$和$x_i$尽可能相似。 $z_i$是$x_i$的正投影这一假设，与投影矩阵$T$满足$TT^{\\intercal}=I_m$是等价的。其中$I_m$表示的是$m \\times m$的单位矩阵。 当$z_i$和$x_i$的维度不一样的时候，并不能直接计算其平方误差。因此，一般先把$m$次维的$z_i$通过$T^{\\intercal}$变换到$d$次维空间，再计算其与$x_i$的距离。所有训练样本的$T^{\\intercal}z_i$与$x_i$的平方距离的和，可以通过下式表示 \\sum_{i=1}^n ||T^{\\intercal}Tx_i - x_i||^2 = -tr(TCT^{\\intercal}) + tr(C)其中，$C$为训练输入样本的协方差矩阵 C=\\sum_{i=1}^n x_ix_i^{\\intercal}主成分学习的过程可以用下式表示 \\mathop{max}_{T\\in \\mathbb{R}^{m \\times d}} tr(TCT^{\\intercal}) \\quad 约束条件 TT^{\\intercal}=I_m考虑到矩阵$C$的特征值问题 C\\xi = \\lambda \\xi将特征值和相对应的特征向量分别表示为$\\lambda_1 \\ge \\dots \\ge \\lambda_d \\ge 0$和$\\xi_1,\\dots,\\xi_d$，这样主成分分析的解就可以通过下式求得 T=(\\xi_1,\\dots,\\xi_m)^{\\intercal}主成分分析的投影矩阵，是通过向训练输入样本的协方差矩阵$C$中的较大的$m$个特征值所对应的特征向量张成的局部空间正投影而得到的。与此相反，通过把较小的特征值所对应的特征向量进行削减，与原始样本的偏离就可以达到最小。另外，主成分分析中求得的低维$\\lbrace z_i \\rbrace_{i=1}^n$，其各个元素之间是无关联的，相互独立的，即协方差矩阵为对角矩阵 \\sum_{i=1}^n z_i z_i^{\\intercal} = diag(\\lambda_1,\\dots,\\lambda_m)局部投影保持局部保持投影利用了训练输入样本间的相似度信息。训练输入样本$x_i$和$x_{i’}$的相似度用$W_{i,i’} \\ge 0$来表示。当$x_i$和$x_{i’}$较为相似的时候，$W_{i,i’}$为较大的值；当$x_i$和$x_{i’}$不那么相似的时候，$W_{i,i’}$为较小的值。相似度是对称的，即可以假设$W_{i,i’}=W_{i’,i}$ 训练输入样本$\\lbrace x_i \\rbrace_{i=1}^n$间的相似度的实例： 高斯相似度： W_{i,i'}=exp(- \\frac{||x_i - x_{i'}||^2}{2t^2})其中，$t&gt;0$是调整相似度衰减值的参数 $k$近邻相似度： W_{i,i'} = \\begin{cases}1 &\\text{$(x_i \\in \\mathcal{N}_k(x_{i'})或x_{i'}\\in \\mathcal{N}_k(x_i))$} \\\\ 0 &\\text{(其他)} \\end{cases}其中，$\\mathcal{N}_k(x)$为$\\lbrace x_i \\rbrace_{i=1}^n$中的$x$近邻的$k$个样本的集合。$k\\in [1,\\dots,n]$是调整相似度局部性的参数。$k$近邻相似度的优点是，以$W_{i,i’}$为第$(i,i’)$个元素的矩阵$W$是稀疏矩阵。 局部尺度相似度： W_{i,i'}=exp(- \\frac{||x_i - x_{i'}||^2}{2t_it_{i'}})其中，$t_i$为局部尺度，定义为$t_i=||x_i - x_i^{(k)}||$。$x_i^{(k)}$是$\\lbrace x_i \\rbrace_{i=1}^n$中与$x_i$的距离为第$k$近的样本。把局部尺度相似度和$k$近邻相似度组合在一起的$k$近邻局部相似度，有着广泛的实际应用。 在局部保持投影中，认为相似度较高的样本对的投影也较为相似，以此来决定投影矩阵$T$。具体而言，就是计算下式的值最小时所对应的$T$ \\frac{1}{2}\\sum_{i,i'=1}^n W_{i,i'}||Tx_i - Tx_{i'}||^2为了避免得到$T=O$这样不证自明的结果，加入约束条件 TXDX^{\\intercal}T^{\\intercal}=I_m上式中，$X=(x_1,\\dots,x_n)\\in \\mathbb{R}^{d \\times n}$是训练输入样本的矩阵，$D$是以矩阵$W$的各行元素之和为对角元素的对角矩阵 D_{i,i'} = \\begin{cases} \\sum_{i''=1}^n W_{i,i'} &\\text{$(i=i')$} \\\\ 0 &\\text{($i \\not= i'$)} \\end{cases}令$L=D-W$，综上，局部投影保持的学习规则可以用下式表示 \\mathop{min}_{T\\in \\mathbb{R}^{m \\times n}} tr(TXLX^{\\intercal}T^{\\intercal}) \\quad 约束条件 \\quad TXDX^{\\intercal}T^{\\intercal}=I_m考虑到关于矩阵对$(XLX^{\\intercal},XDX^{\\intercal})$的一般化特征值问题 XLX^{\\intercal}\\xi = \\lambda XDX^{\\intercal}\\xi将一般化特征值及与其对应的一般化特征向量，分别用$\\lambda_1 \\ge \\dots \\ge \\lambda_d \\ge 0$和$\\xi_1,\\dots,\\xi_d$来表示。局部保持投影就可以用下式来求解 T=(\\xi_d,\\xi_{d-1}, \\dots,\\xi_{d-m+1})^{\\intercal}局部保持投影的投影矩阵，是通过矩阵对$(XLX^{\\intercal},XDX^{\\intercal})$的较小的$m$个一般化特征值对应的一般化特征向量来求解的。 核函数主成分分析把训练样本$\\lbrace x_i \\rbrace_{i=1}^n$通过非线性函数$\\psi$进行变换，在变换后的特征空间里进行主成分分析。通过这样的方法，就可以在原始训练样本的特征空间中进行非线性降维操作。 协方差矩阵$C$的大小往往依赖于特征空间的维度，但是核矩阵$K$的大小则只与样本数有关。因此，当特征空间的维数比样本数大的时候，使用与核矩阵$K$相关的特征值问题，可以得到更高效的求解。 拉普拉斯特征映射将核函数方法应用在局部保持投影的非线性降维方法，称为拉普拉斯特征映射。 与$(XLX^{\\intercal},XDX^{\\intercal})$相关的一般化特征值问题就可以变换为 L\\alpha=\\lambda D \\alpha上式中一般化特征值及与其对应的一般化特征向量，分别可以用$\\lambda_1 \\ge \\dots \\ge \\lambda_n \\ge 0$和$\\alpha_1,\\dots,\\alpha_n$来表示。这里因为$L1_n=0_n$是成立的，显然与最小的一般化特征值$\\lambda_n=0$相对应的一般化特征向量为$\\alpha_n = 1_n$，这里去掉$\\alpha_n$变为 (z_1,\\dots,z_n)=(\\alpha_{n-1},\\alpha_{n-2},\\dots,\\alpha_{n-m})^{\\intercal}上式即为拉普拉斯特征映射的最终结果。 如果相似度矩阵$W$为稀疏矩阵，$L=D-W$也为稀疏矩阵，这样就变成了稀疏的一般化特征值问题，可以进行高效的求解。","link":"/2020/05/09/%E5%9B%BE%E8%A7%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0%20%E6%97%A0%E7%9B%91%E7%9D%A3%E9%99%8D%E7%BB%B4/"},{"title":"图解机器学习&#x2F;第十九章 多任务学习","text":"在对多个相似的学习任务进行学习的时候，共享各学习任务的信息并同时对其进行求解的方法，往往比对各个学习任务单独进行求解有更高的学习精度。 多任务学习是在多个学习任务之间实现信息的共享、转移的一种学习方法 使用最小二乘回归的多任务学习对于序号为$t$的回归任务，使用与参数$\\theta_t = (\\theta_{t,1},\\dots,\\theta_{t,b})^{\\intercal}$相关的线性模型 \\sum_{j=1}^b \\theta_{t,j}\\phi_j(x) = \\theta_t^{\\intercal} \\phi(x)基函数$\\phi(x)$对所有的学习任务都相同。在多任务学习里，添加约束条件使各个任务的参数$\\theta_1,\\dots,\\theta_T$具有相似的值，在此基础上对所有的参数$\\theta=(\\theta_1^{\\intercal}, \\dots, \\theta_T^{\\intercal})^{\\intercal}$同时进行学习。 使用$l_2$正则化的最小二乘法对下式$J(\\theta)$为最小时所对应的参数$\\theta$进行学习 J(\\theta) = \\frac{1}{2}\\sum_{i=1}^n (\\theta_{t_i}^{\\intercal} \\phi(x_i) - y_i)^2+\\frac{1}{2}\\sum_{t=1}^T \\lambda_t||\\theta_t||^2 + \\frac{1}{4}\\sum_{t,t'=1}^T \\gamma_{t,t'}||\\theta_t - \\theta_{t'}||^2在这里，$\\lambda_t \\ge 0$是与序号为$t$的学习任务对应的$l_2$正则化参数0，$\\gamma_{t,t’} \\ge 0$是序号为$t$的学习任务和序号为$t’$的学习任务的相似度。对于所有的$t,t’=1,\\dots,T$，当$\\gamma_{t,t’} = 0$时，$J(\\theta)$的第三项就没有了，这就对应于$T$个学习任务分别进行$l_2$正则化最小二乘学习。另一方面，如果$\\gamma_{t,t’} &gt; 0$的话，$\\theta_t$和$\\theta_{t’}$向着$l_2$范数的方向进行学习，即可实现多个学习任务间的信息共享。","link":"/2020/05/04/%E5%9B%BE%E8%A7%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%AC%AC%E5%8D%81%E4%B9%9D%E7%AB%A0%20%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%AD%A6%E4%B9%A0/"},{"title":"图解机器学习&#x2F;第十五章 在线学习","text":"一般来说，在训练样本不同时给定的情况下，比起将所有的训练样本集中起来同时进行学习，把训练样本逐个输入到学习算法中，并在新的数据进来的时候马上对现有的学习结果进行更新，这样的逐次学习算法更加有效。 当训练样本总数$n$非常大的时候，在线学习算法对于有限内存的利用、管理来说非常有效。 被动攻击学习梯度下降量的抑制在训练样本$(x,y)$逐个给定的在线学习中，也可以使用随机梯度下降算法进行参数的更新。概率梯度下降算法中，当梯度下降幅度过大的时候，学习结果往往会不稳定；而当梯度下降幅度过小的时候，又会使得收敛速度变慢。因此，一般引入一个惩罚系数，即偏离现在的解$\\tilde{\\theta}$的幅度，对梯度下降量进行适当地调整。 这样的学习方法对激进的梯度下降进行了抑制，称为被动攻击学习。 被动攻击分类进行分类时的损失函数，一般使用Hinge损失的平方形式，即 J(\\theta)=\\frac{1}{2}(max\\lbrace 0,1-m \\rbrace)^2 被动攻击分类的具体算法流程： 选取初始值为$\\theta \\leftarrow 0$ 利用新输入的训练样本$(x,y)$，使用下式对参数$\\theta$进行更新 \\theta \\leftarrow \\theta + \\frac{ymax(0,1-\\theta^{\\intercal}xy)}{||x||^2+ \\lambda}x 返回2步 被动攻击回归改变损失函数，即可适用于回归问题。使用$l_2$损失或$l_1$损失 J(\\theta)=\\frac{1}{2}r^2,J(\\theta)=|r|通过推导可得到更新规则 \\theta \\leftarrow \\theta-\\frac{r}{||x||^2 + \\lambda}x,\\theta \\leftarrow \\theta-sign(r)min \\lbrace \\frac{1}{\\lambda},\\frac{|r|}{||x||^2} \\rbrace x适应正则化学习被动攻击学习中使用的是没有上界的损失函数，因此往往不能很好地处理异常值。然而，具有上界的损失函数是非凸函数，进行最优化求解往往是很困难的。 参数分布的学习适应正则化学习，并不只是对参数$\\theta$进行学习，而是对参数的概率分布进行学习。 适应正则化分类 适应正则化分类的具体算法流程： 选取初始值为$\\mu \\leftarrow 0, \\Sigma \\leftarrow I$ 与新输入的训练样本$(x,y)$相对应的间隔$m=\\mu^{\\intercal}xy$，如果满足$m&lt;1$的话，则使用下式对参数进行更新 \\mu \\leftarrow \\mu + ymax(0,1-m)\\Sigma x/ \\beta,\\Sigma \\leftarrow \\Sigma-\\Sigma xx^{\\intercal}\\Sigma / \\beta其中，$\\beta=x^{\\intercal}\\Sigma x + C$ 返回第二步 适应正则化回归 \\mu \\leftarrow \\mu + (\\mu^{\\intercal}x-y)\\Sigma x/ \\beta,\\Sigma \\leftarrow \\Sigma - \\Sigma xx^{\\intercal} \\Sigma/ \\beta其中，$\\beta=x^{\\intercal}\\Sigma x + C$","link":"/2020/07/30/%E5%9B%BE%E8%A7%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0%20%E5%9C%A8%E7%BA%BF%E5%AD%A6%E4%B9%A0/"},{"title":"图解机器学习&#x2F;第十二章 异常检测","text":"异常检测，是指找出给定的输入样本$\\lbrace x_i \\rbrace_{i=1}^n$中包含的异常值的问题。 局部异常因子局部异常因子，是指对偏离大部分数据的异常数据进行检测的方法。 从$x$到$x’$的可达距离 RD_k(x,x')=max(||x-x^{(k)}||,||x-x'||)$x^{(k)}$表示的是训练样本$\\lbrace x_i \\rbrace_{i=1}^n$中距离$x$第$k$近的样本。 $x$的局部可达密度可由下式加以定义 LRD-k(x) = (\\frac{1}{k} \\sum_{i=1}^k RD_k(x^{(i)},x))^{-1}$x$的局部可达密度，是从$x^{(i)}$到$x$的可达距离的平均值的倒数。 $x$的局部异常因子 LOF_k(x) = \\frac{ \\frac{1}{k} \\sum_{i=1}^k LRD_k(x^{(i)})}{LRD_k(x)}$LOF_k(x)$的值越大，$x$的异常度就越大。$LOF_k(x)$是$x^{(i)}$的局部可达密度的平均值和$x$的局部可达密度的比。当$x^{(i)}$的周围的密度比较高而$x$周围的密度比较低的时候，局部异常因子就比较大，$x$就会被看作是异常值。 局部异常因子，是遵循事先制定的规则(偏离大部分正常值的数据被认为是异常值)，寻找异常值的无监督的异常检测算法。 支持向量机异常检测支持向量机异常检测器会求出几乎包含所有训练样本$\\lbrace x_i \\rbrace_{i=1}^n$的超球，并将没有包含在超球内的训练样本看作是异常值。 具体而言，就是通过求解下述的最优化问题来求得超球的球心$c$和半径$R$ \\mathop{min}_{c,R,\\xi}[R^2+C\\sum_{i=1}^n\\xi_i] \\\\ 约束条件 ||x_i-c||^2 \\le R^2+\\xi_i,\\xi_i \\ge0 对于i=1,\\dots,n这样就变成了支持向量机分类器类似的最优化问题。 基于密度比的异常检测由于无监督学习的异常检测中完全没有与异常值相关的信息，因此要想进行理想的异常检测是很困难的。异常值各式各样，对其进行模型化一般是比较困难的，而正常值则相对比较稳定，因此通过把非正常的数据看作是异常数据的方法，有望实现高精度的异常检测。 已知是正常值的样本$\\lbrace x’_{i’} \\rbrace_{i’=1}^{n’}$的概率密度$p’(x)$，测试样本$\\lbrace x_i \\rbrace_{i=1}^n$的概率密度值$\\lbrace p’(x_i) \\rbrace_{i=1}^n$就可以看作是正常度。当概率密度函数$p’(x)$的值较小的时候需要较高精度的估计，但是因为概率密度很低的时候数据基本上是没有的，所以想要进行高精度的估计往往是比较困难的。 因此，一般通过计算正常样本的概率密度$p’(x)$和测试样本的概率密度$p(x)$的比值 w(x) = \\frac{p'(x)}{p(x)}这样的密度比$w(x)$，对于正常样本会输出接近1的值，对于异常样本则会输出和1相差较大的值。因为密度比函数对异常值的变化较为明显，因此使用密度比可以很容易地进行异常值的检测。 如果密度比分母很小，则分子值得误差会相应地增加。利用KL散度密度比估计法可以不计算概率密度而直接进行密度比估计。 KL散度密度比估计法的算法流程： 给$\\alpha$以适当的初值 直到解$\\alpha$达到收敛精度为止，重复以下的参数更新计算 $\\alpha \\leftarrow \\alpha+ \\epsilon A^{\\intercal}(1./A\\alpha)$ $\\alpha \\leftarrow \\alpha + (1-b^{\\intercal}\\alpha)b/(b^{\\intercal}b)$ $\\alpha \\leftarrow max(0,\\alpha)$ $\\alpha \\leftarrow \\alpha/(b^{\\intercal}\\alpha)$ $\\epsilon$为表示梯度上升幅度的正常数。$A$是第$(i’,j)$个元素为$\\psi_j(x’_{j’})$的矩阵，1为所有元素为1的向量，“./”表示对各个元素进行除法运算，0为所有元素为0的向量，b为第$j$个元素为$\\frac{1}{n}\\sum_{i=1}^n \\psi_j(x_i)$的向量。另外，向量的max运算表示对各个单独元素进行max运算。步骤2.1为梯度上升，2.2到2.4分别与满足约束条件的各个正交投影矩阵相对应。","link":"/2020/05/09/%E5%9B%BE%E8%A7%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%20%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B/"},{"title":"图解机器学习&#x2F;第十八章 迁移学习","text":"利用过去学习的得到的经验、知识，来提高当前以及将来进行的学习任务的求解精度，这样的方式称为迁移学习。 协变量移位下的迁移学习在统计学里，输入变量称为协变量。协变量移位是指输入输出关系不变，协变量的概率分布发生变化的情况。 重要度加权学习 如果只利用当前学习任务的输入训练样本$\\lbrace x’_{i’} \\rbrace_{i’=1}^{n’}$近旁的输入输出训练样本$\\lbrace (x_i, y_i)\\rbrace _{i=1}^n$进行学习，一般是可以很好地对$\\lbrace x’_{i’} \\rbrace_{i’=1}^{n’}$的输出进行预测。这种思路可以通过使用输入输出训练样本的重要度权重进行学习来实现。 重要度，是指当前学习任务的输入训练样本$\\lbrace x’_{i’} \\rbrace_{i’=1}^{n’}$的概率密度$p’(x)$和原始学习任务的输入训练样本$\\lbrace x_i \\rbrace_{i=1}^n$的概率密度$p(x)$的比 w(x) = \\frac{p'(x)}{p(x)}重要度加权最小二乘学习 \\mathop{min}_{\\theta} \\frac{1}{2}\\sum_{i=1}^n w(x_i)(f_{\\theta}(x_i)-y_i)^2重要度加权最小二乘学习，理论上可以认为是统计学中的重要性采样，可以据此来理解其算法的本质。重要性采样，是指利用与$p(x)$相关的加权期望值来计算与$p’(x)$相关的期望值的方法 \\int g(x)p'(x)dx = \\int g(x)\\frac{p'(x)}{p(x)}p(x)dx \\approx \\frac{1}{n}\\sum_{i=1}^n g(x_i)w(x_i)相对重要度加权学习一般而言，当重要度函数$w(x)$的值非常大的时候，就特别容易引起不稳定现象，因此如果能使得重要度函数稍许平滑，就可以使学习结果稳定下来。为此可以使用比重要度稍微钝一些的相对重要度 w_{\\beta}(x) = \\frac{p'(x)}{\\beta p'(x)+(1-\\beta)p(x)}重要度加权模型选择 重要度加权交叉验证法的算法流程： 把训练样本$\\mathcal{T}=\\lbrace (x_i,y_i) \\rbrace_{i=1}^n$随机划分为$m$个集合$\\lbrace \\mathcal{T}_i \\rbrace_{i=1}^m$ 对$i=1,\\dots,m$循环执行如下操作 使用除$\\mathcal{T}_i$以外的训练样本$\\mathcal{T}/ \\mathcal{T}_i$，求解其学习结果$f_i$ 把上述过程中没有参与学习的训练样本$\\mathcal{T}_i$作为测试样本，对$f_i$的泛化误差进行重要度加权评估 \\hat{G}_i = \\begin{cases} \\frac{1}{|\\mathcal{T_i}|}\\sum_{(x,y)\\in \\mathcal{T}_i}w(x)(f_i(x)-y)^2 &\\text{回归} \\\\ \\frac{1}{|\\mathcal{T_i}|} \\sum_{(x,y)\\in \\mathcal{T}_i \\frac{w(x)}{2}}(1-sign(f_i(x)y)) &\\text{分类} \\end{cases}在这里，$|\\mathcal{T}_i|$表示集合$\\mathcal{T}_i$包含的训练样本的个数 对各个$i$的泛化误差的评估值$\\hat{G}_i$进行平均，得到最终的泛化误差$\\hat{G}$ \\hat{G}=\\frac{1}{m}\\sum_{i=1}^m \\hat{G}_i 重要度加权估计不计算概率密度而直接求得相对重要度的方法。 首先把相对重要度函数$w_{\\beta}(x)$用下式的与参数相关的线性模型进行模型化 w_{\\alpha}(x) = \\sum_{j=1}^b \\alpha_j \\psi_j(x) = \\alpha^{\\intercal}\\psi(x)在这里，$\\alpha = (\\alpha_1,\\dots,\\alpha_b)^{\\intercal}$为参数向量，$\\psi(x)=(\\psi_1(x), \\dots, \\psi_b(x))^{\\intercal}$为基函数向量。 类别平衡变化下的迁移学习类别平衡变化，是指各个类别的输入样本的概率分布不变，但是各个类别之间的样本数的平衡发生变化的情况。 类别平衡加权学习在分类问题中，有时候各个类别的样本数的平衡在训练样本和测试样本中是不一致的。为了使最终结果与测试样本的类别平衡相吻合，可以对训练样本进行加权学习，来纠正误差。 具体而言，就是在训练时的类别$y$出现的概率为$p(y)$，测试时的类别$y$出现的概率为$p’(y)$的时候，对$p’(y)/p(y)$的概率比进行加权学习。 最小二乘学习的情况下，进行如下式学习 \\mathop{min}_{\\theta}\\frac{1}{2}\\sum_{i=1}^n \\frac{p'(y_i)}{p(y_i)}(f_{\\theta}(x_i)-y_i)^2","link":"/2020/07/30/%E5%9B%BE%E8%A7%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%AC%AC%E5%8D%81%E5%85%AB%E7%AB%A0%20%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0/"},{"title":"图解机器学习&#x2F;第十章 概率分类法","text":"对模式基于概率进行分类的手法称为概率分类法。基于概率的模式识别，是指对与模式$x$所对应的类别$y$的后验概率$p(y|x)$进行学习。其所属类别为后验概率达到最大值时所对应的类别。 \\hat{y} = \\mathop{argmax}_{y=1,\\dots,c}p(y|x)类别的后验概率$p(y=\\hat{y}|x)$，可以理解为模式$x$属于类别$y$的可信度。另外，基于概率的模式识别算法还有一个优势，就是对于多种类别的分类问题通常会有较好的分类结果。 Logistic回归Logistic模型的最大似然估计Logistic回归，使用线性对数函数对分类后验概率$p(y|x)$进行模型化 q(y|x;\\theta)=\\frac{exp(\\sum_{j=1}^b \\theta_j^{(y)} \\phi_j(x)) }{\\sum_{y'=1}^c exp(\\sum_{j=1}^b \\theta_j^{(y')} \\phi_j(x))}Logistic回归模型的学习，通过对数似然为最大时的最大似然估计进行求解。 一般使用对数使得乘法变成加法的方法来防止丢位现象的发生。 Logistic回归的学习模式由下式的最优化问题来定义 \\mathop{max}_{\\theta}\\sum_{i=1}^n logq(y_i|x_i;\\theta) 使用概率梯度下降法的Logistic回归学习算法： 给$\\theta$以适当的初值 随机选择一个训练样本(选择顺序为$i$的训练样本$(x_i,y_i)$ 对于选定的训练样本，以梯度上升的方向对参数$\\theta = (\\theta^{(1)^{\\intercal}}, \\dots,\\theta^{(c)^{\\intercal}})^{\\intercal}$进行更新 \\theta^{(y)} \\leftarrow \\theta^{(y)} + \\epsilon \\nabla_yJ_i(\\theta)对于y=1,\\dots,c在这里，$\\epsilon$为表示梯度上升幅度的正的常数。$\\nabla_yJ_i$是指顺序为$i$的训练样本所对应的对数似然$J_i(\\theta)=logq(y_i|x_i;\\theta)$的关于$\\theta^{(y)}$的梯度上升的方向 \\nabla_yJ_i(\\theta) = -\\frac{exp(\\theta^{(y)^{\\intercal}} \\phi(x_i)) \\phi(x_i)}{\\sum_{y'=1}^c exp(\\theta^{(y‘)^{\\intercal}} \\phi(x_i))} + \\begin{cases} \\phi(x_i) &\\text{$y=y_i$}\\\\ 0 &\\text{$y \\not= y_i$} \\end{cases} 直到解$\\theta$达到收敛精度为止，重复上述2、3步计算 使用Logistic损失最小化学习来解释首先从2分类问题$y\\in \\lbrace +1,-1 \\rbrace$进行说明 q(y=+1|x;\\theta) + q(y=-1|x;\\theta)=1通过上述关系式，Logistic模型的参数个数就可以由2b个降为b个。 最小二乘概率分类最小二乘概率分类器，对于各个类别$y=1,\\dots,c$的后验概率$p(y|x)$，使用与参数相关的线性模型 q(y|x;\\theta^{(y)}) = \\sum_{j=1}^b \\theta_j^{(y)} \\phi_j(x) =\\theta^{(y)^{\\intercal}} \\phi(x_i)进行模型化，与Logistic模型不同的是，这个模型只依赖于与各个类别$y$对应的参数$\\theta^{(y)} = (\\theta_i^{(y)},\\dots, \\theta_b^{(y)})^{\\intercal}$。","link":"/2020/05/09/%E5%9B%BE%E8%A7%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E6%A6%82%E7%8E%87%E5%88%86%E7%B1%BB%E6%B3%95/"},{"title":"图解机器学习&#x2F;第四章 带有约束条件的最小二乘法","text":"单纯的最小二乘法对于包含噪声的学习过程经常有过拟合的弱点 部分空间约束的最小二乘学习法&emsp;通过把参数空间限制在一定范围内，来防止过拟合现象。 \\mathop{min}_{\\theta}J_{LS}(\\theta) \\quad 约束条件P\\theta=\\theta$P$是满足$P^2=P$和$P^{\\intercal}=P$的$b\\times b$矩阵，表示的是矩阵$P$的值域$\\mathcal{R}(P)$的正交投影矩阵。通过附加$P\\theta=P$约束条件，参数$\\theta$就不会偏移到值域$\\mathcal{R}(P)$范围外了。 $l_2$约束的最小二乘学习法 \\mathop{min}_{\\theta}J_{LS}(\\theta) \\quad 约束条件 \\quad ||\\theta||^2 \\le R&emsp;$l_2$约束的最小二乘学习法是以参数空间的原点为圆心，在一定半径范围的圆内进行秋季。$R$表示的即是圆的半径。 拉格朗日对偶问题 可微分的凸函数$f:\\mathbb{R}^d \\rightarrow \\mathbb{R}$和$g:\\mathbb{R}^d \\rightarrow \\mathbb{R}^p$的约束条件的最小化问题 \\mathop{min}_t f(t) \\quad 约束条件 \\quad g(t) \\le 0的拉格朗日对偶问题，可以使用拉格朗日乘子 \\lambda=(\\lambda_1,\\dots,\\lambda_p)^{\\intercal}和拉格朗日函数 L(t,\\lambda)=f(t)+\\lambda^{\\intercal}g(t)采用以下方式进行定义： \\mathop{max}_{\\lambda}\\mathop{inf}_t L(t,\\lambda) \\quad 约束条件 \\quad \\lambda \\ge 0拉格朗日对偶问题的$t$的解，与原来的问题的解是一致的。 \\mathop{max}_{\\lambda} \\mathop{min}_{\\theta}[J_{LS}(\\theta) + \\frac{\\lambda}{2}(||\\theta||^2)-R] \\quad 约束条件 \\quad \\lambda \\ge 0&emsp;拉格朗日对偶问题的拉格朗日乘子$\\lambda$的解由圆的半径$R$决定，如果不根据$R$来决定$\\lambda$，而是直接指定的话，$l_2$约束的最小二乘学习法的解 \\hat{\\theta}=\\mathop{argmin}_{\\theta}[J_{LS}(\\theta)+\\frac{\\lambda}{2}||\\theta||^2]上式的第一项$J_{LS}(\\theta)$表示的是对训练样本的拟合程度，通过与第二项的$\\frac{\\lambda}{2}||\\theta||^2$相结合得到最小值，来防止过拟合发生。 令偏微分为0，解得 \\hat{\\theta}=(\\Phi^{\\intercal}\\Phi + \\lambda I)^{-1}\\Phi^{\\intercal}y其中，$I$是单位矩阵。通过将矩阵$\\Phi^{\\intercal}\\Phi$与$\\lambda I$相加提高其正则性，进而就可以更稳定的进行逆矩阵的求解。 $l_2$正则化的最小二乘学习法在有些著作中也成为岭回归。 &emsp;如果考虑设计矩阵$\\Phi$的奇异值分解 \\Phi = \\sum_{k=1}^{min(n,b)} \\kappa_k \\psi_k \\varphi_k^{\\intercal}$l_2$约束的最小二乘学习法的解 \\hat{\\theta}=\\sum_{k=1}^{min(n,b)} \\frac{\\kappa_k}{\\kappa_k^2+\\lambda}\\psi_k^{\\intercal}y\\varphi_k 当设计矩阵$\\Phi$的计算条件很恶劣，即包含非常小的奇异值$\\kappa_k$的时候，$\\frac{\\kappa}{\\kappa^2}$就会变成非常大的数值，训练输出向量$y$包含的噪声就会有所增加。另一方面，在$l_2$约束的最小二乘法中，通过在分母的$\\kappa_k^2$中加入正的常数$\\lambda$，使$\\kappa_k / (\\kappa_k^2+\\lambda)$避免变得过大，进而可以达到防止过拟合的目的。 通过使用$b\\times b$的正则化矩阵$G$，就可以得到更为普遍的表示方法 \\mathop{min}_{\\theta}J_{LS}(\\theta) \\quad 约束条件 \\quad \\theta^{\\intercal}G\\theta \\le R \\\\ \\hat{\\theta}=(\\Phi^{\\intercal}\\Phi + \\lambda G)^{-1}\\Phi^{\\intercal}y模型选择&emsp;通过采用不同的输入训练样本，来决定机器学习算法中包含的各个参数值，一般称为模型选择。 一般的模型选择流程 准备模型的候选$M_1,\\dots,M_k$ 对各个模型$M_1,\\dots,M_k$求解其学习结果$f^{(1),\\dots,f^{(k)}}$ 对各学习结果$f^{(1),\\dots,f^{(k)}}$的泛化误差$G^{(1)},\\dots,G^{(k)}$进行评价 选择泛化误差$G^{(1)},\\dots,G^{(k)}$最小的模型为最终模型 泛化是指学习机器对未知的测试输入样本的处理能力，泛化误差是指对未知的测试输入样本的输出所做的预测的误差 &emsp;交叉验证发用于评估模型发话误差，在交叉验证法中，把训练样本的一部分拿出来作为测试样本，不将其用于学习，而只用于评价最终学习结果的泛化误差。 分割数为m的交叉验证法一般称为m折交叉验证。 分割的集合数m设定为训练样本数n的交叉验证法， 即对n-1个训练样本及进行学习，将余下的1个作为测试样本的方法，称为留一交叉验证法。","link":"/2020/05/09/%E5%9B%BE%E8%A7%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E5%B8%A6%E6%9C%89%E7%BA%A6%E6%9D%9F%E6%9D%A1%E4%BB%B6%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95/"},{"title":"尚硅谷JVM&#x2F;第七章_本地方法栈","text":"本地方法栈(Native Method Stack) Java 虚拟机栈用于管理 Java 方法的调用，而本地方法栈用于管理本地方法的调用。 本地方法栈，也是线程私有的。 允许被实现成固定或者是可动态扩展的内存大小。（在内存溢出方面是相同的） 如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java 虚拟机将会抛出一个 StackOverFlowError 异常。 如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么 Java 虚拟机将会抛出一个 OutOfMemoryError 异常。 本地方法是使用 C 语言实现的。 它的具体做法是 Native Method Stack 中登记 native 方法，在 Execution Engine 执行时加载本地方法库。 当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。 本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区。 它甚至可以直接使用本地处理器中的寄存器 直接从本地内存的堆中分配任意数量的内存。 并不是所有的 JVM 都支持本地方法。因为 Java 虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果 JVM 产品不打算支持 native 方法，也可以无需实现本地方法栈。 在 HotSpot JVM 中，直接将本地方法栈和虚拟机栈合二为一。","link":"/2020/10/16/%E5%B0%9A%E7%A1%85%E8%B0%B7JVM/%E7%AC%AC%E4%B8%83%E7%AB%A0_%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88/"},{"title":"图解机器学习&#x2F;第十六章 半监督学习","text":"灵活应用输入数据的流形构造半监督学习会首先假定输入概率密度$p(x)$和条件概率密度$p(y|x)$之间具有某种关联，利用对输入概率密度$p(x)$的估计来辅助对条件概率密度$p(y|x)$的估计，进而使得最终的学习精度得以提升。 流形是一数学用于，一般指局部具有欧几里得空间性质的图形，在半监督学习里指的是输入空间的局部范围。半监督学习中流形的假设，即输入数据只出现在某个流形上，输出则在该流形上平滑的变化。 高斯核函数实际上是灵活运用了流行的假设后形成的模型 f_{\\theta}(x)=\\sum_{j=1}^n \\theta_j K(x,x_j), K(x,c)=exp(-\\frac{||x-c||^2}{2h^2})即通过在训练输入样本$\\lbrace x_i \\rbrace_{i=1}^n$上设置平滑的高斯核函数，进而使得输入数据在流形上学习得到平滑的输入输出函数。 半监督学习在核函数的构成中，也应用了只有输入数据的训练样本$\\lbrace x_i \\rbrace_{i=n+1}^{n+n’}$ f_{\\theta}(x)=\\sum_{j=1}^{n+n'} \\theta_j K(x,x_j)另外，为了使训练输入样本的输出$\\lbrace f_{\\theta}(x_i) \\rbrace_{i=n+1}^{n+n’}$拥有局部相似值，还需要添加约束条件。对于$l_2$正则化最小二乘学习的情况，有以下学习规则 \\mathop{min}_{\\theta}[\\frac{1}{2}\\sum_{i=1}^n(f_{\\theta}(x_i)-y_i)^2 + \\frac{\\lambda}{2}||\\theta||^2+ \\frac{v}{4}\\sum_{i,i'=1}^{n+n'}W_{i,i'}(f_{\\theta}(x_i) - f_{\\theta}(x_i'))^2]其中第一项和第二项与$l_2$正则化最小二乘学习相对应。第三项是进行半监督学习所需的正则化项，称为拉普拉斯正则化。$v \\ge 0$是调整流形的平滑性的半监督学习的正则化参数。$W_{i,i’} \\ge0$是$x_i$和$x_{i’}$的相似度，当$x_i$和$x_{i’}$相似的时候，$W_{i,i’}$具有较大的值；当$x_i$和$x_{i’}$不相似的时候，$W_{i,i’}$具有较小的值。$W_{i,i’}$是对称的，即假定满足$W_{i,i’}=W_{i’,i}$。 拉普拉斯正则化最小二乘学习的求解方法对角元素为矩阵$W$的各行元素之和的对角矩阵用$D$来表示，矩阵$D$和矩阵$W$的差用矩阵$L$表示。上式第三项可以简化为 \\sum_{i,i'=1}^{n+n'}W_{i,i'}(f_{\\theta}(x_i) - f_{\\theta}(x_i'))^2 =\\sum_{i=1}^{n+n'}D_{i,i}f_{\\theta}(x_i)^2 - 2\\sum_{i,i'=1}^{n+n'}W_{i,i'}f_{\\theta}(x_i)f_{\\theta}(x_{i'})+\\sum_{i'=1}^{n+n'}D_{i',i'}f_{\\theta}(x_i)^2\\\\ =2 \\sum_{i,i'=1}^{n+n'}L_{i,i'}f_{\\theta}(x_i)f_{\\theta}(x_{i'})使用这样的表现形式，就可以归结为一般化$l_2$约束的最小二乘学习。 拉普拉斯正则化的解释把输入数据在流形上进行函数平滑的半监督学习算法称为拉普拉斯正则化。 对于训练输入样本$\\lbrace x_i \\rbrace_{i=n+1}^{n+n’}$的相似度$W_{i,i’}$，从如下图论规则进行说明 将训练输入样本$V=\\lbrace 1,\\dots,n+n’ \\rbrace$作为接点 当$W_{i,i’}=1$的时候，接点$i$和$i’$之间有分支；当$W_{i,i’}=0$的时候，接点$i$和$i’$之间没有分支。 在图论中，表示分支有无的矩阵$W$称为邻接矩阵。这个矩阵$W$的各行元素之和与各个接点相连接的分支的个数相对应。以维度为对角元素的对角矩阵$D$，有$L=D-W$，称为拉普拉斯矩阵（图论矩阵）。 在基于拉普拉斯正则化的半监督学习中，分支连接的各接点具有相同的类别标签。即通过从有标签的接点向没有标签的接点传播标签，相互连接的接点就可以实现标签的共享。 通常的最小二乘学习，可以理解为利用有一正一负的标签的训练样本，基于样本间的欧氏距离来求解其分类面。与此相对，拉普拉斯正则化学习，则可以理解为沿着输入样本的流形计算路径距离（图论中为最短路径），基于样本间的最短路径来求解其分类面。利用这样的方法，就可以把各个聚类中的所有数据，都归类到相同的类别中。","link":"/2020/05/09/%E5%9B%BE%E8%A7%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0%20%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/"},{"title":"尚硅谷JVM&#x2F;第三章_运行时数据区概述及线程","text":"运行时数据区概述及线程概述 本节主要讲的是运行时数据区，也就是下图这部分，它是在类加载完成后的阶段 当我们通过前面的：类的加载-&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化 这几个阶段完成后，就会用到执行引擎对我们的类进行使用，同时执行引擎将会使用到我们运行时数据区 也就是大厨做饭，我们把大厨后面的东西（切好的菜，刀，调料），比作是运行时数据区。而厨师可以类比于执行引擎，将通过准备的东西进行制作成精美的菜品 内存是非常重要的系统资源，是硬盘和 CPU 的中间仓库及桥梁，承载着操作系统和应用程序的实时运行 JVM 内存布局规定了 Java 在运行过程中内存申请、分配、管理的策略，保证了 JVM 的高效稳定运行。不同的 JVM 对于内存的划分方式和管理机制存在着部分差异。结合 JVM 虚拟机规范，来探讨一下经典的 JVM 内存布局。 我们通过磁盘或者网络 IO 得到的数据，都需要先加载到内存中，然后 CPU 从内存中获取数据进行读取，也就是说内存充当了 CPU 和磁盘之间的桥梁 运行时数据区的完整图 Java 虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。 灰色的为单独线程私有的，红色的为多个线程共享的。即： 每个线程：独立包括程序计数器、栈、本地栈。 线程间共享：堆、堆外内存（永久代或元空间、代码缓存） 每个 JVM 只有一个 Runtime 实例。即为运行时环境。 线程 线程是一个程序里的运行单元。JVM 允许一个应用有多个线程并行的执行。 在 HotSpot JVM 里，每个线程都与操作系统的本地线程直接映射。 当一个 Java 线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java 线程执行终止后，本地线程也会回收。 操作系统负责所有线程的安排调度到任何一个可用的 CPU 上。一旦本地线程初始化成功，它就会调用 Java 线程中的 run() 方法。 JVM 系统线程如果你使用 jconsole 或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用public static void main(String[]) 的 main 线程以及所有这个 main 线程自己创建的线程。这些主要的后台系统线程在 HotSpot JVM 里主要是以下几个： 虚拟机线程：这种线程的操作是需要 JVM 达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要 JVM 达到安全点，这样堆才不会变化。这种线程的执行类型包括 “Stop-The-World” 的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销。 周期任务线程：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行。 GC 线程：这种线程对在 JVM 里不同种类的垃圾收集行为提供了支持。 编译线程：这种线程在运行时会将字节码编译成到本地代码。 信号调度线程：这种线程接收信号并发送给 JVM，在它内部通过调用适当的方法进行处理。","link":"/2020/10/16/%E5%B0%9A%E7%A1%85%E8%B0%B7JVM/%E7%AC%AC%E4%B8%89%E7%AB%A0_%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%BA%BF%E7%A8%8B/"},{"title":"尚硅谷JVM&#x2F;第一章_JVM与Java体系结构","text":"JVM 与 Java 体系结构前言 作为 Java 工程师的你曾被伤害过吗？你是否也遇到过这些问题？ 运行着的线上系统突然卡死，系统无法访问，甚至直接 OOM ！ 想解决线上 JVM GC 问题，但却无从下手。 新项目上线，对各种 JVM 参数设置一脸茫然，直接默认吧然后就 GG 了 每次面试之前都要重新背一遍 JVM 的一些原理概念性的东西，然而面试官却经常问你在实际项目中如何调优VM 参数，如何解决 GC、OOM 等问题，一脸懵逼。 大部分 Java 开发人员，除会在项目中使用到与 Java 平台相关的各种高精尖技术，对于 Java 技术的核心 Java 虚拟机了解甚少。 一些有一定工作经验的开发人员，打心眼儿里觉得 SSM 、微服务等上层技术才是重点，基础技术并不重要，这其实是一种本末倒置的“病态”。如果我们把核心类库的 API 比做数学公式的话，那么 Java 虚拟机的知识就好比公式的推导过程。 计算机系统体系对我们来说越来越远，在不了解底层实现方式的前提下，通过高级语言很容易编写程序代码。但事实上计算机并不认识高级语言 架构师每天都在思考什么？ 应该如何让我的系统更快？ 如何避免系统出现瓶颈？ 知乎上有条帖子：应该如何看招聘信息，直通年薪50万+？ 参与现有系统的性能优化，重构，保证平台性能和稳定性 根据业务场景和需求，决定技术方向，做技术选型 能够独立架构和设计海量数据下高并发分布式解决方案，满足功能和非功能需求 解决各类潜在系统风险，核心功能的架构与代码编写 分析系统瓶颈，解决各种疑难杂症，性能调优等 为什么要学习 JVM 面试的需要（BATJ、TMD，PKQ等面试都爱问） 中高级程序员必备技能 项目管理、调优的需求 追求极客的精神 比如：垃圾回收算法、JIT（及时编译器）、底层原理 Java vs C++垃圾收集机制为我们打理了很多繁琐的工作，大大提高了开发的效率，但是，垃圾收集也不是万能的，懂得 JVM内部的内存结构、工作机制，是设计高扩展性应用和诊断运行时问题的基础，也是 Java 工程师进阶的必备能力。 C 语言需要自己来分配内存和回收内存，Java 全部交给 JVM 进行分配和回收。 参考书目 Java 及 JVM 简介Java：跨平台的语言Java 是目前应用最为广泛的软件开发平台之一。随着 Java 以及 Java 社区的不断壮大 Java 也早已不再是简简单单的一门计算机语言了，它更是一个平台、一种文化、一个社区。 作为一个平台，Java 虚拟机扮演着举足轻重的作用 Groovy、Scala、JRuby、Kotlin等都是Java平台的一部分 作为一种文化，Java 几乎成为了“开源”的代名词。 第三方开源软件和框架。如Tomcat、Struts，MyBatis，Spring等。 就连 JDK 和 JVM 自身也有不少开源的实现，如OpenJDK、Harmony。 作为一个社区，Java 拥有全世界最多的技术拥护者和开源社区支持，有数不清的论坛和资料。从桌面应用软件、嵌入式开发到企业级应用、后台服务器、中间件，都可以看到 Java 的身影。其应用形式之复杂、参与人数之众多也令人咂舌。 每个语言都需要转换成字节码文件，最后转换的字节码文件都能通过 Java 虚拟机进行运行和处理 JVM：跨平台的语言 随着 Java 7 的正式发布，Java 虚拟机的设计者们通过 JSR-292 规范基本实现在 Java 虚拟机平台上运行非 Java语言编写的程序。 Java 虚拟机根本不关心运行在其内部的程序到底是使用何种编程语言编写的，它只关心“字节码”文件。也就是说 Java 虚拟机拥有语言无关性，并不会单纯地与 Java 语言“终身绑定”，只要其他编程语言的编译结果满足并包含 Java 虚拟机的内部指令集、符号表以及其他的辅助信息，它就是一个有效的字节码文件，就能够被虚拟机所识别并装载运行。 字节码我们平时说的 Java 字节码，指的是用 Java 语言编译成的字节码。准确的说任何能在 JVM 平台上执行的字节码格式都是一样的。所以应该统称为：JVM 字节码。 不同的编译器，可以编译出相同的字节码文件，字节码文件也可以在不同的 JVM 上运行。 Java 虚拟机与 Java 语言并没有必然的联系，它只与特定的二进制文件格式— Class 文件格式所关联，Class 文件中包含了 Java 虚拟机指令集（或者称为字节码、Bytecodes）和符号表，还有一些其他辅助信息。 多语言混合编程Java 平台上的多语言混合编程正成为主流，通过特定领域的语言去解决特定领域的问题是当前软件开发应对日趋复杂的项目需求的一个方向。 试想一下，在一个项目之中，并行处理用 Clojure 语言编写，展示层使用 JRuby/Rails ，中间层则是 Java ，每个应用层都将使用不同的编程语言来完成，而且，接口对每一层的开发者都是透明的，各种语言之间的交互不存在任何困难，就像使用自己语言的原生 API 一样方便，因为它们最终都运行在一个虚拟机之上。 对这些运行于 Java 虚拟机之上、Java 之外的语言，来自系统级的、底层的支持正在迅速增强，以 JSR-292 为核心的一系列项目和功能改进（如 Da Vinci Machine 项目、Nashorn 引擎、InvokeDynamic 指令、java.lang.invoke 包等），推动 Java 虚拟机从“Java 语言的虚拟机”向 “多语言虚拟机”的方向发展。 Java发展的重大事件 1990年，在 Sun 计算机公司中，由 Patrick Naughton、MikeSheridan 及 James Gosling 领导的小组Green Team，开发出的新的程序语言，命名为 oak ，后期命名为 Java 1995年，Sun 正式发布 Java 和 HotJava 产品，Java 首次公开亮相。 1996年1月23日 Sun Microsystems 发布了 JDK 1.0。 1998年，JDK 1.2 版本发布。同时，Sun 发布了 JSP/Servlet、EJB 规范，以及将 Java 分成了 J2EE、J2SE 和 J2ME。这表明了 Java 开始向企业、桌面应用和移动设备应用3大领域挺进。 2000年，JDK 1.3 发布，Java HotSpot Virtual Machine 正式发布，成为 Java 的默认虚拟机。 2002年，JDK 1.4 发布，古老的 Classic 虚拟机退出历史舞台。 2003年年底，Java 平台的 Scala 正式发布，同年 Groovy 也加入了 Java 阵营。 2004年，JDK 1.5 发布。同时 JDK 1.5 改名为 JavaSE 5.0。 2006年，JDK 6 发布。同年，Java 开源并建立了 OpenJDK。顺理成章，HotSpot 虚拟机也成为了OpenJDK 中的默认虚拟机。 2007年，Java 平台迎来了新伙伴 Clojure。 2008年，Oracle 收购了 BEA，得到了 JRockit 虚拟机。 2009年，Twitter 宣布把后台大部分程序从 Ruby 迁移到 Scala ，这是 Java 平台的又一次大规模应用。 2010年，Oracle 收购了 Sun，获得 Java 商标和最真价值的 HotSpot 虚拟机。此时，Oracle 拥有市场占用率最高的两款虚拟机 HotSpot 和 JRockit，并计划在未来对它们进行整合：HotRockit 2011年，JDK 7 发布。在 JDK 1.7u4 中，正式启用了新的垃圾回收器 G1。 2017年，JDK 9 发布。将 G1 设置为默认 GC，替代 CMS 同年，IBM 的 J9 开源，形成了现在的 Open J9 社区 2018年，Android 的 Java 侵权案判决，Google 赔偿 Oracle 计88亿美元 同年，Oracle 宣告 JavaEE 成为历史名词 JDBC、JMS、Servlet 赠予 Eclipse 基金会 同年，JDK 11 发布，LTS 版本的 JDK，发布革命性的 ZGC，调整 JDK 授权许可 2019年，JDK 12 发布，加入 RedHat 领导开发的 Shenandoah GC 在 JDK 11 之前，OracleJDK 中还会存在一些 OpenJDK 中没有的、闭源的功能。但在 JDK 11 中，我们可以认为 OpenJDK 和 OracleJDK 代码实质上已经完全一致的程度。 虚拟机与 Java 虚拟机虚拟机所谓虚拟机（Virtual Machine），就是一台虚拟的计算机。它是一款软件，用来执行一系列虚拟计算机指令。大体上，虚拟机可以分为系统虚拟机和程序虚拟机。 大名鼎鼎的 Visual Box，VMware 就属于系统虚拟机，它们完全是对物理计算机的仿真，提供了一个可运行完整操作系统的软件平台。 程序虚拟机的典型代表就是 Java 虚拟机，它专门为执行单个计算机程序而设计，在 Java 虚拟机中执行的指令我们称为 Java 字节码指令。 无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中。 Java虚拟机Java 虚拟机是一台执行 Java 字节码的虚拟计算机，它拥有独立的运行机制，其运行的 Java 字节码也未必由 Java 语言编译而成。 JVM 平台的各种语言可以共享 Java 虚拟机带来的跨平台性、优秀的垃圾回器，以及可靠的即时编译器。 Java 技术的核心就是 Java 虚拟机（JVM，Java Virtual Machine），因为所有的 Java 程序都运行在 Java 虚拟机内部。 作用： Java 虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释/编译为对应平台上的机器指令执行。每一条 Java 指令，Java 虚拟机规范中都有详细定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里。 特点： 一次编译，到处运行 自动内存管理 自动垃圾回收功能 JVM 的位置JVM 是运行在操作系统之上的，它与硬件没有直接的交互 Java 的体系结构 JVM 的整体结构 HotSpot VM 是目前市面上高性能虚拟机的代表作之一。 它采用解释器与即时编译器并存的架构。 在今天，Java 程序的运行性能早已脱胎换骨，已经达到了可以和 C/C++ 程序一较高下的地步。 执行引擎包含三部分：解释器，及时编译器，垃圾回收器 Java 代码执行流程 只是能生成被 Java 虚拟机所能解释的字节码文件，那么理论上就可以自己设计一套代码了 JVM 的架构模型Java 编译器输入的指令流基本上是一种基于栈的指令集架构，另外一种指令集架构则是基于寄存器的指令集架构。具体来说：这两种架构之间的区别： 基于栈式架构的特点： 设计和实现更简单，适用于资源受限的系统； 避开了寄存器的分配难题：使用零地址指令方式分配。 指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现。 不需要硬件支持，可移植性更好，更好实现跨平台 基于寄存器架构的特点 典型的应用是 x86 的二进制指令集：比如传统的 PC 以及 Android 的 Davlik 虚拟机。 指令集架构则完全依赖硬件，可移植性差 性能优秀和执行更高效 花费更少的指令去完成一项操作。 在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主 举例同样执行2+3这种逻辑操作，其指令分别如下： 基于栈的计算流程（以Java虚拟机为例）： 12345678iconst_2 // 常量2入栈istore_1iconst_3 // 常量3入栈istore_2iload_1iload_2iadd //常量2/3出栈，执行相加istore_0 // 结果5入栈 而基于寄存器的计算流程 12mov eax,2 //将eax寄存器的值设为1add eax,3 //使eax寄存器的值加3 字节码反编译我们编写一个简单的代码，然后查看一下字节码的反编译后的结果 12345public class StackStruTest { public static void main(String[] args) { int i = 2 + 3; }} 然后我们找到编译后的 class 文件，使用下列命令进行反编译 1javap -v(verbose) StackStruTest.class 得到的文件为: 12345678910111213141516171819202122232425public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=4, args_size=1 0: iconst_2 1: istore_1 2: iconst_3 3: istore_2 4: iload_1 5: iload_2 6: iadd 7: istore_3 8: return LineNumberTable: line 9: 0 line 10: 2 line 11: 4 line 12: 8 LocalVariableTable: Start Length Slot Name Signature 0 9 0 args [Ljava/lang/String; 2 7 1 i I 4 5 2 j I 8 1 3 k I 总结由于跨平台性的设计，Java 的指令都是根据栈来设计的。不同平台 CPU 架构不同，所以不能设计为基于寄存器的。优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。 时至今日，尽管嵌入式平台已经不是 Java 程序的主流运行平台了（准确来说应该是 HotSpotVM 的宿主环境已经不局限于嵌入式平台了），那么为什么不将架构更换为基于寄存器的架构呢？ 栈 跨平台性 指令集小 指令多 执行性能比寄存器差 JVM 的生命周期虚拟机的启动Java 虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。 虚拟机的执行 一个运行中的 Java 虚拟机有着一个清晰的任务：执行 Java 程序。 程序开始执行时他才运行，程序结束时他就停止。 执行一个所谓的 Java 程序的时候，真真正正在执行的是一个叫做 Java 虚拟机的进程。 虚拟机的退出有如下的几种情况： 程序正常执行结束 程序在执行过程中遇到了异常或错误而异常终止 由于操作系统用现错误而导致 Java 虚拟机进程终止 某线程调用 Runtime 类或 System 类的 exit 方法，或 Runtime 类的 halt 方法，并且 Java 安全管理器也允许这次 exit 或 halt 操作。 除此之外，JNI（Java Native Interface）规范描述了用 JNI Invocation API 来加载或卸载 Java 虚拟机时，Java 虚拟机的退出情况。 JVM 发展历程Sun Classic VM 早在1996年 Java1.0 版本的时候，Sun 公司发布了一款名为 Sun Classic VM 的 Java 虚拟机，它同时也是世界上第一款商用 Java 虚拟机，JDK 1.4 时完全被淘汰。 这款虚拟机内部只提供解释器。现在还有及时编译器，因此效率比较低，而及时编译器会把热点代码缓存起来，那么以后使用热点代码的时候，效率就比较高。 如果使用 JIT 编译器，就需要进行外挂。但是一旦使用了 JIT 编译器，JIT 就会接管虚拟机的执行系统。解释器就不再工作。解释器和编译器不能配合工作。 现在 HotSpot 内置了此虚拟机。 Exact VM为了解决上一个虚拟机问题，JDK 1.2 时，Sun 提供了此虚拟机。Exact Memory Management：准确式内存管理 也可以叫 Non-Conservative/Accurate Memory Management 虚拟机可以知道内存中某个位置的数据具体是什么类型。 具备现代高性能虚拟机的维形 热点探测（寻找出热点代码进行缓存） 编译器与解释器混合工作模式 只在 Solaris 平台短暂使用，其他平台上还是 Classic VM， 英雄气短，终被 HotSpot 虚拟机替换 HotSpot VMHotSpot 历史 最初由一家名为“Longview Technologies”的小公司设计 1997年，此公司被 Sun 收购；2009年，Sun 公司被甲骨文收购。 JDK 1.3 时，HotSpot VM 成为默认虚拟机 目前 HotSpot 占有绝对的市场地位，称霸武林。 不管是现在仍在广泛使用的 JDK 6 ，还是使用比例较多的 JDK 8 中，默认的虚拟机都是 HotSpot Sun/Oracle JDK 和 OpenJDK 的默认虚拟机 因此本课程中默认介绍的虚拟机都是 HotSpot，相关机制也主要是指 HotSpot 的 GC 机制。（比如其他两个商用虚机都没有方法区的概念） 从服务器、桌面到移动端、嵌入式都有应用。 名称中的 HotSpot 指的就是它的热点代码探测技术。 通过计数器找到最具编译价值代码，触发即时编译或栈上替换 通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡 JRockit专注于服务器端应用 它可以不太关注程序启动速度，因此 JRockit 内部不包含解析器实现，全部代码都靠即时编译器编译后执行。 大量的行业基准测试显示，JRockit JVM 是世界上最快的 JVM。 使用 JRockit 产品，客户已经体验到了显著的性能提高（一些超过了70%）和硬件成本的减少（达50%）。 优势：全面的 Java 运行时解决方案组合 JRockit 面向延迟敏感型应用的解决方案 JRockit Real Time 提供以毫秒或微秒级的 JVM 响应时间，适合财务、军事指挥、电信网络的需要 MissionControl 服务套件，它是一组以极低的开销来监控、管理和分析生产环境中的应用程序的工具。 2008年，JRockit 被 Oracle 收购。 Oracle 表达了整合两大优秀虚拟机的工作，大致在 JDK 8 中完成。整合的方式是在 HotSpot 的基础上，移植JRockit 的优秀特性。 高斯林：目前就职于谷歌，研究人工智能和水下机器人 IBM 的 J9全称：IBM Technology for Java Virtual Machine，简称 IT4J，内部代号：J9 市场定位与 HotSpot 接近，服务器端、桌面应用、嵌入式等多用途 VM 广泛用于 IBM 的各种 Java 产品。 目前，有影响力的三大商用虚拟机之一，也号称是世界上最快的 Java 虚拟机。 2017年左右，IBM 发布了开源 J9 VM，命名为 OpenJ9，交给 EClipse 基金会管理，也称为 Eclipse OpenJ9 OpenJDK -&gt; 是 JDK 开源了，包括了虚拟机 KVM 和 CDC / CLDC HotSpotOracle 在 Java ME 产品线上的两款虚拟机为：CDC/CLDC HotSpot Implementation VM KVM（Kilobyte）是 CLDC-HI 早期产品目前移动领域地位尴尬，智能机被 Angroid 和 IOS 二分天下。 KVM 简单、轻量、高度可移植，面向更低端的设备上还维持自己的一片市场 智能控制器、传感器 老人手机、经济欠发达地区的功能手机 所有的虚拟机的原则：一次编译，到处运行。 Azul VM前面三大“高性能 Java 虚拟机”使用在通用硬件平台上这里 Azul VW 和 BEALiquid VM 是与特定硬件平台绑定、软硬件配合的专有虚拟机 高性能 Java 虚拟机中的战斗机。 Azul VM 是 Azul Systems 公司在 HotSpot 基础上进行大量改进，运行于 Azul Systems 公司的专有硬件 Vega系统上的 Java 虚拟机。 每个 Azul VM 实例都可以管理至少数十个 CPU 和数百GB内存的硬件资源，并提供在巨大内存范围内实现可控的 GC 时间的垃圾收集器、专有硬件优化的线程调度等优秀特性。 2010年，Azul Systems 公司开始从硬件转向软件，发布了自己的 Zing JVM，可以在通用 x86 平台上提供接近于 Vega 系统的特性。 Liquid VM高性能 Java 虚拟机中的战斗机。 BEA 公司开发的，直接运行在自家 Hypervisor 系统上 Liquid VM 即是现在的 JRockit VE（Virtual Edition），Liquid VM 不需要操作系统的支持，或者说它自己本身实现了一个专用操作系统的必要功能，如线程调度、文件系统、网络支持等。 随着 JRockit 虚拟机终止开发，Liquid VM 项目也停止了。 Apache MarmonyApache 也曾经推出过与 JDK 1.5 和 JDK 1.6 兼容的 Java 运行平台 Apache Harmony。 它是 IBM 和 Intel 联合开发的开源 JVM，受到同样开源的 OpenJDK 的压制，Sun 坚决不让 Harmony 获得 JCP 认证，最终于2011年退役，IBM 转而参与 OpenJDK 虽然目前并没有 Apache Harmony 被大规模商用的案例，但是它的 Java 类库代码吸纳进了 Android SDK。 Micorsoft JVM微软为了在 IE3 浏览器中支持 Java Applets，开发了 Microsoft JVM。 只能在 Windows 平台下运行。但确是当时 Windows 下性能最好的 Java VM。 1997年，Sun 以侵犯商标、不正当竞争罪名指控微软成功，赔了 Sun 很多钱。微软 Windows XP SP3 中抹掉了其 VM。现在 Windows 上安装的 JDK 都是 HotSpot。 Taobao JVM由 AliJVM 团队发布。阿里，国内使用 Java 最强大的公司，覆盖云计算、金融、物流、电商等众多领域，需要解决高并发、高可用、分布式的复合问题。有大量的开源产品。 基于 OpenJDK 开发了自己的定制版本 AlibabaJDK，简称 AJDK。是整个阿里 Java 体系的基石。 基于 OpenJDK HotSpot VM 发布的国内第一个优化、深度定制且开源的高性能服务器版 Java 虚拟机。 创新的 GCIH（GC Invisible Heap）技术实现了 Off-Heap，即将生命周期较长的 Java 对象从 Heap 中移到Heap 之外，并且 GC 不能管理 GCIH 内部的 Java 对象，以此达到降低 GC 的回收频率和提升 GC 的回收效率的目的。 GCIH 中的对象还能够在多个 Java 虚拟机进程中实现共享 使用 crc32 指令实现 JVM Intrinsic 降低 JNI 的调用开销 PMU Hardware 的 Java Profiling Tool 和诊断协助功能 针对大数据场景的 ZenGC TaoBao VM 应用在阿里产品上性能高，硬件严重依赖 Intel 的 CPU，损失了兼容性，但提高了性能 目前已经在淘宝、天猫上线，把 Oracle 官方 JVM 版本全部替换了。 Dalvik VM谷歌开发的，应用于 Android 系统，并在 Android 2.2 中提供了 JIT，发展迅猛。 Dalvik 只能称作虚拟机，而不能称作“Java 虚拟机”，它没有遵循 Java 虚拟机规范 不能直接执行 Java 的 Class 文件 基于寄存器架构，不是 JVM 的栈架构。 执行的是编译以后的 dex（Dalvik Executable）文件。执行效率比较高。 它执行的 dex（Dalvik Executable）文件可以通过 class 文件转化而来，使用 Java 语法编写应用程序，可以直接使用大部分的 Java API 等。 Android 5.0 使用支持提前编译（Ahead of Time Compilation，AoT）的 ART VM 替换 Dalvik VM。 Graal VM2018年4月，Oracle Labs 公开了 Graal VM，号称 “Run Programs Faster Anywhere”，勃勃野心。与1995年Java 的”write once，run anywhere”遥相呼应。 Graal VM 在 HotSpot VM 基础上增强而成的跨语言全栈虚拟机，可以作为“任何语言”的运行平台使用。语言包括：Java、Scala、Groovy、Kotlin；C、C++、Javascript、Ruby、Python、R 等 支持不同语言中混用对方的接口和对象，支持这些语言使用已经编写好的本地库文件 工作原理是将这些语言的源代码或源代码编译后的中间格式，通过解释器转换为能被 Graal VM 接受的中间表示。Graal VM 提供 Truffle 工具集快速构建面向一种新语言的解释器。在运行时还能进行即时编译优化，获得比原生编译器更优秀的执行效率。 如果说 HotSpot 有一天真的被取代，Graal VM 希望最大。但是 Java 的软件生态没有丝毫变化。 总结具体 JVM 的内存结构，其实取决于其实现，不同厂商的 JVM，或者同一厂商发布的不同版本，都有可能存在一定差异。主要以 Oracle HotSpot VM 为默认虚拟机。","link":"/2020/10/16/%E5%B0%9A%E7%A1%85%E8%B0%B7JVM/%E7%AC%AC%E4%B8%80%E7%AB%A0_JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"},{"title":"图解机器学习&#x2F;第十四章 聚类","text":"聚类是无监督机器学习方法的一种。 K均值聚类 K均值聚类的算法流程： 给各个簇中心$\\mu_1,\\dots,\\mu_c$以适当的初值 更新样本$x_1,\\dots,x_n$对应的簇标签$y_1,\\dots,y_n$ y_i \\leftarrow \\mathop{argmin}_{y\\in \\lbrace 1,\\dots,c \\rbrace}||x_i - \\mu_y||^2,i=1,\\dots,n 更新各个簇中心$\\mu_1,\\dots,\\mu_c$ \\mu_y \\leftarrow \\frac{1}{n_y}\\sum_{i:y_i=y}x_i,y=1,\\dots,c上式中，$n_y$为属于簇$y$的样本总数 直到簇标签达到收敛精度为止，重复上述2、3步的计算。 核K均值聚类由于K均值聚类是依据欧氏距离的大小来决定样本所属的簇，因此只能处理线性可分的聚类问题。利用核映射的方法就可以得到处理非线性可分的聚类问题的核K均值聚类算法。 具体而言，首先把欧氏距离的平方$||x-\\mu_y||^2$用样本间的内积$\\langle x,x’ \\rangle$来表示 ||x-\\mu_y||^2=||x - \\frac{1}{n_y}\\sum_{i:y_i=y}x_i||^2=\\langle x,x \\rangle - \\frac{1}{n_y}\\sum_{i:y_i=y}\\langle x,x_i \\rangle \\frac{1}{n_y^2} \\sum_{i,i':y_i=y_{i'}=y} \\langle x,x_{i'} \\rangle将上式內积置换为核函数$K(x,x’)$，就变成了核K均值聚类算法 y \\leftarrow \\mathop{argmin}_{y \\in \\lbrace1,\\dots,c \\rbrace}[- \\frac{2}{n_y}\\sum_{i:y_i=y} K(x,x_i) + \\frac{1}{n_y^2}\\sum_{i,i':y_i=y_i'=y} K(x_i,x_{i'})]在这里，与$\\langle x,x \\rangle$相对应的$K(x,x)$是与最小化无关的常数，因此在实际计算中可以忽略。 然而，采用核函数的非线性核K均值聚类算法，最终的聚类结果强烈依赖于初始值的选择。 谱聚类对于核K均值聚类算法的不足，可以通过降维来解决，这种方法称为谱聚类。 谱聚类，首先在核特征空间中应用局部保持投影法，然后直接应用通常的K均值聚类方法。 谱聚类的具体算法流程： 对样本$\\lbrace x_i \\rbrace_{i=1}^n$应用拉普拉斯特征映射，得到$c-1$次维的$\\lbrace z_i \\rbrace_{i=1}^n$ 对于得到的样本$\\lbrace z_i \\rbrace_{i=1}^n$，应用通常的K均值聚类方法求其簇标签$\\lbrace y_i \\rbrace_{i=1}^n$ 调整参数的自动选取核K均值聚类法与谱聚类的结果依赖于高斯核函数的带宽等核参数的选择。 互信息是信息论里的一个基本的概念，由概率变量$x$和$y$的联合概率$p(x,y)$到各个边缘概率$p(x)p(y)$的KL距离来定义 \\int \\sum_{y=1}^c p(x,y)log\\frac{p(x,y)}{p(x)p(y)}dx互信息一般为非负的数值，只有当概率变量$x$和$y$在统计上是相互独立的时候，即当$p(x,y)=p(x)p(y)$的时候，其值为零。 互信息越大，簇标签$\\lbrace y_i \\rbrace_{i=1}^n$则包含的样本$\\lbrace x_i \\rbrace_{i=1}^n$的信息越多","link":"/2020/05/09/%E5%9B%BE%E8%A7%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0%20%E8%81%9A%E7%B1%BB/"},{"title":"尚硅谷JVM&#x2F;第九章_方法区","text":"方法区栈、堆、方法区的交互关系 这次所讲述的是运行时数据区的最后一个部分——方法区 从线程共享与否的角度来看 ThreadLocal：如何保证多个线程在并发环境下的安全性？典型应用就是数据库连接管理，以及会话管理 栈、堆、方法区的交互关系下面就涉及了对象的访问定位 Person：存放在元空间，也可以说方法区 person：存放在 Java 栈的局部变量表中 new Person()：存放在 Java 堆中 方法区的理解《Java虚拟机规范》中明确说明：“尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。”但对于 HotSpot JVM 而言，方法区还有一个别名叫做 Non-Heap（非堆），目的就是要和堆分开。 所以，方法区看作是一块独立于 Java 堆的内存空间。 方法区主要存放的是 Class ，而堆中主要存放的是实例化的对象 方法区（Method Area）与 Java 堆一样，是各个线程共享的内存区域。 方法区在 JVM 启动的时候被创建，并且它的实际的物理内存空间中和 Java 堆区一样都可以是不连续的（逻辑上连续，物理上可以不连续）。 方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。 方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：java.lang.OutOfMemoryError：PermGen space 或者 java.lang.OutOfMemoryError：Metaspace 加载大量的第三方的 jar 包 Tomcat 部署的工程过多（30~50个） 大量动态的生成反射类 关闭 JVM 就会释放这个区域的内存。 HotSpot 中方法区的演进在 JDK 7 及以前，习惯上把方法区，称为永久代。 JDK 8 开始，使用元空间取代了永久代。 JDK 1.8 后，元空间存放在堆外内存中（In JDK 8, classes metadata is now stored in the native heap and this space is called Metaspace.） 本质上，方法区和永久代并不等价，仅是对 HotSpot 而言的。《Java虚拟机规范》对如何实现方法区，不做统一要求。例如：BEAJRockit / IBM J9 中不存在永久代的概念。 现在来看，当年使用永久代，不是好的idea。导致 Java 程序更容易 OOM （超过-XX:MaxPermsize上限） 而到了 JDK 8 ，终于完全废弃了永久代的概念，改用与 JRockit、J9 一样在本地内存中实现的元空间（Metaspace）来代替 元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现。不过元空间与永久代最大的区别在于：元空间不在虚拟机设置的内存中，而是使用本地内存 永久代、元空间二者并不只是名字变了，内部结构也调整了 根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出 OOM 异常 设置方法区大小与 OOM方法区的大小不必是固定的， JVM 可以根据应用的需要动态调整。 JDK 7 及以前 通过 -XX:PermSize 来设置永久代初始分配空间。默认值是20.75M -XX:MaxPermSize 来设定永久代最大可分配空间。32位机器默认是64M，64位机器模式是82M 当 JVM 加载的类信息容量超过了这个值，会报异常 OutOfMemoryError:PermGen space。 JDK 8 以后元数据区大小可以使用参数 -XX:MetaspaceSize 和 -XX:MaxMetaspaceSize 指定 默认值依赖于平台。windows下，-XX:MetaspaceSize 是21M，-XX:MaxMetaspaceSize 的值是-1，即没有限制。 与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常 OutOfMemoryError:Metaspace -XX:MetaspaceSize：设置初始的元空间大小。对于一个64位的服务器端 JVM 来说，其默认的 -XX:MetaspaceSize 值为21MB。这就是初始的高水位线，一旦触及这个水位线，Full GC 将会被触发并卸载没用的类（即这些类对应的类加载器不再存活）然后这个高水位线将会重置。新的高水位线的值取决于 GC 后释放了多少元空间。如果释放的空间不足，那么在不超过 MaxMetaspaceSize 时，适当提高该值。如果释放空间过多，则适当降低该值。 如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到 Full GC 多次调用。为了避免频繁地 GC ，建议将 -XX:MetaspaceSize 设置为一个相对较高的值。 1234567891011121314151617181920public class OOMTest extends ClassLoader { public static void main(String[] args) { int j = 0; try { OOMTest test = new OOMTest(); for (int i = 0; i &lt; 10000; i++) { //创建ClassWriter对象，用于生成类的二进制字节码 ClassWriter classWriter = new ClassWriter(0); //指明版本号，public，类名，包名，父类，接口 classWriter.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, \"Class\" + i, null, \"java/lang/Object\", null); byte[] code = classWriter.toByteArray(); //类的加载 test.defineClass(\"Class\" + i, code, 0, code.length); j++; } } finally { System.out.println(j); } }} 运行结果： 如何解决这些 OOM 要解决 OOM 异常或 Heap Space 的异常，一般的手段是首先通过内存映像分析工具（如 Eclipse Memory Analyzer）对 dump 出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow） 内存泄漏就是有大量的引用指向某些对象，但是这些对象以后不会使用了，但是因为它们还和 GC ROOT 有关联，所以导致以后这些对象也不会被回收，这就是内存泄漏的问题 内存泄漏得不到解决，从而占据满整个内存空间就会造成内存溢出 如果是内存泄漏，可进一步通过工具查看泄漏对象到 GC Roots 的引用链。于是就能找到泄漏对象是通过怎样的路径与 GC Roots 相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及 GC Roots 引用链的信息，就可以比较准确地定位出泄漏代码的位置。 如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx 与 -Xms ），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。 方法区的内部结构 《深入理解Java虚拟机》书中对方法区（Method Area）存储内容描述如下：它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。 类型信息对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVM 必须在方法区中存储以下类型信息： 这个类型的完整有效名称（全名=包名.类名） 这个类型直接父类的完整有效名（对于interface或是java.lang.object，都没有父类） 这个类型的修饰符（public，abstract，final的某个子集） 这个类型直接接口的一个有序列表 域（Field）信息JVM 必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。 域的相关信息包括：域名称、域类型、域修饰符（public，private，protected，static，final，volatile，transient 的某个子集） 方法（Method）信息JVM 必须保存所有方法的以下信息，同域信息一样包括声明顺序： 方法名称 方法的返回类型（或 void ） 方法参数的数量和类型（按顺序） 方法的修饰符（public，private，protected，static，final，synchronized，native，abstract的一个子集） 方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native方法除外） 异常表（abstract和native方法除外） 每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引 Non-Final 的类变量静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分 类变量被类的所有实例共享，即使没有类实例时，你也可以访问它 123456789101112131415public class MethodAreaTest { public static void main(String[] args) { Order order = null; order.hello(); System.out.println(order.count); }}class Order { public static int count = 1; public static void hello() { System.out.println(\"Hello!\"); }} 运行结果： 12Hello!1 如上代码所示，即使我们把 order 设置为 null ，也不会出现空指针异常 全局常量全局常量就是使用 static final 进行修饰 被声明为 final 的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了。 运行时常量池 VS 常量池运行时常量池，就是运行时常量池 方法区，内部包含了运行时常量池 字节码文件，内部包含了常量池 要弄清楚方法区，需要理解清楚 ClassFile ，因为加载类的信息都在方法区。 要弄清楚方法区的运行时常量池，需要理解清楚 ClassFile 中的常量池。 常量池 一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述符信息外，还包含一项信息就是常量池表（Constant Pool Table），包括各种字面量和对类型、域和方法的符号引用 为什么需要常量池一个 Java 源文件中的类、接口，编译后产生一个字节码文件。而 Java 中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用。r在动态链接的时候会用到运行时常量池，之前有介绍。 比如：如下的代码： 12345public class SimpleClass { public void sayHello() { System.out.println(\"hello\"); }} 虽然上述代码只有194字节，但是里面却使用了 String、System、PrintStream 及 Object 等结构。这里的代码量其实很少了，如果代码多的话，引用的结构将会更多，这里就需要用到常量池了。 常量池中有什么几种在常量池内存存储的数据类型包括： 数量值 字符串值 类引用 字段引用 方法引用 例如下面这段代码 12345public class MethodAreaTest2 { public static void main(String args[]) { Object obj = new Object(); }} Object obj = new Object();将会被翻译成如下字节码 123new #2 //Class java/lang/Objectdupinvokespecial //Method java/lang/Object \"&lt;init&gt;\"()V 小结常量池、可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型 运行时常量池 运行时常量池（Runtime Constant Pool）是方法区的一部分。 常量池表（Constant Pool Table）是 Class 文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。 运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。 JVM 为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。 运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址。 运行时常量池，相对于 Class 文件常量池的另一重要特征是：具备动态性。 String.intern() 运行时常量池类似于传统编程语言中的符号表（Symbol Table），但是它所包含的数据却比符号表要更加丰富一些。 当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则 JVM 会抛 OutOfMemoryError 异常。 方法区使用举例如下代码 123456789public class MethodAreaDemo { public static void main(String args[]) { int x = 500; int y = 100; int a = x / y; int b = 50; System.out.println(a+b); }} 字节码执行过程展示 首先现将操作数500放入到操作数栈中 然后存储到局部变量表中 然后重复一次，把100放入局部变量表中，最后再将变量表中的500和100取出，进行操作 将500和100进行一个除法运算，在把结果入栈 在最后就是输出流，需要调用运行时常量池的常量 最后调用 invokevirtual（虚方法调用），然后返回 返回时 程序计数器始终计算的都是当前代码运行的位置，目的是为了方便记录方法调用后能够正常返回，或者是进行了CPU 切换后，也能回来到原来的代码进行执行。 方法区的演进细节首先明确：只有 HotSpot 才有永久代。BEA JRockit、IBMJ9 等来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一 HotSpot 中方法区的变化： JDK1.6及以前 有永久代，静态变量存储在永久代上 JDK1.7 有永久代，但已经逐步 “去永久代”，字符串常量池，静态变量移除，保存在堆中 JDK1.8 无永久代，类型信息，字段，方法，常量保存在本地内存的元空间，但字符串常量池、静态变量仍然在堆中。 JDK 6 的时候 JDK 7 的时候 JDK 8 的时候，元空间大小只受物理内存影响 为什么永久代要被元空间替代？JRockit 是和 HotSpot 融合后的结果，因为 JRockit 没有永久代，所以他们不需要配置永久代 随着 Java 8 的到来，HotSpot VM 中再也见不到永久代了。但是这并不意味着类的元数据信息也消失了。这些数据被移到了一个与堆不相连的本地内存区域，这个区域叫做元空间（Metaspace）。 由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间，这项改动是很有必要的，原因有： 为永久代设置空间大小是很难确定的。 在某些场景下，如果动态加载类过多，容易产生 Perm 区的 OOM 。比如某个实际 Web 工程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。 “Exception in thread‘dubbo client x.x connector’java.lang.OutOfMemoryError:PermGen space” 而元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。 对永久代进行调优是很困难的。 主要是为了降低 Full GC 有些人认为方法区（如 HotSpot 虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如 JDK 11 时期的 ZGC 收集器就不支持类卸载）。一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前 Sun 公司的 Bug 列表中，曾出现过的若干个严重的 Bug 就是由于低版本的 HotSpot 虚拟机对此区域未完全回收而导致内存泄漏 方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不在使用的类型 StringTable为什么要调整位置JDK 7 中将 StringTable 放到了堆空间中。因为永久代的回收效率很低，在 Full GC 的时候才会触发。而 Full GC 是老年代的空间不足、永久代不足时才会触发。 这就导致 StringTable 回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。 静态变量存放在那里？静态引用对应的对象实体始终都存在堆空间 可以使用 jhsdb.ext，需要在 JDK 9 的时候才引入的 1234567891011121314151617181920public class StaticObject { static class Test { static ObjectHolder staticObj = new ObjectHolder(); ObjectHolder instanceObj = new ObjectHolder(); void foo() { ObjectHolder localObj = new ObjectHolder(); System.out.println(\"done\"); } } private static class ObjectHolder { } public static void main(String[] args) { Test test = new StaticObjTest.Test(); test.foo(); }} staticObj 随着 Test 的类型信息存放在方法区，instanceObj 随着 Test 的对象实例存放在 Java 堆，localObject则是存放在 foo（）方法栈帧的局部变量表中。 测试发现：三个对象的数据在内存中的地址都落在 Eden 区范围内，所以结论：只要是对象实例必然会在 Java 堆中分配。 接着，找到了一个引用该 staticObj 对象的地方，是在一个 java.lang.Class 的实例里，并且给出了这个实例的地址，通过Inspector查看该对象实例，可以清楚看到这确实是一个 java.lang.Class 类型的对象实例，里面有一个名为 staticObj 的实例字段： 从《Java虚拟机规范》所定义的概念模型来看，所有 Class 相关的信息都应该存放在方法区之中，但方法区该如何实现，《Java虚拟机规范》并未做出规定，这就成了一件允许不同虚拟机自己灵活把握的事情。JDK 7 及其以后版本的 HotSpot 虚拟机选择把静态变量与类型在 Java 语言一端的映射 Class 对象存放在一起，存储于 Java 堆之中，从我们的实验中也明确验证了这一点 方法区的垃圾回收有些人认为方法区（如 HotSpot 虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如 JDK 11 时期的 ZGC 收集器就不支持类卸载）。 一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前 Sun 公司的 Bug 列表中，曾出现过的若干个严重的 Bug 就是由于低版本的 HotSpot 虚拟机对此区域未完全回收而导致内存泄漏。 方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型。 先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近 Java 语言层次的常量概念，如文本字符串、被声明为 final 的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量： 类和接口的全限定名 字段的名称和描述符 方法的名称和描述符 HotSpot 虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。 回收废弃常量与回收 Java 堆中的对象非常类似。（关于常量的回收比较简单，重点是类的回收） 判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件： 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类及其任何派生子类的实例。 加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如 OSGi、JSP 的重加载等，否则通常是很难达成的。 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。 Java 虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot 虚拟机提供了 -Xnoclassgc 参数进行控制，还可以使用 -verbose:class 以及 -XX:+TraceClass-Loading、-XX:+TraceClassUnLoading 查看类加载和卸载信息 在大量使用反射、动态代理、CGLib 等字节码框架，动态生成 JSP 以及 OSGi 这类频繁自定义类加载器的场景中，通常都需要 Java 虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。 总结 常见面试题百度三面：说一下 JVM 内存模型吧，有哪些区？分别干什么的？ 蚂蚁金服：Java 8 的内存分代改进JVM 内存分哪几个区，每个区的作用是什么？一面：JVM 内存分布/内存结构？栈和堆的区别？堆的结构？为什么两个 Survivor 区？二面：Eden 和 Survior 的比例分配 小米：JVM 内存分区，为什么要有新生代和老年代 字节跳动：二面：Java 的内存分区二面：讲讲 JVM 运行时数据库区什么时候对象会进入老年代？ 京东：JVM 的内存结构，Eden 和 Survivor 比例。JVM 内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为 Eden 和 Survivor 。 天猫：一面：JVM 内存模型以及分区，需要详细到每个区放什么。一面：JVM 的内存模型，Java 8 做了什么改 拼多多：JVM 内存分哪几个区，每个区的作用是什么？ 美团：Java 内存分配JVM 的永久代中会发生垃圾回收吗？一面：JVM 内存分区，为什么要有新生代和老年代？","link":"/2020/10/16/%E5%B0%9A%E7%A1%85%E8%B0%B7JVM/%E7%AC%AC%E4%B9%9D%E7%AB%A0_%E6%96%B9%E6%B3%95%E5%8C%BA/"},{"title":"尚硅谷JVM&#x2F;第二十章_类的加载过程详解","text":"类的加载过程详解概述 在 Java 中数据类型分为基本数据类型和引用数据类型。基本数据类型由虚拟机预先定义，引用数据类型则需要进行类的加载 按照 Java 虚拟机规范，从 Class 文件到加载到内存中的类，到类卸载出内存位置，它的整个生命周期包括如下七个阶段： 其中，验证、准备、解析3个部分统称为链接(Linking) 从程序中类的使用过程看： 大厂面试题蚂蚁金服： 描述一下 JVM 加载 Class 文件的原理机制？ 一面：类加载过程 百度： 类加载的机制 Java 类加载过程？ 简述 Java 类加载机制？ 腾讯： JVM 中类加载机制，类加载过程？ 滴滴： JVM 类加载机制 美团： Java 类加载过程 描述一下 JVM 加载 Class 文件的原理机制 过程一：Loading(加载)阶段加载完成的操作加载的理解所谓加载，简而言之就是将 Java 类的字节码文件加载到机器内存中，并在内存中构建出 Java 类的原型——类模板对象。所谓类模板对象，其实就是 Java 类在 JVM 内存中的一个快照，JVM 将从字节码文件中解析出的常量池、类字段、类方法等信息存储到模板中，这样 JVM 在运行期便能通过类模板而获取 Java 类中的任意信息，能够对 Java 类的成员变量进行遍历，也能进行 Java 方法的调用 反射的机制即基于这一基础。如果 JVM 没有将 Java 类的声明信息存储起来，则 JVM 在运行期也无法反射 加载完成的操作加载阶段，简言之，查找并加载类的二进制数据，生成 Class 的实例 在加载类时，Java 虚拟机必须完成以下3件事情： 通过类的全名，获取类的二进制数据流 解析类的二进制数据流为方法区内的数据结构(Java 类模型) 创建 java.lang.Class 类的实例，表示该类型。作为方法区这个类的各种数据的访问入口 二进制流的获取方式对于类的二进制数据流，虚拟机可以通过多种途径产生或获得。(只要所读取的字节码符合 JVM 规范即可) 虚拟机可能通过文件系统读入一个 Class 后缀的文件(最常见) 读入 jar、zip 等归档数据包，提取类文件 事先存放在数据库中的类的二进制数据 使用类似于 HTTP 之类的协议通过网络进行加载 在运行时生成一段 Class 的二进制信息等 在获取到类的二进制信息后，Java 虚拟机就会处理这些数据，并最终转为一个 java.lang.Class 的实例 如果输入数据不是 ClassFile 的结构，则会抛出 ClassFormatError 类模型与 Class 实例的位置 类模型的位置 加载的类在 JVM 中创建相应的类结构，类结构会存储在方法区(JDK 1.8之前：永久代；JDK 1.8之后：元空间) Class 实例的位置 类将 .class 文件加载至元空间后，会在堆中创建一个 java.lang.Class 对象，用来封装类位于方法区内的数据结构，该 Class 对象是在加载类的过程中创建的，每个类都对应有一个 Class 类型的对象 图示 外部可以通过访问代表 Order 类的 Class 对象来获取 Order 的类数据结构 再说明 Class 类的构造方法是私有的，只有 JVM 能够创建 java.lang.Class 实例是访问类型元数据的接口，也是实现反射的关键数据、入口。通过 Class 类提供的接口，可以获得目标类所关联的 .class 文件中具体的数据结构：方法、字段等信息 数组类的加载创建数组类的情况稍微有些特殊，因为数组类本身并不是由类加载器负责创建，而是由 JVM 在运行时根据需要而直接创建的，但数组的元素类型仍然需要依靠类加载器去创建。创建数组类(下述简称 A)的过程： 如果数组的元素类型是引用类型，那么就遵循定义的加载过程递归加载和创建数组 A 的元素类型 JVM 使用指定的元素类型和数组唯独来创建新的数组类 如果数组的元素类型是引用类型，数组类的可访问性就由元素类型的可访问性决定。否则数组类的可访问性将被缺省定义为 public 过程二：Linking(链接)阶段环节1:链接阶段之 Verification (验证)当类加载到系统后，就开始链接操作，验证是链接操作的第一步 它的目的是保证加载的字节码是合法、合理并符合规范的 验证的步骤比较复杂，实际要验证的项目也很繁多，大体上 Java 虚拟机需要做以下检查，如图所示 整体说明： 验证的内容则涵盖了类数据信息的格式验证、语义检查、字节码验证，以及符号引用验证等 其中格式验证会和加载阶段一起执行。验证通过之后，类加载器才会成功将类的二进制数据信息加载到方法区中 格式验证之外的验证操作将会在方法区中进行 链接阶段的验证虽然拖慢了加载速度，但是它避免了在字节码运行时还需要进行各种检查 具体说明： 格式验证：是否以魔数 0xCAFEBABE 开头，主版本和副版本号是否在当前 Java 虚拟机的支持范围内，数据中每一个项是否都拥有正确的长度等 Java 虚拟机会进行字节码的语义检查，但凡在语义上不符合规范的，虚拟机也不会给予验证通过。比如： 是否所有的类都有父类的存在(在 Java 里，除了 Object 外，其他类都应该有父类) 是否一些被定义为 final 的方法或者类被重写或继承了 非抽象类是否实现了所有抽象方法或者接口方法 是否存在不兼容的方法(比如方法的签名除了返回值不同，其他都一样，这种方法会让虚拟机无从下手调度；absract 情况下的方法，就不能是final 的了) Java 虚拟机还会进行字节码验证，字节码验证也是验证过程中最为复杂的一个过程。它试图通过对字节码流的分析，判断字节码是否可以被正确地执行。比如： 在字节码的执行过程中，是否会跳转到一条不存在的指令 函数的调用是否传递了正确类型的参数 变量的赋值是不是给了正确的数据类型等 栈映射帧(StackMapTable)就是在这个阶段，用于检测在特定的字节码处，其局部变量表和操作数栈是否有着正确的数据类型。但遗憾的是，100%准确地判断一段字节码是否可以被安全执行是无法实现的，因此，该过程只是尽可能地检查出可以预知的明显的问题。如果在这个阶段无法通过检查，虚拟机也不会正确装载这个类。但是，如果通过了这个阶段的检查，也不能说明这个类是完全没有问题的 在前面3次检查中，已经排除了文件格式错误、语义错误以及字节码的不正确性。但是依然不能确保类是没有问题的 校验器还将进行符号引用的验证。Class 文件在其常量池会通过字符串记录自己将要使用的其他类或者方法。因此，在验证阶段，虚拟机就会检查这些类或者方法确实是存在的，并且当前类有权限访问这些数据，如果一个需要使用类无法在系统中找到，则会抛出 NoClassDefFoundError，如果一个方法无法被找到，则会抛出 NoSuchMethdError 此阶段在解析环节才会执行 环节2:链接阶段之 Preparation (准备)准备阶段(Preparation)，简言之，为类的静态变量分配内存，并将其初始化为默认值 当一个类验证通过时，虚拟机就会进入准备阶段。在这个阶段，虚拟机就会为这个类分配相应的内存空间，并设置默认初始值。 Java 虚拟机为各类型变量默认的初始值如表所示： 注意：Java 并不支持 boolean 类型，对于 boolean 类型，内部实现是 int，由于 int 的默认值是0，故对应的，boolean 的默认值就是 false 注意： 这里不包含基本数据类型的字段用 static final 修饰的情况，因为 final 在编译的时候就会分配了，准备阶段会显式赋值 注意这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到 Java 堆中 在这个阶段不会像初始化阶段中那样会有初始化或者代码被执行 1234567891011121314/** * &lt;p&gt; * 基本数据类型：非 final 修饰的变量，在准备环节进行默认初始化赋值 * final 修饰以后，在准备环节直接进行显式赋值 * &lt;p&gt; * 拓展：如果使用字面量的方式定义一个字符串的常量的话，也是在准备环节直接进行显式赋值 */public class LinkingTest { private static long id; private static final int num = 1; public static final String constStr = \"CONST\"; public static final String constStr1 = new String(\"CONST\");} 环节3:链接阶段之 Resolution (解析)在准备阶段(Resolution)，简言之，将类、接口、字段和方法的符号引用转为直接引用 具体描述： 符号引用就是一些字面量的引用，和虚拟机的内部数据结构和内存分布无关。比较容理解的就是在 Class 类文件中，通过常量池进行了大量的符号引用。但是在程序实际运行时，只有符号引用是不够的，比如当如下 println() 方法被调用时，系统需要明确知道该方法的位置 举例：输出操作 System.out.println() 对应的字节码： invokevirtual #24 以方法为例，Java 虚拟机为每个类都准备了一张方法表，将其所有的方法都列在表中，当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法。通过解析操作，符号引用就可以转变为目标方法在类中方法表中的位置，从而使得方法被成功调用 小结 所谓解析就是将符号引用转为直接引用，也就是得到类、字段、方法在内存中的指针或者偏移量。因此，可以说，如果直接引用存在，那么可以肯定系统中存在该类、方法或者字段。但只存在符号引用，不能确定系统中一定存在该结构 不过 Java 虚拟机规范并没有明确要求解析阶段一定要按照顺序执行。在 HotSpot VM 中，加载、验证、准备和初始化会按照顺序有条不紊地执行，但链接阶段中的解析操作往往会伴随着 JVM 在执行完初始化之后再执行 字符串的复习 最后，再来看一下 CONSTANT_String 的解析。由于字符串在程序开发中有着重要的作用，因此，读者有必要了解一下 String 在 Java 虚拟机中的处理。当在 Java 代码中直接使用字符串常量时，就会在类中出现 CONSTANT_String，它表示字符串常量，并且会引用一个 CONSTANT_UTF8 的常量项。在 Java 虚拟机内部运行中的常量池，会维护一张字符串拘留表(intern)，它会保存所有出现过的字符串常量，并且没有重复项。只要以 CONSTANT_String 形式出现的字符串也都会在这张表中。使用 String.intern() 方法可以得到一个字符串在拘留表中的引用，因为该表中没有重复项，所以任何字面相同的字符串的 String.intern() 方法返回总是相等的 过程三：Initialization(初始化)阶段初始化阶段，简言之，为类的静态变量赋予正确的初始值 具体描述 类的初始化是类装载的最后一个阶段。如果前面的步骤都没有问题，那么表示类可以顺利装载到系统中。此时，类才会开始执行 Java 字节码。(即：到了初始化阶段，才真正开始执行类中定义的 Java 程序代码) 初始化阶段的重要工作是执行类的初始化方法：() 方法 该方法仅能由 Java 编译器生成并由 JVM 调用，程序开发者无法自定义一个同名的方法，更无法直接在 Java 程序中调用该方法，虽然该方法也是由字节码指令所组成 它是类静态成员的赋值语句以及 static 语句块合并产生的 说明 在加载一个类之前，虚拟机总是会试图加载该类的父类，因此父类的 总是在子类 之前被调用，也就是说，父类的 static 块优先级高于子类 Java 编译器并不会为所有的类都产生 () 初始化方法。哪些类在编译为字节码后，字节码文件中将不会包含 () 方法？ 一个类中并没有声明任何的类变量，也没有静态代码块时 一个类中声明类变量，但是没有明确使用类变量的初始化语句以及静态代码块来执行初始化操作时 一个类中包含 static final 修饰的基本数据类型的字段，这些类字段初始化语句采用编译时常量表达式 static 与 final 的搭配问题123456789101112/** * * 哪些场景下，Java 编译器就不会生成&lt;clinit&gt;()方法 */public class InitializationTest1 { //场景1:对应非静态的字段，不管是否进行了显式赋值，都不会生成&lt;clinit&gt;()方法 public int num = 1; //场景2：静态的字段，没有显式的赋值，不会生成&lt;clinit&gt;()方法 public static int num1; //场景3：比如对于声明为 static final 的基本数据类型的字段，不管是否进行了显式赋值，都不会生成&lt;clinit&gt;()方法 public static final int num2 = 1;} 123456789101112131415161718192021222324252627/** * * 说明：使用 static + final 修饰的字段的显式赋值的操作，到底是在哪个阶段进行的赋值？ * 情况1：在链接阶段的准备环节赋值 * 情况2：在初始化阶段&lt;clinit&gt;()中赋值 * * 结论： * 在链接阶段的准备环节赋值的情况： * 1. 对于基本数据类型的字段来说，如果使用 static final 修饰，则显式赋值(直接赋值常量，而非调用方法)通常是在链接阶段的准备环节进行 * 2. 对于 String 来说，如果使用字面量的方式赋值，使用 static final 修饰的话，则显式赋值通常是在链接阶段的准备环节进行 * * 在初始化阶段&lt;clinit&gt;()中赋值的情况 * 排除上述的在准备环节赋值的情况之外的情况 * * 最终结论：使用 static + final 修饰，且显示赋值中不涉及到方法或构造器调用的基本数据类型或String类型的显式赋值，是在链接阶段的准备环节进行 */public class InitializationTest2 { public static int a = 1; //在初始化阶段&lt;clinit&gt;()中赋值 public static final int INT_CONSTANT = 10; //在链接阶段的准备环节赋值 public static final Integer INTEGER_CONSTANT1 = Integer.valueOf(100); //在初始化阶段&lt;clinit&gt;()中赋值 public static Integer INTEGER_CONSTANT2 = Integer.valueOf(1000); //在初始化阶段&lt;clinit&gt;()中赋值 public static final String s0 = \"helloworld0\"; //在链接阶段的准备环节赋值 public static final String s1 = new String(\"helloworld1\"); //在初始化阶段&lt;clinit&gt;()中赋值} () 的线程安全性对于 () 方法的调用，也就是类的初始化，虚拟机会在内部确保其多线程环境中的安全性 虚拟机会保证一个类的 () 方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的 () 方法，其他线程都需要阻塞等待，直到活动线程执行 () 方法完毕 正是因为函数 () 带锁线程安全的，因此，如果一个在类的 () 方法中有耗时很长的操作，就可能造成多个线程阻塞，引发死锁。并且这种死锁是很难发现的，因为看起来它们并没有可用的锁信息 如果之前的线程成功加载了类，则等在队列中的线程就没有机会再执行 () 方法了。那么，当需要使用这个类时，虚拟机会直接返回给它已经准备好的信息 类的初始化情况：主动使用 vs 被动使用Java 程序对类的使用分为两种：主动使用 和 被动使用 一、主动使用 Class 只有在必须要首次使用的时候才会被装载，Java 虚拟机不会无条件地装载 Class 类型。Java 虚拟机规定，一个类或接口在初次使用前，必须要进行初始化。这里指的”使用”，是指主动使用，主动使用只有下列几种情况：(即：如果出现如下的情况，则会对类进行初始化操作。而初始化操作之前的加载、验证、准备已经完成) 当创建一个类的实例时，比如使用 new 关键字，或者通过反射、克隆、反序列化 当调用类的静态方法时，即当使用了字节码 invokestatic 指令 当使用类、接口的静态字段时(final 修饰特殊考虑)，比如，使用 getstatic 或者 putsttic 指令。(对应访问变量、赋值变量操作) 当使用 java.lang.reflect 包中的方法反射类的方法时。比如：Class.forname(“com.atguigu.java.Test”) 当初始化子类时，如果发现其分类还没有进行过初始化，则需要先触发其父类的初始化 如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，该接口要在其之前被初始化 当虚拟机启动时，用户需要指定一个要执行的主类(包含 main() 方法的那个类)，虚拟机会先初始化这个主类 当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。(涉及解析 REF_getStatic、REF_putStatic、REF_invokeStatic 方法句柄对应的类) 针对5，补充说明： 当 Java 虚拟机初始化一个类时，要求它的所有父类都已经被初始化，但是这条规则并不适用于接口 在初始化一个类时，并不会先初始化它所实现的接口 在初始化一个接口时，并不会先初始化它的父接口 因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化，只有当程序首次使用特定接口的静态字段时，才会导致该接口的初始化 针对7，说明： JVM 启动的时候通过引导类加载器加载一个初始类。这个类在调用 public static void main(String[]) 方法之前被链接和初始化。这个方法的执行将依次导致所需的类的加载、链接和初始化 二、被动使用 除了以上的情况属于主动使用，其他的情况均属于被动使用。被动使用不会引起类的初始化 也就是说：并不是在代码中出现的类，就一定会被加载或者初始化。如果不符合主动使用的条件，类就不会初始化 当访问一个静态字段时，只有真正声明这个字段的类才会被初始化 当通过子类引用父类的静态变量，不会导致子类初始化 通过数组定义类引用，不会触发此类的初始化 引用变量不会触发此类或接口的初始化。因为常量在链接阶段就已经被显式赋值了 调用 ClassLoader 类的 loadClass() 方法加载一个类，并不是对类的主动使用，不会导致类的初始化 如果针对代码，设置参数 -XX:+TraceClassLoading，可以追踪类的加载信息并打印出来 过程四：类的Using(使用)任何一个类型在使用之前都必须经历过完整的加载、链接和初始化3个类加载步骤。一旦一个类型成功经历过这3个步骤之后，便“万事俱备，只欠东风”，就等着开发者使用了 开发人员可以在程序中访问和调用它的静态类成员信息(比如：静态字段、静态方法)，或者使用 new 关键字为其创建对象实例 过程五：类的Unloading(卸载)一、类、类的加载器、类的实例之间的引用关系 在类加载器的内部实现中，用一个 Java 集合来存放所加载类的引用。另一方面，一个 Class 对象总是会引用它的类加载器，调用 Class 对象的 getClassLoader() 方法，就能获得它的类加载器。由此可见，代表某个类的 Class 实例与其类的加载器之间为双向关联关系 一个类的实例总是引用代表这个类的 Class 对象。在 Object 类中定义了 getClass() 方法，这个方法返回代表对象所属类的 Class 对象的引用。此外，所有的 Java 类都有一个静态属性 Class，它引用代表这个类的 Class 对象 二、类的生命周期 当 Sample 类被加载、链接和初始化后，它的生命周期就开始了。当代表 Sample 类的 Class 对象不再被引用，即不可触及时，Class 对象就会结束生命周期，Sample 类在方法区内的数据也会被卸载，从而结束 Sample 类的生命周期 一个类何时结束生命周期，取决于代表它的 Class 对象何时结束生命周期 三、具体例子 Loader1 变量和 obj 变量间接应用代表 Sample 类的 Class 对象，而 objClass 变量则直接引用它 如果程序运行过程中，将上图左侧三个引用变量都置为 null，此时 Sample 对象结束生命周期，MyClassLoader 对象结束生命周期，代表 Sample 类的 Class 对象也结束生命周期，Sample 类在方法区内的二进制数据被卸载 当再次有需要时，会检查 Sample 类的 Class 对象是否存在，如果存在会直接使用，不再重新加载；如果不存在 Sample 类会被重新加载，在 Java 虚拟机的堆区会生成一个新的代表 Sample 类的 Class 实例(可以通过哈希码查看是否是同一个实例) 四、类的卸载 启动类加载器加载的类型在整个运行期间是不可能被卸载的(JVM 和 JSL 规范) 被系统类加载器和扩展类加载器加载的类型在运行期间不太可能被卸载，因为系统类加载器实例或者扩展类的实例基本上在整个运行期间总能直接或者间接的访问的到，其达到 unreachable 的可能性极小 被开发者自定义的类加载器实例加载的类型只有在很简单的上下文环境中才能被卸载，而且一般还要借助于强制调用虚拟机的垃圾收集功能才可以做到。可以预想，稍微复杂点的应用场景(比如：很多时候用户在开发自定义类的加载器实例的时候采用缓存的策略以提高系统性能)，被加载的类型在运行期间也是几乎不太可能被卸载的(至少卸载的时间是不确定的) 综合以上三点，一个已经加载的类型被卸载的几率很小至少被卸载的时间是不确定的。同时我们可以看的出来，开发者在开发代码时候，不应该对虚拟机的类型卸载做任何假设的前提下，来实现系统中的特定功能 回顾：方法区的垃圾回收方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型 HotSpot 虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收 判定一个常量是否”废弃”还是相对简单，而要判定一个类型是否属于”不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件： 该类所有的实例都已经被回收。也就是 Java 堆中不存在该类及其任何派生子类的实例 加载该类的类加载器已经被回收。这个条件除非是经过精心设计的可替换类加载器的场景，如 OSGI、JSP 的重加载等，否则通常是很难达成的 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法 Java 虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是”被允许”，而并不是和对象一样，没有引用了就必然会回收","link":"/2020/10/24/%E5%B0%9A%E7%A1%85%E8%B0%B7JVM/%E7%AC%AC%E4%BA%8C%E5%8D%81%E7%AB%A0_%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/"},{"title":"尚硅谷JVM&#x2F;第二十一章_再谈类的加载器","text":"再谈类的加载器概述 类加载器是 JVM 执行类加载机制的前提 ClassLoader 的作用： ClassLoader 是 Java 的核心组件，所有的 Class 都是由 ClassLoader 进行加载的，ClassLoader 负责通过各种方式将 Class 信息的二进制数据流读入 JVM 内部，转换为一个与目标类对应的 java.lang.Class 对象实例。然后交给 Java 虚拟机尽心链接、初始化等操作。因此，ClassLoader 在整个装载阶段，只能影响到类的加载，而无法通过 ClassLoader 去改变类的链接和初始化行为。至于它是否可以运行，则由 Execution Engine 决定 类加载器最早出现在 Java 1.0 版本中，那个时候只是单纯地为了满足 Java Applet 应用而被研发出来，但如今类加载器却在 OSGI、字节码加解密领域大放异彩。这主要归功于 Java 虚拟机的设计者们当初在设计类加载器的时候，并没有考虑将它绑定在 JVM 内部，这样做的好处就是能够更加灵活和动态地执行类加载操作 大厂面试题蚂蚁金服： 深入分析 ClassLoader，双亲委派机制 类加载器的双亲委派模型是什么？ 一面：双亲委派机制及使用原因 百度： 都有哪些类加载器，这些类加载器都加载哪些文件？ 手写一个类加载器 Demo Class 的 forName(“java.lang.String”) 和 Class 的 getClassLoader() 的 loadClass(“java.lang.String”)有什么区别？ 腾讯： 什么是双亲委派模型？ 类加载器有哪些？ 小米： 双亲委派模型介绍一下 滴滴： 简单说说你了解的类加载器 一面：讲一下双亲委派模型，以及其优点 字节跳动： 什么事类加载器，类加载器有哪些？ 京东： 类加载器的双亲委派模型是什么？ 双亲委派机制可以打破吗？为什么？ 类加载的分类类的加载分类：显式加载 vs 隐式加载 Class 文件的显式加载与隐式加载的方式是指 JVM 加载 Class 文件到内存的方式 显式加载指的是在代码中通过调用 ClassLoader 加载 Class 对象，如直接使用 Class.forName(name) 或 this.getClass().getClassLoader().loadClass() 加载 Class 对象 隐式加载则是不直接在代码中调用 ClassLoader 的方法加载 Class 对象，而是通过虚拟机自动加载到内存中，如在加载某个类的 Class 文件时，该类的 Class 文件中引用了另外一个类的对象，此时额外引用的类将通过 JVM 自动加载到内存中 在日常开发中以上两种方式一般会混合使用 类加载器的必要性一般情况下，Java 开发人员并不需要在程序中显式地使用类加载器，但是了解类加载器的加载机制却显得至关重要。从以下几个方面说： 避免在开发中遇到 java.lang.ClassNotFoundException 异常或 java.lang.NoClassDeFoundError 异常时手足无措。只有了解类加载器的加载机制才能够在出现异常的时候快速地根据错误异常日志定位问题和解决问题 需要支持类的动态加载或需要对编译后的字节码文件进行加解密操作时，就需要与类加载器打交道了 开发人员可以在程序中编写自定义类加载器来重新定义类的加载规则，以便实现一些自定义的处理逻辑 命名空间 何为类的唯一性？ 对于任意一个类，都需要由加载它的类加载器和这个类本身一同确认其在 Java 虚拟机中的唯一性。每一个类加载器，都拥有一个独立的类名称空间：比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义。否则，即使这两个类源自同一个 Class 文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类就必定不相等 命名空间 每个类加载器都有自己的命名空间，命名空间由该加载器所有的父加载器所加载的类组成 在同一命名空间中，不会出现类的完整名字(包括类的包名)相同的两个类 在不同的命名空间中，有可能会出现类的完整名字(包括类的包名)相同的两个类 在大型应用中，我们往往借助这一特性，来运行同一个类的不同版本 类加载机制的基本特征通常类加载机制有三个基本特征： 双亲委派模型。但不是所有类加载都遵守这个模型，有的时候，启动类加载器所加载的类型，是可能要加载用户代码的，比如 JDK 内部的 ServiceProvider/ServiceLoader 机制，用户可以在标准 API 框架上，提供自己的实现，JDK 也需要提供些默认的参考实现。例如，Java 中 JNDI、JDBC、文件系统、Cipher 等很多方面，都是利用的这种机制，这种情况就不会用双亲委派模型去加载，而是利用所谓的上下文加载器 可见性，子类加载器可以访问父加载器加载的类型，但是反过来是不允许的。不然，因为缺少必要的隔离，我们就没有办法利用类加载器去实现容器的逻辑 单一性，由于父加载器的类型对于子加载器是可见的，所以父加载器中加载过的类型，就不会在子加载器中重复加载。但是注意，类加载器”邻居”间，同一类型仍然可以被加载多次，因为相互并不可见 复习：类的加载器分类JVM 支持两种类型的类加载器，分别为引导类加载器(Bootstrap ClassLoader)和自定义类加载器(User-Defined ClassLoader) 从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是 Java 虚拟机规范却没有这么定义，而是将所有派生于抽象类 ClassLoader 的类加载器都划分为自定义类加载器。无论类加载器的类型如何划分，在程序中我们最常见的类加载器结构主要是如下情况： 除了顶层的启动类加载器外，其余的类加载器都应当有自己的”父类”加载器 不同类加载器看似是继承(Inheritance)关系，实际上是包含关系。在下层加载器中，包含着上层加载器的引用 1234567891011121314151617181920class ClassLoader { ClassLoader parent; //父类加载器 public ClassLoader(ClassLoader parent) { this.parent = parent; }}class ParentClassLoader extends ClassLoader { public ParentClassLoader(ClassLoader parent) { super(parent); }}class ChildClassLoader extends ClassLoader { public ChildClassLoader(ClassLoader parent) { //parent = new ParentClassLoader(); super(parent); }} 引导类加载器启动类加载器(引导类加载器) 这个类加载使用 C/C++ 语言实现的，嵌套在 JVM 内部 它用来加载 Java 的核心库(JAVA_HOME/jre/lib/rt.jar 或 sun.boot.class.path 路径下的内容)。用于提供 JVM 自身需要的类 并不继承自 java.lang.ClassLoader，没有父加载器 出于安全考虑，Bootstrap 启动类加载器之加载包名为 java、javax、sun 等开头的类 加载扩展类和应用程序类加载器，并指定为他们的父类加载器 使用 -XX:+TraceClassLoading 参数 启动类加载器使用 C++ 编写的？Yes！ C/C++：指针函数 &amp; 函数指针、C++ 支持多继承、更加高效 Java ：由 C++ 演变而来，(C++)— 版，单继承 扩展类加载器扩展类加载器(Extension ClassLoader) Java 语言编写，由 sun.misc.Launcher$ExtClassLoader 实现 继承于 ClassLoader 类 父类加载器为启动类加载器 从 java.ext.dirs 系统属性所指定的目录中加载类库，或从 JDK 的安装目录的 jre/lib/ext 子目录下加载类库。如果用户创建的 JAR 放在此目录下，也会自动由扩展类加载器加载 系统类加载器应用程序类加载器(系统类加载器，AppClassLoader) Java 语言编写，由 sun.misc.Launcher$AppClassLoader 实现 继承于 ClassLoader 类 父类加载器为扩展类加载器 它负责加载环境变量 classpath 或系统属性 java.class.path 指定路径下的类库 应用程序中的类加载器默认是系统类加载器 它是用户自定义类加载器的默认父加载器 通过 ClassLoader 的 getSystemClassLoader() 方法可以获取到该类加载器 用户自定义类加载器 在 Java 的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的。在必要时，我们还可以自定义类加载器，来定制类的加载方式 体现 Java 语言强大生命力和巨大魅力的关键因素之一便是，Java 开发者可以自定义类加载器来实现类库的动态加载，加载源可以是本地的 JAR 包，也可以是网络上的远程资源 通过类加载器可以实现非常绝妙的插件机制，这方面的实际应用案例不胜枚举。例如，著名的 OSGI 组件框架，再如 Eclipse 的插件机制。类加载器为应用程序提供了一种动态增加新功能的机制，这种机制无需重新打包发布应用程序就能实现 同时，自定义加载器能够实现应用隔离，例如 Tomcat、Spring 等中间件和组件框架都在内部实现了自定义的加载器，并通过自定义加载器隔离不同的组件模块。这种机制比 C/C++ 程序要好太多，想不修改 C/C++ 程序就能为其新增功能，几乎是不可能的，仅仅一个兼容性便能阻挡所有美好的设想 自定义类加载器通常需要继承于 ClassLoader 测试不同的类加载器每个 Class 对象都会包含一个定义它的 ClassLoader 的一个引用 获取 ClassLoader 的途径 12345678获取当前类的 ClassLoaderclazz.getClassLoader();获得当前线程上下文的 ClassLoaderThread.currentThread().getContextClassLoader();获得系统的 ClassLoaderClassLoader.getSystemClassLoader(); 说明： 站在程序的角度看，引导类加载器与另外两种类加载器(系统类加载器和扩展类加载器)并不是同一个层次意义上的加载器，引导类加载器是使用 C++ 语言编写而成的，而另外两种类加载器则是使用 Java 语言编写的。由于引导类加载器压根儿就不是一个 Java 类，因此在 Java 程序中只能打印出空值 数组类的 Class 对象，不是由类加载器去创建的，而是在 Java 运行期 JVM 根据需要自动创建的。对于数组类的类加载器来说，是通过 Class.geetClassLoader() 返回的，与数组当中元素类型的类加载器是一样的：如果数组当中的元素类型是基本数据类型，数组类是没有类加载器的 1234567891011String[] strArr = new String[6];System.out.println(strArr.getClass().getClassLoader());//运行结果：nullClassLoaderTest[] test = new ClassLoaderTest[1];System.out.println(test.getClass().getClassLoader());//运行结果：sun.misc.Launcher$AppClassLoader@18b4aac2int[] inst = new int[2];System.out.println(inst.getClass().getClassLoader());//运行结果：null ClassLoader 源码解析ClassLoader 与现有类加载的关系： 除了以上虚拟机自带的加载器外，用户还可以定制自己的类加载器。Java 提供了抽象类 java.lang.ClassLoader，所有用户自定义的类加载器都应该继承 ClassLoader 类 ClassLoader 的主要方法抽象类 ClassLoader 的主要方法：(内部没有抽象方法) public final ClassLoader getParent() 返回该类加载器的超类加载器 public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException 加载名称为 name 的类，返回结果为 java.lang.Class 类的实例。如果找不到类，则返回 ClassNotFountException 异常。该方法中的逻辑就是双亲委派模式的实现 protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException 查找二进制名称为 name 的类，返回结果为 java.lang.Class 类的实例。这是一个受保护的方法，JVM 鼓励我们重写此方法，需要自定义加载器遵循双亲委派机制，该方法会在检查完父类加载器之后被 loadClass() 方法调用 在 JDK 1.2 之前，在自定义类加载时，总会去继承 ClassLoader 类并重写 loadClass 方法，从而实现自定义的类加载类。但是在 JDK 1.2 之后已不再建议用户去覆盖 loadClass() 方法，而是建议把自定义的类加载逻辑写在 find Class() 方法中，从前面的分析可知，findClass() 方法是在 loadClass() 方法中被调用的，当 loadClass() 方法中父加载器加载失败后，则会调用自己的 findClass() 方法来完成类加载，这样就可以保证自定义的类加载器也符合双亲委派机制 需要注意的是 ClassLoader 类中并没有实现 findClass() 方法的具体代码逻辑，取而代之的是抛出 ClassNotFoundException 异常，同时应该知道的是 findClass() 方法通常是和 defineClass() 方法一起使用的。一般情况下，在自定义类加载器时，会直接覆盖 ClassLoader 的 findClass() 方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用 defineClass() 方法生成类的 Class 对象 protected final Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len) 根据给定的字节数组 b 转换为 Class 的实例，off 和 len 参数表示实际 Class 信息在 byte 数组中的位置和长度，其中 byte 数组 b 是 ClassLoader 从外部获取的。这是受保护的方法，只有在自定义 ClassLoader 子类中可以使用 defineClass() 方法是用来将 byte 字节流解析成 JVM 能够识别的 Class 对象(ClassLoader 中已实现该方法逻辑)，通过这个方法不仅能够通过 Class 文件实例化 Class 对象，也可以通过其它方式实例化 Class 对象，如通过网络中接收一个类的字节码，然后转换为 byte 字节流创建对应的 Class 对象 defineClass() 方法通常与 findClass() 方法一起使用，一般情况下，在自定义类加载器时，会直接覆盖 ClassLoader 的 findClass() 方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用 defineClass() 方法生成类的 Class 对象 简单举例： 12345678910protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException { //获取类的字节数组 byte[] classData = getClassData(name); if (classData == null) { throw new ClassNotFoundException(); } else { //使用 defineClass 生成 Class 对象 return defineClass(name, classData, 0, classData.length); }} protected final void resolveClass(Class&lt;?&gt; c) 链接指定的一个 Java 类。使用该方法可以使用类的 Class 对象创建完成的同时也被解析。前面我们说链接阶段主要是对字节码进行验证，为类变量分配内存并设置初始值同时将字节码文件中的符号引用转换为直接引用 protected final Class&lt;?&gt; findLoadedClass(String name) 查找名称为 name 的已经被加载过的类，返回结果为 java.lang.Class 类的实例。这个方法是 final 方法，无法被修改 private final ClassLoader parent; 它也是一个 ClassLoader 的实例，这个字段所表示的 ClassLoader 也称为这个 ClassLoader 的双亲。在类加载的过程中，ClassLoader 可能会将某些请求交予自己的双亲处理 loadClass() 的剖析测试代码： ClassLoader.getSystemClassLoader().loadClass(“com.atguigu.java.User”) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/** * Loads the class with the specified &lt;a href=\"#binary-name\"&gt;binary name&lt;/a&gt;. The * default implementation of this method searches for classes in the * following order: * * &lt;ol&gt; * * &lt;li&gt;&lt;p&gt; Invoke {@link #findLoadedClass(String)} to check if the class * has already been loaded. &lt;/p&gt;&lt;/li&gt; * * &lt;li&gt;&lt;p&gt; Invoke the {@link #loadClass(String) loadClass} method * on the parent class loader. If the parent is {@code null} the class * loader built into the virtual machine is used, instead. &lt;/p&gt;&lt;/li&gt; * * &lt;li&gt;&lt;p&gt; Invoke the {@link #findClass(String)} method to find the * class. &lt;/p&gt;&lt;/li&gt; * * &lt;/ol&gt; * * &lt;p&gt; If the class was found using the above steps, and the * {@code resolve} flag is true, this method will then invoke the {@link * #resolveClass(Class)} method on the resulting {@code Class} object. * * &lt;p&gt; Subclasses of {@code ClassLoader} are encouraged to override {@link * #findClass(String)}, rather than this method. &lt;/p&gt; * * &lt;p&gt; Unless overridden, this method synchronizes on the result of * {@link #getClassLoadingLock getClassLoadingLock} method * during the entire class loading process. * * @param name * The &lt;a href=\"#binary-name\"&gt;binary name&lt;/a&gt; of the class * * @param resolve * If {@code true} then resolve the class * * @return The resulting {@code Class} object * * @throws ClassNotFoundException * If the class could not be found */protected Class&lt;?&gt; loadClass(String name, boolean resolve) //resolve:true 加载Class的同时进行解析操作 throws ClassNotFoundException{ synchronized (getClassLoadingLock(name)) { //同步操作，保证只能加载一次 // First, check if the class has already been loaded Class&lt;?&gt; c = findLoadedClass(name); if (c == null) { long t0 = System.nanoTime(); try { if (parent != null) { c = parent.loadClass(name, false); } else { c = findBootstrapClassOrNull(name); } } catch (ClassNotFoundException e) { // ClassNotFoundException thrown if class not found // from the non-null parent class loader } if (c == null) { // If still not found, then invoke findClass in order // to find the class. long t1 = System.nanoTime(); c = findClass(name); // this is the defining class loader; record the stats PerfCounter.getParentDelegationTime().addTime(t1 - t0); PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); PerfCounter.getFindClasses().increment(); } } if (resolve) {//是否进行解析操作 resolveClass(c); } return c; }} SecureClassLoader 与 URLClassLoader接着 SecureClassLoader 扩展了 ClassLoader，新增了几个与使用相关的代码源(对代码源的位置及其证书的验证)和权限定义类验证(主要针对 Class 源码的访问权限)的方法，一般我们不会直接跟这个类打交道，更多的是与它的子类 URLClassLoader 有所关联 前面说过，ClassLoader 是一个抽象类，很多方法是空的没有实现，比如 findClass()、findResource() 等。而 URLClassLoader 这个实现类为这些方法提供了具体的实现。并新增了 URLClassPath 类协助取得 Class 字节码流等功能。在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承 URLClassLoader 类，这样就可以避免自己去编写 findClass() 方法及其获取字节码流的方式，使自定义类加载器编写更加简洁 ExtClassLoader 与 AppClassLoaderExtClassLoader 并没有重写 loadClass() 方法，这足以说明其遵循双亲委派模式，而 AppClassLoader 重载了 loadClass() 方法，但最终调用的还是父类 loadClass() 方法，因此依然遵循双亲委派模式 Class.forName() 与 ClassLoader.loadClass() Class.forName()：是一个静态方法，最常用的是 Class.forName(String className)；根据传入的类的权限定名返回一个 Class 对象。该方法在将 Class 文件加载到内存的同时，会执行类的初始化。如： Class.forName(“com.atguigu.java.HelloWorld”); ClassLoader.loadClass() 这是一个实例方法，需要一个 ClassLoader 对象来调用该方法。该方法将 Class 文件加载到内存时，并不会执行类的初始化，直到这个类第一次使用时才进行初始化。该方法因为需要得到一个 ClassLoader 对象，所以可以根据需要指定使用哪个类加载器，如：ClassLoader c1 = …..; c1.loadClass(“com.atguigu.java.HelloWorld”); 双亲委派模型定义与本质类加载器用来把类加载到 Java 虚拟机中。从 JDK 1.2 版本开始，类的加载过程采用双亲委派机制，这种机制能更好地保证 Java 平台的安全 定义 如果一个类加载器在接到加载类的请求时，它首先不会自己尝试去加载这个类，而是把这个请求任务委托给父类加载器去完成，依次递归，如果父类加载器可以完成类加载任务，就成功返回。只有父类加载器无法完成此加载任务时，才自己去加载 本质 规定了类加载的顺序是：引导类加载器先加载，若加载不到，由扩展类加载器加载，若还加载不到，才会由系统类加载器或自定义的类加载器进行加载 优势与劣势 双亲委派机制优势 避免类的重复加载，确保一个类的全局唯一性 Java 类随着它的类加载器一起具备了一种带有优先级的层级关系，通过这种层级关系可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子 ClassLoader 再加载一次 保护程序安全，防止核心 API 被随意篡改 代码支持 双亲委派机制在 java.lang.ClassLoader.loadClass(String, boolean) 接口中体现。该接口的逻辑如下： 先在当前加载器的缓存中查找有无目标类，如果有，直接返回 判断当前加载器的父加载器是否为空，如果不为空，则调用 parent.loadClass(name, false) 接口进行加载 反之，如果当前加载器的父类加载器为空，则调用 findBootstrapClassOrNull(name) 接口，让引导类加载器进行加载 如果通过以上3条路径都没能成功加载，则调用 findClass(name) 接口进行加载。该接口最终会调用 java.lang.ClassLoader 接口的 defineClass 系列的 native 接口加载目标 Java 类 双亲委派的模型就隐藏在第2和第3步中 举例 假设当前加载的是 java.lang.Object 这个类，很显然，该类属于 JDK 中核心的不能再核心的一个类，因此一定只能由引导类加载器进行加载。当 JVM 准备加载 java.lang.Object 时，JVM 默认会使用系统类加载器去加载，按照上面5步加载的逻辑，在第1步从系统类的缓存中肯定查找不到该类，于是进入第2步。由于从系统类加载器的父类加载器是扩展类加载器，于是扩展类加载器继续从第1步开始重复。由于扩展类加载器的缓存中也一定查找不到该类，因此进入第2步。扩展类的父加载器是 null，因此系统调用 findClass(String)，最终通过引导类加载器进行加载 思考 如果在自定义的类加载器中重写 java.lang.ClassLoader.loadClass(String) 或 java.lang.ClassLoader.loadClass(String, boolean) 方法，抹去其中的双亲委派机制，仅保留上面这4步中的第1步和第4步，那么是不是就能够加载核心类库了呢？ 这也不行！因为 JDK 还为核心类库提供了一层保护机制。不管是自定义的类加载器，还是系统类加载器抑或扩展类加载器，最终都必须调用 java.lang.ClassLoader.defineClass(String, byte[], int, int, ProtectionDomain) 方法，而该方法会执行 preDefineClass() 接口，该接口中提供了对 JDK 核心类库的保护 双亲委派模式的弊端 检查类是否加载的委派过程是单向的，这个方式虽然从结构上说比较清晰，使各个 ClassLoader 的职责非常明确，但是同时会带来一个问题，即顶层的 ClassLoader 无法访问底层的 ClassLoader 所加载的类 通常情况下，启动类加载器中的类为系统核心类，包括一些重要的系统接口，而在应用类加载器中，为应用类。按照这种模式，应用类访问系统类自然是没有问题，但是系统类访问应用类就会出现问题。比如在系统类中提供了一个接口，该接口需要在应用类中得以实现，该接口还绑定一个工厂方法，用于创建该接口的实例，而接口和工厂方法都在启动类加载器中。这时，就会出现该工厂方法无法创建由应用类加载器加载的应用实例的问题 结论 由于 Java 虚拟机规范并没有明确要求类加载器的加载机制一定要使用双亲委派模型，只是建议采用这种方式而已。比如 Tomcat 中，类加载器所采用的加载机制就和传统的双亲委派模型有一定区别，当缺省的类加载器接收到一个类的加载任务时，首先会由它自行加载，当它加载失败时，才会将类的加载任务委派给它的超类加载器去执行，这同时也是 Servlet 规范推荐的一种做法 破坏双亲委派机制破坏双亲委派机制1双亲委派模型并不是一个具有强制性约束的模型，而是 Java 设计者推荐给开发者们的类加载器实现方式 在 Java 的世界中大部分的类加载器都遵循这个模型，但也有例外情况，直到 Java 模块化出现为止，双亲委派模型主要出现过3次较大规模”被破坏”的情况 第一次破坏双亲委派机制： 双亲委派模型的第一次”被破坏”其实发生在双亲委派模型出现之前——即 JDK 1.2 面世以前的”远古”时代 由于双亲委派模型在 JDK 1.2 之后才被引入，但是类加载器的概念和抽象类 java.lang.ClassLoader 则在 Java 的第一个版本中就已经存在，面对已经存在的用户自定义类加载器的代码，Java 设计者们引入双亲委派模型时不得不做出一些妥协，为了兼容这些已有的代码，无法再以技术手段避免 loadClass() 被子类覆盖的可能性，只能在 JDK 1.2 之后的 java.lang.ClassLoader 中添加一个新的 protected 方法 findClass()，并引导用户编写的类加载逻辑时尽可能去重写这个方法，而不是在 loadClass() 中编写代码。上节我们已经分析过 loadClass() 方法，双亲委派的具体逻辑就实现在这里面，按照 loadClass() 方法的逻辑，如果父类加载失败，会自动调用自己的 findClass() 方法来完成加载，这样既不影响用户按照自己的意愿去加载类，又可以保证新写出来的类加载器是符合双亲委派规则的 破坏双亲委派机制2第二次破坏双亲委派机制：线程像下文类加载器 双亲委派模型的第二次”被破坏”是由这个模型自身的缺陷导致的，双亲委派很好地解决了各个类加载器协作时基础类型的一致性问题(越基础的类由越上层的加载器进行加载)，基础类型之所以被称为”基础”，是因为它们总是作为被用户代码继承、调用的 API 存在，但程序设计往往没有绝对不变的完美规则，如果有基础类型又要调用回用户代码，那该怎么办？ 这并非是不可能出现的事情，一个典型的例子便是 JNDI 服务，JNDI 现在已经是 Java 的标准服务，它的代码由启动类加载器来完成加载(在 JDK 1.3 时加入到 rt.jar)，肯定属于 Java 中很基础的类型了。但 JNDI 存在的目的就是对资源进行查找和集中管理，它需要调用由其它厂商实现并部署在应用程序的 ClassPath 下的 JNDI 服务提供者接口(Service Provider Interface. SPI) 的代码，现在问题来了，启动类加载器时绝对不可能认识、加载这些代码的，那该怎么办？(SPI：在 Java 平台中，通常把核心类 rt.jar 中提供外部服务、可由应用层自行实现的接口称为 SPI) 为了解决这个困境，Java 的设计团队只好引入了一个不太优雅的设计：线程上下文类加载器(Thread Context ClassLoader)。这个类加载器可以通过 java.lang.Thread 类的 setContextClassLoader() 方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器 有了线程上下文类加载器，程序就可以做一些”舞弊”的事情了。JNDI 服务使用这个线程上下文类加载器去加载所需的 SPI 服务代码。这是一种负累加载器去请求子类加载器完成类加载的行为，这种行为实际上是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型的一般性原则，但也是无可奈何的事情。Java 中涉及 SPI 的加载基本上都采用这种方式来完成，例如 JNDI、JDBC、JCE、JAXB 和 JBI 等。不过，当 SPI 的服务提供者多于一个的时候，代码就只能根据具体提供者的类型来硬编码判断，为了消除这种极不优雅的方式，在 JDK 6 时，JDK 提供了 java.util.ServiceLoader 类，以 META-INF/Services 中的配置信息，辅以责任链模式，这才算是给 SPI 的加载提供了一种相对合理的解决方案 默认上下文加载器就是应用类加载器，这样以上下文加载器为中介，使得启动类加载器中的代码也可以访问应用类加载器中的类 破坏双亲委派机制3第三次破坏双亲委派机制： 双亲委派模型的第三次”被破坏”是由于用户对程序动态性的追求而导致的。如：代码热替换(Hot Swap)、模块热部署(Hot Deployment)等 IBM 公司主导的 JSR-291(即 OSGI R4.2)实现模块化热部署的关键是它自定义的类加载器机制的实现，每个程序模块(OSGI 中称为 Bundle)都有一个自己的类加载器，当需要更换一个 Bundle 时，就把 Bundle 连同类加载器一起换掉以实现代码的热替换。在 OSGI 环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构 当收到类加载请求时，OSGI 将按照下面的顺序进行类搜索： 将以 java.* 开头的类，委派给父类加载器加载 否则，将委派列表名单内的类，委派给父类加载器加载 否则，将 Import 列表中的类，委派给 Export 这个类的 Bundle 的类加载器加载 否则，查找当前 Bundle 的 ClassPath，使用自己的类加载器加载 否则，查找类是否在自己的 Fragment Bundle 中，如果在，则委派给 Fragment Bundle 的类加载器加载 否则，查找 Dynamic Import 列表的 Bundle，委派给对应 Bundle 的类加载器加载 否则，类查找失败 说明：只有开头两点仍然符合双亲委派模型的原则，其余的类查找都是在平级的类加载器中进行的 小结： 这里，我们使用了”被破坏”这个词来形容上述不符合双亲委派模型原则的行为，但这里”被破坏”并不一定是带有贬义的。只要有明确的目的和充分的理由，突破旧有原则无疑是一种创新 正如：OSGI 中的类加载器的设计不符合传统的双亲委派的类加载器架构，且业界对其为了实现热部署而带来的额外的高复杂度还存在不少争议，但对这方面有了解的技术人员基本还是能达成一个共识，认为 OSGI 中对类加载器的运用是值得学习的，完全弄懂了 OSGI 的实现，就算是掌握了类加载器的精髓 热替换的实现热替换是指在程序运行过程中，不停止服务，只通过替换程序文件来修改程序的行为。热替换的关键需求在于服务不能中断，修改必须立即表现正在运行的系统之中。基本上大部分脚本语言都是天生支持热替换的，比如：PHP，只要替换了 PHP 源文件，这种改动就会立即生效，而无需重启 Web 服务器 但对 Java 来说，热替换并非天生就支持，如果一个类已经加载到系统中，通过修改类文件，并无法让系统再来加载并重定义这个类。因此，在 Java 中实现这一功能的一个可行的方法就是灵活运用 ClassLoader 注意：由不同 ClassLoader 加载的同名类属于不同的类型，不能相互转换和兼容。即两个不同的 ClassLoader 加载同一个类，在虚拟机内部，会认为这2个类是完全不同的 根据这个特点，可以用来模拟热替换的实现，基本思路如下图所示： 沙箱安全机制 保护程序安全 保护 Java 原生的 JDK 代码 Java 安全模型的核心就是 Java 沙箱(Sandbox)，什么是沙箱？沙箱就是一个限制程序运行的环境 沙箱机制就是将 Java 代码限定在虚拟机(JVM)特定的运行范围中，并且严格限制代码对本地系统资源访问。通过这样的措施来保证对代码的有限隔离，防止对本地系统造成破坏 沙箱主要限制系统资源访问，那系统资源包括什么？CPU、内存、文件系统、网络。不同级别的沙箱对这些资源访问的限制也可以不一样 所有的 Java 程序运行都可以指定沙箱，可以定制安全策略 JDK 1.0 时期在 Java 中将执行程序分成本地代码和远程代码两种，本地代码默认视为可信任的，而远程代码则被看作是不受信的。对于授信的本地代码，可以访问一切本地资源。而对于非授信的远程代码在早期的 Java 实现中，安全依赖于沙箱(Sandbox)机制。如下图所示 JDK 1.0 安全模型 JDK 1.1 时期JDK 1.0 中如此严格的安全机制也给程序的功能扩展带来障碍，比如当用户希望远程代码访问本地系统的文件时候，就无法实现 因此在后续的 JDK 1.1 版本中，针对安全机制做了改进，增加了安全策略。允许用户指定代码对本地资源的访问权限 如下图所示 JDK 1.1 安全模型 JDK 1.2 时期在 JDK 1.2 版本中，再次改进了安全机制，增加了代码签名。不论本地代码或是远程代码，都会按照用户的安全策略设定，由类加载器加载到虚拟机中权限不同的运行空间，来实现差异化的代码执行权限控制。如下图所示 JDK 1.2 安全模型： JDK 1.6 时期当前最新的安全机制实现，则引入了域(Domain)的概念 虚拟机会把所有代码加载到不同的系统域和应用域。系统域部分专门负责与关键资源进行交互，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。虚拟机中不同的受保护域(Protected Domain)，对应不一样的权限(Permission)。存在于不同域中的类文件就具有了当前域的全部权限，如下图所示，最新的安全模型(JDK 1.6) 自定义类的加载器 为什么要自定义类加载器？ 隔离加载类 在某些框架内进行中间件与应用的模块隔离，把类加载到不同的环境。比如：阿里内某容器框架通过自定义类加载器确保应用中依赖的 jar 包不会影响到中间件运行时使用的 jar 包。再比如：Tomcat 这类 Web 应用服务器，内部自定义了好几种类加载器，用于隔离同一个 Web 应用服务器上的不同应用程序。(类的仲裁 —&gt; 类冲突) 修改类加载的方式 类的加载模型并非强制，除 Bootstrap 外，其他的加载并非一定要引入，或者根据实际情况在某个时间点按需进行动态加载 扩展加载源 比如从数据库、网络、甚至是电视机机顶盒进行加载 防止源码泄露 Java 代码容易被编译和篡改，可以进行编译加密。那么类加载也需要自定义，还原加密的字节码 常见的场景 实现类似进程内隔离，类加载器实际上用作不同的命名空间，以提供类似容器、模块化的效果。例如，两个模块依赖于某个类库的不同版本，如果分别被不同的容器加载，就可以互不干扰。这个方面的集大成者是 Java EE 和 OSGI、JPMS 等框架 应用需要从不同的数据源获取类定义信息，例如网络数据源，而不是本地文件系统。或者是需要自己操纵字节码，动态修改或者生成类型 注意 在一般情况下，使用不同的类加载器去加载不同的功能模块，会提高应用程序的安全性。但是，如果涉及 Java 类型转换，则加载器反而容易产生不美好的事情。在做 Java 类型转换时，只有两个类型都是由同一个加载器所加载，才能进行类型转换，否则转换时会发生异常 实现方式用户通过定制自己的类加载器，这样可以重新定义类的加载规则，以便实现一些自定义的处理逻辑 实现方式 Java 提供了抽象类 java.lang.ClassLoader，所有用户自定义的类加载器都应该继承 ClassLoader 类 在自定义 ClassLoader 的子类时候，我们常见的会有两种做法： 方式一：重写 loadClass() 方法 方式二：重写 findClass() 方法 对比 这两种方法本质上差不多，毕竟 loadClass() 也会调用 findClass()，但是从逻辑上讲我们最好不要直接修改 loadClass() 的内部逻辑。建议的做法是只在 findClass() 里重写自定义类的加载方法，根据参数指定类的名字，返回对应的 Class 对象的引用 loadClass() 这个方法是实现双亲委派模型逻辑的地方，擅自修改这个方法会导致模型被破坏，容易造成问题。因此我们最好是在双亲委派模型框架内进行小范围的改动，不破坏原有的稳定结构。同时，也避免了自己重写 loadClass() 方法的过程中必须写双亲委托的重复代码，从代码的复用性来看，不直接修改这个方法始终是比较好的选择 当编写好自定义类加载器后，便可以在程序中调用 loadClass() 方法来实现类加载操作 说明 其父类加载器是系统类加载器 JVM 中的所有类加载都会使用 java.lang.ClassLoader.loadClass(String) 接口(自定义类加载器并重写 java.lang.ClassLoader.loadClass(String) 接口的除外)，连 JDK 的核心类库也不能例外 Java 9 新特性为了保证兼容性，JDK 9 没有从根本上改变三层类加载器架构和双亲委派模型，但为了模块化系统的顺利运行，仍然发生了一些值得被注意的变动 扩展机制被移除，扩展类加载器由于向后兼容性的原因被保留，不过被重命名为平台类加载器(Platform Class Loader)。可以通过 ClassLoader 的新方法 getPlatformClassLoader() 来获取 JDK 9 时基于模块化进行构建(原来的 rt.jar 和 tools.jar 被拆分成数十个 JMOD 文件)，其中的 Java 类库就已天然地满足了可扩展的需求，那自然无需再保留 \\lib\\ext 目录，此前使用这个目录或者 java.ext.dirs 系统变量来扩展 JDK 功能的机制已经没有继续存在的价值了 平台类加载器和应用程序类加载器都不再继承自 java.net.URLClassLoader 现在启动类加载器、平台类加载器、应用程序类加载器全都继承于 jdk.internal.loader.BuiltinClassLoader 如果有程序直接依赖了这种继承关系，或者依赖了 URLClassLoader 类的特定方法，那代码很可能会在 JDK 9 及更高版本的 JDK 中崩溃 在 Java 9 中，类加载器有了名称。该名称在构造方法中指定，可以通过 getName() 方法来获取。平台类加载器的名称是 Platform，应用类加载器的名称是 App。类加载器的名称在调试与类加载器相关的问题时会非常有用 启动类加载器现在是在 JVM 内部和 Java 类库共同协作实现的类加载器(以前是 C++ 实现)，但为了与之前代码兼容，在获取启动类加载器的场景中仍然会返回 null，而不会得到 BootClassLoader 实例 类加载的委派关系也发生了变动 当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责哪个模块的加载器完成加载 双亲委派模式示意图 附加： 在 Java 模块化系统明确规定了三个类加载器负责各自加载的模块： 启动类加载器负责加载的模块 12345678910java.base java.security.sasljava.datatransfer java.xmljava.desktop jdk.httpserverjava.instrument jdk.internal.vm.cijava.logging jdk.managementjava.management jdk.management.agentjava.management.rmi jdk.naming.rmijava.naming jdk.netjava.prefs jdk.sctpjava.rmi jdk.unsupported 平台类加载器负责加载的模块 123456789101112131415java.activation* jdk.accessibilityjava.compiler* jdk.charsetsjava.corba* jdk.crypto.cryptokijava.scripting jdk.crypto.ecjava.se jdk.dynalinkjava.se.se jdk.incubator.httpclientjava.security.jgss jdk.internal.vm.compiler*java.smartcardio jdk.jsobjectjava.sql jdk.localedatajava.sql.rowset jdk.naming.dnsjava.transaction* jdk.scripting.nashornjava.xml.bind* jdk.security.authjava.xml.crypto jdk.security.jgssjava.xml.ws* jdk.xml.domjava.xml.ws.annotation* jdk.zipfs 应用程序类加载器负责加载的模块 123456jdk.aot jdk.jdepsjdk.attach jdk.jdijdk.compiler jdk.jdwp.agentjdk.editpad jdk.jlinkjdk.hotspot.agent jdk.jshelljdk.internal.ed jdk.jstatd","link":"/2020/10/23/%E5%B0%9A%E7%A1%85%E8%B0%B7JVM/%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%80%E7%AB%A0_%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/"},{"title":"尚硅谷JVM&#x2F;第六章_本地方法接口","text":"本地方法接口什么是本地方法 简单地讲，一个 Native Method 是一个 Java 调用非 Java 代码的接囗。一个 Native Method 是这样一个 Java 方法：该方法的实现由非 Java 语言实现，比如 C。这个特征并非 Java 所特有，很多其它的编程语言都有这一机制，比如在 C++ 中，你可以用 extern “c” 告知 C++ 编译器去调用一个 C 的函数。 “A native method is a Java method whose implementation is provided by non-java code.”（本地方法是一个非 Java 的方法，它的具体实现是非 Java 代码的实现） 在定义一个 Native Method 时，并不提供实现体（有些像定义一个 Java interface），因为其实现体是由非 Java 语言在外面实现的。 本地接口的作用是融合不同的编程语言为 Java 所用，它的初衷是融合 C/C++ 程序。 代码举例说明 Native 方法是如何编写的 123456public class IhaveNatives { public native void Native1(int x); native static public long Native2(); native synchronized private float Native3(Object o); native void Natives(int[] ary) throws Exception;} 需要注意的是：标识符 native 可以与其它 Java 标识符连用，但是 abstract 除外 为什么使用 Native Method ？Java 使用起来非常方便，然而有些层次的任务用 Java 实现起来不容易，或者我们对程序的效率很在意时，问题就来了。 与 Java 环境的交互有时 Java 应用需要与 Java 外面的环境交互，这是本地方法存在的主要原因。你可以想想 Java 需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解 Java 应用之外的繁琐的细节。 与操作系统的交互JVM 支持着 Java 语言本身和运行时库，它是 Java 程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一底层系统的支持。这些底层系统常常是强大的操作系统。通过使用本地方法，我们得以用 Java 实现了 jre 的与底层系统的交互，甚至 JVM 的一些部分就是用 C 写的。还有，如果我们要使用一些 Java 语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。 Sun’s JavaSun 的解释器是用 C 实现的，这使得它能像一些普通的 C 一样与外部交互。jre 大部分是用 Java 实现的，它也通过一些本地方法与外界交互。例如：类 java.lang.Thread 的 setPriority（）方法是用 Java 实现的，但是它实现调用的是该类里的本地方法 setPriority0（）。这个本地方法是用 C 实现的，并被植入 JVM 内部，在Windows 95 的平台上，这个本地方法最终将调用 Win32 setPriority（）API。这是一个本地方法的具体实现由JVM 直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVM 调用。 现状目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过 Java 程序驱动打印机或者 Java 系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用 Socket 通信，也可以使用 Web Service 等等，不多做介绍。","link":"/2020/10/16/%E5%B0%9A%E7%A1%85%E8%B0%B7JVM/%E7%AC%AC%E5%85%AD%E7%AB%A0_%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3/"},{"title":"尚硅谷JVM&#x2F;第二章_类加载子系统","text":"类加载子系统内存结构概述 完整图如下 如果自己想手写一个 Java 虚拟机的话，主要考虑哪些结构呢？ 类加载器 执行引擎 类加载器子系统的加载过程类加载器子系统负责从文件系统或者网络中加载 class 文件，class 文件在文件开头有特定的文件标识。 ClassLoader 只负责 class 文件的加载，至于它是否可以运行，则由 Execution Engine 决定。 加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是 class 文件中常量池部分的内存映射） class file 存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到JVM 当中来根据这个文件实例化出 n 个一模一样的实例。 class file 加载到 JVM 中，被称为 DNA 元数据模板，放在方法区。 在 class 文件 -&gt; JVM -&gt; 最终成为元数据模板，此过程就要一个运输工具（类装载器Class Loader），扮演一个快递员的角色。 类的加载过程例如下面的一段简单的代码 12345public class HelloLoader { public static void main(String[] args) { System.out.println(\"我已经被加载啦\"); }} 它的加载过程是怎么样的呢? 完整的流程图如下所示 加载 通过一个类的全限定名获取定义此类的二进制字节流 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口 补充：加载 .class 文件的方式 从本地系统中直接加载 通过网络获取，典型场景：Web Applet 从 zip 压缩包中读取，成为日后 jar、war 格式的基础 运行时计算生成，使用最多的是：动态代理技术 由其他文件生成，典型场景：JSP 应用从专有数据库中提取 .class 文件，比较少见 从加密文件中获取，典型的防 class 文件被反编译的保护措施 链接验证 Verify 目的在于确保 class 文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。 主要包括四种验证：文件格式验证，元数据验证，字节码验证，符号引用验证。 工具：Binary Viewer 查看 如果出现不合法的字节码文件，那么将会验证不通过 同时我们可以通过安装 IDEA 的插件，来查看我们的 class 文件 安装完成后，我们编译完一个 class 文件后，点击 view 即可显示我们安装的插件来查看字节码方法了 准备 Prepare为类变量分配内存并且设置该类变量的默认初始值，即零值。 123456public class HelloApp { private static int a = 1; // 准备阶段为0，在下个阶段，也就是初始化的时候才是1 public static void main(String[] args) { System.out.println(a); }} 上面的变量 a 在准备阶段会赋初始值，但不是1，而是0。 为类变量分配内存并且设置该类变量的默认初始值，即零值； 这里不包含用 final 修饰的 static，因为 final 在编译的时候就会分配了，准备阶段会显式初始化； 这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到 Java 堆中。 解析 Resolve 将常量池内的符号引用转换为直接引用的过程。 事实上，解析操作往往会伴随着 JVM 在执行完初始化之后再执行。 符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《Java虚拟机规范》的 class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的 CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info 等 初始化 初始化阶段就是执行类构造器法 （）的过程。 此方法不需定义，是 javac 编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。 也就是说，当我们代码中包含 static 变量的时候，就会有 clinit 方法 构造器方法中指令按语句在源文件中出现的顺序执行。 （）不同于类的构造器。（关联：构造器是虚拟机视角下的 （）） 若该类具有父类，JVM 会保证子类的 （）执行前，父类的 （）已经执行完毕。 虚拟机必须保证一个类的 （）方法在多线程下被同步加锁。 任何一个类在声明后，都有生成一个构造器，默认是空参构造器 12345678910111213141516public class ClassInitTest { private static int num = 1; static { num = 2; number = 20; System.out.println(num); System.out.println(number); //报错，非法的前向引用 } private static int number = 10; public static void main(String[] args) { System.out.println(ClassInitTest.num); // 2 System.out.println(ClassInitTest.number); // 10 }} 关于涉及到父类时候的变量赋值过程 12345678910111213141516public class ClinitTest1 { static class Father { public static int A = 1; static { A = 2; } } static class Son extends Father { public static int b = A; } public static void main(String[] args) { System.out.println(Son.b); }} 我们输出结果为 2，也就是说首先加载 ClinitTest1 的时候，会找到 main 方法，然后执行 Son 的初始化，但是Son 继承了 Father，因此还需要执行 Father 的初始化，同时将 A 赋值为2。我们通过反编译得到 Father 的加载过程，首先我们看到原来的值被赋值成1，然后又被复制成2，最后返回 12345iconst_1putstatic #2 &lt;com/atguigu/java/chapter02/ClinitTest1$Father.A&gt;iconst_2putstatic #2 &lt;com/atguigu/java/chapter02/ClinitTest1$Father.A&gt;return 虚拟机必须保证一个类的（）方法在多线程下被同步加锁。 1234567891011121314151617181920212223public class DeadThreadTest { public static void main(String[] args) { new Thread(() -&gt; { System.out.println(Thread.currentThread().getName() + \"\\t 线程t1开始\"); new DeadThread(); }, \"t1\").start(); new Thread(() -&gt; { System.out.println(Thread.currentThread().getName() + \"\\t 线程t2开始\"); new DeadThread(); }, \"t2\").start(); }}class DeadThread { static { if (true) { System.out.println(Thread.currentThread().getName() + \"\\t 初始化当前类\"); while(true) { } } }} 上面的代码，输出结果为 123线程t1开始线程t2开始线程t2 初始化当前类 从上面可以看出初始化后，只能够执行一次初始化，这也就是同步加锁的过程 类加载器的分类JVM 支持两种类型的类加载器 。分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）。 从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是 Java 虚拟机规范却没有这么定义，而是将所有派生于抽象类 ClassLoader 的类加载器都划分为自定义类加载器。 无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有3个，如下所示： 这里的四者之间是包含关系，不是上层和下层，也不是子系统的继承关系。 我们通过一个类，获取它不同的加载器 1234567891011121314151617181920212223public class ClassLoaderTest { public static void main(String[] args) { // 获取系统类加载器 ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader(); System.out.println(systemClassLoader); // 获取其上层的：扩展类加载器 ClassLoader extClassLoader = systemClassLoader.getParent(); System.out.println(extClassLoader); // 试图获取 根加载器 ClassLoader bootstrapClassLoader = extClassLoader.getParent(); System.out.println(bootstrapClassLoader); // 获取自定义加载器 ClassLoader classLoader = ClassLoaderTest.class.getClassLoader(); System.out.println(classLoader); // 获取String类型的加载器 ClassLoader classLoader1 = String.class.getClassLoader(); System.out.println(classLoader1); }} 得到的结果，从结果可以看出，根加载器无法直接通过代码获取，同时目前用户代码所使用的加载器为系统类加载器。同时我们通过获取 String 类型的加载器，发现是 null ，那么说明 String 类型是通过根加载器进行加载的，也就是说 Java 的核心类库都是使用根加载器进行加载的。 虚拟机自带的加载器启动类加载器（引导类加载器，Bootstrap ClassLoader） 这个类加载使用 C/C++ 语言实现的，嵌套在 JVM 内部。 它用来加载 Java 的核心库（JAVAHOME/jre/lib/rt.jar、resources.jar 或 sun.boot.class.path 路径下的内容），用于提供 JVM 自身需要的类 并不继承自 java.lang.ClassLoader，没有父加载器。 加载扩展类和应用程序类加载器，并指定为他们的父类加载器。 出于安全考虑，Bootstrap 启动类加载器只加载包名为 java、javax、sun 等开头的类 扩展类加载器（Extension ClassLoader） Java 语言编写，由 sun.misc.Launcher$ExtClassLoader 实现。 派生于 ClassLoader 类 父类加载器为启动类加载器 从 java.ext.dirs 系统属性所指定的目录中加载类库，或从 JDK 的安装目录的 jre/lib/ext 子目录（扩展目录）下加载类库。如果用户创建的 JAR 放在此目录下，也会自动由扩展类加载器加载。 应用程序类加载器（系统类加载器，AppClassLoader） Java 语言编写，由 sun.misc.LaunchersAppClassLoader 实现 派生于 ClassLoader 类 父类加载器为扩展类加载器 它负责加载环境变量 classpath 或系统属性 java.class.path 指定路径下的类库 该类加载是程序中默认的类加载器，一般来说，Java 应用的类都是由它来完成加载 通过 ClassLoader#getSystemClassLoader() 方法可以获取到该类加载器 用户自定义类加载器在 Java 的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。为什么要自定义类加载器？ 隔离加载类 修改类加载的方式 扩展加载源 防止源码泄漏 用户自定义类加载器实现步骤： 开发人员可以通过继承抽象类 java.lang.ClassLoader 类的方式，实现自己的类加载器，以满足一些特殊的需求 在 JDK 1.2 之前，在自定义类加载器时，总会去继承 ClassLoader 类并重写 loadClass() 方法，从而实现自定义的类加载类，但是在 JDK 1.2 之后已不再建议用户去覆盖 loadClass() 方法，而是建议把自定义的类加载逻辑写在 findClass() 方法中 在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承 URIClassLoader 类，这样就可以避免自己去编写 findClass() 方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。 查看根加载器所能加载的目录刚刚我们通过概念了解到了，根加载器只能够加载 java/lib目录下的class，我们通过下面代码验证一下 12345678910111213public class ClassLoaderTest1 { public static void main(String[] args) { System.out.println(\"*********启动类加载器************\"); // 获取BootstrapClassLoader 能够加载的API的路径 URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs(); for (URL url : urls) { System.out.println(url.toExternalForm()); } // 从上面路径中，随意选择一个类，来看看他的类加载器是什么：得到的是null，说明是 根加载器 ClassLoader classLoader = Provider.class.getClassLoader(); }} 得到的结果 12345678910*********启动类加载器************file:/E:/Software/JDK1.8/Java/jre/lib/resources.jarfile:/E:/Software/JDK1.8/Java/jre/lib/rt.jarfile:/E:/Software/JDK1.8/Java/jre/lib/sunrsasign.jarfile:/E:/Software/JDK1.8/Java/jre/lib/jsse.jarfile:/E:/Software/JDK1.8/Java/jre/lib/jce.jarfile:/E:/Software/JDK1.8/Java/jre/lib/charsets.jarfile:/E:/Software/JDK1.8/Java/jre/lib/jfr.jarfile:/E:/Software/JDK1.8/Java/jre/classesnull 关于ClassLoaderClassLoader 类，它是一个抽象类，其后所有的类加载器都继承自 ClassLoader（不包括启动类加载器） sun.misc.Launcher 它是一个 Java 虚拟机的入口应用 获取 ClassLoader 的途径 获取当前 ClassLoader：clazz.getClassLoader() 获取当前线程上下文的 ClassLoader：Thread.currentThread().getContextClassLoader() 获取系统的 ClassLoader：ClassLoader.getSystemClassLoader() 获取调用者的 ClassLoader：DriverManager.getCallerClassLoader() 双亲委派机制Java 虚拟机对 class 文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的 class 文件加载到内存生成 class 对象。而且加载某个类的 class 文件时，Java 虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。 工作原理 如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行； 如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器； 如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。 双亲委派机制举例当我们加载 jdbc.jar 用于实现数据库连接的时候，首先我们需要知道的是 jdbc.jar 是基于 SPI 接口进行实现的，所以在加载的时候，会进行双亲委派，最终从根加载器中加载 SPI 核心类，然后在加载 SPI 接口类，接着在进行反向委派，通过线程上下文类加载器进行实现类 jdbc.jar 的加载。 沙箱安全机制自定义 String 类，但是在加载自定义 String 类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载 JDK 自带的文件（rt.jar包中java\\lang\\String.class），报错信息说没有 main 方法，就是因为加载的是 rt.jar 包中的 String 类。这样可以保证对 Java 核心源代码的保护，这就是沙箱安全机制。 双亲委派机制的优势通过上面的例子，我们可以知道，双亲机制可以 避免类的重复加载 保护程序安全，防止核心 API 被随意篡改 自定义类：java.lang.String 自定义类：java.lang.ShkStart（报错：阻止创建 java.lang 开头的类） 其它如何判断两个 class 对象是否相同在 JVM 中表示两个 class 对象是否为同一个类存在两个必要条件： 类的完整类名必须一致，包括包名。 加载这个类的 ClassLoader（指 ClassLoader 实例对象）必须相同。 换句话说，在 JVM 中，即使这两个类对象（class对象）来源同一个 Class 文件，被同一个虚拟机所加载，但只要加载它们的 ClassLoader 实例对象不同，那么这两个类对象也是不相等的。 JVM 必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么 JVM 会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。当解析一个类型到另一个类型的引用的时候，JVM 需要保证这两个类型的类加载器是相同的。 类的主动使用和被动使用Java 程序对类的使用方式分为：主动使用和被动使用。主动使用，又分为七种情况： 创建类的实例 访问某个类或接口的静态变量，或者对该静态变量赋值 调用类的静态方法 反射（比如：Class.forName（”com.atguigu.Test”）） 初始化一个类的子类 Java 虚拟机启动时被标明为启动类的类 JDK 7 开始提供的动态语言支持： java.lang.invoke.MethodHandle 实例的解析结果 REF getStatic、REF putStatic、REF invokeStatic 句柄对应的类没有初始化，则初始化 除了以上七种情况，其他使用 Java 类的方式都被看作是对类的被动使用，都不会导致类的初始化。","link":"/2020/10/16/%E5%B0%9A%E7%A1%85%E8%B0%B7JVM/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/"},{"title":"尚硅谷JVM&#x2F;第十一章_直接内存","text":"直接内存 Direct Memory 不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。 直接内存是在 Java 堆外的、直接向系统申请的内存区间。 来源于 NIO ，通过存在堆中的 DirectByteBuffer 操作 Native 内存 通常，访问直接内存的速度会优于 Java 堆。即读写性能高。 因此出于性能考虑，读写频繁的场合可能会考虑使用直接内存。 Java 的 NIO 库允许 Java 程序使用直接内存，用于数据缓冲区 使用下列代码，直接分配本地内存空间 12int BUFFER = 1024 * 1024 * 1024; // 1GBByteBuffer byteBuffer = ByteBuffer.allocateDirect(BUFFER); 非直接缓存区和直接缓存区原来采用 BIO 的架构，我们需要从用户态切换成内核态 NIO 的方式使用了直接缓存区的概念 存在的问题也可能导致 OutOfMemoryError 异常 由于直接内存在 Java 堆外，因此它的大小不会直接受限于 -Xmx 指定的最大堆大小，但是系统内存是有限的，Java 堆和直接内存的总和依然受限于操作系统能给出的最大内存。 缺点 分配回收成本较高 不受 JVM 内存回收管理 直接内存大小可以通过 MaxDirectMemorySize 设置 如果不指定，默认与堆的最大值 -Xmx 参数值一致","link":"/2020/10/16/%E5%B0%9A%E7%A1%85%E8%B0%B7JVM/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0_%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98/"},{"title":"尚硅谷JVM&#x2F;第八章_堆","text":"堆堆的核心概念 堆和方法区针对一个 JVM 进程来说是唯一的，也就是一个进程只有一个 JVM ，但是进程包含多个线程，他们是共享同一堆和方法区空间的，每个线程各自包含一套程序计数器、本地方法栈和虚拟机栈。 一个 JVM 实例只存在一个堆内存，堆也是 Java 内存管理的核心区域。 Java 堆区在 JVM 启动的时候即被创建，其空间大小也就确定了。是 JVM 管理的最大一块内存空间。 堆内存的大小是可以调节的。 《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。 所有的线程共享 Java 堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）。 -Xms10m：最小堆内存 -Xmx10m：最大堆内存 下图就是使用：Java VisualVM 查看堆空间的内容，通过 jdk/bin提供的插件 《Java虚拟机规范》中对 Java 堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。（The heap is the run-time data area from which memory for all class instances and arrays is allocated） 我要说的是：“几乎”所有的对象实例都在这里分配内存。——从实际使用角度看的。 因为还有一些对象是在栈上分配的 数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。 在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。 也就是触发了 GC 的时候，才会进行回收 如果堆中对象马上被回收，那么用户线程就会收到影响，因为有 Stop The World 堆，是 GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。 堆内存细分Java 7 及之前堆内存逻辑上分为三部分：新生区+养老区+永久区 Young Generation Space 新生区 Young/New 又被划分为 Eden 区和 Survivor 区 Tenure Generation Space 养老区 Old/Tenure Permanent Space 永久区 Perm Java 8 及之后堆内存逻辑上分为三部分：新生区+养老区+元空间 Young Generation Space 新生区 Young/New 又被划分为 Eden 区和 Survivor 区 Tenure Generation Space 养老区 Old/Tenure Meta Space 元空间 Meta 约定：新生区 &lt;-&gt; 新生代 &lt;-&gt; 年轻代 、 养老区 &lt;-&gt; 老年区 &lt;-&gt; 老年代、 永久区 &lt;-&gt; 永久代 堆空间内部结构，JDK 1.8 时从永久代替换成元空间 设置堆内存大小与 OOMJava 堆区用于存储 Java 对象实例，那么堆的大小在 JVM 启动时就已经设定好了，大家可以通过选项”-Xmx”和”-Xms”来进行设置。 “-Xms” 用于表示堆区的起始内存，等价于 -XX:InitialHeapSize “-Xmx” 则用于表示堆区的最大内存，等价于 -XX:MaxHeapSize 一旦堆区中的内存大小超过 “-Xmx” 所指定的最大内存时，将会抛出 OutOfMemoryError 异常。 通常会将 -Xms 和 -Xmx 两个参数配置相同的值，其目的是为了能够在 Java 垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。 默认情况下： 初始内存大小：物理电脑内存大小/64 最大内存大小：物理电脑内存大小/4 12345678910public class HeapSpaceInitial { public static void main(String[] args) { // 返回Java虚拟机中的堆内存总量 long initialMemory = Runtime.getRuntime().totalMemory() / 1024 / 1024; // 返回Java虚拟机试图使用的最大堆内存 long maxMemory = Runtime.getRuntime().maxMemory() / 1024 / 1024; System.out.println(\"-Xms:\" + initialMemory + \"M\"); System.out.println(\"-Xmx:\" + maxMemory + \"M\"); }} 输出结果 12-Xms:245M-Xmx:3623M 开发中建议将初始堆内存和最大堆内存设置成相同的值 如何查看堆内存的内存分配情况 1jps -&gt; jstat -gc 进程id 1-XX:+PrintGCDetails 为什么设置初始堆内存为600M，实际只有575M？ 答：因为在新生代中，数据存放在 Eden 区和 Survivor 区，其中 Survivor0 和 Survivor1 区只能二选一存放，少了一个25600 / 1024 = 25M。 OutOfMemory 举例123456789public class OOMTest { public static void main(String[] args) { ArrayList&lt;Picture&gt; list = new ArrayList&lt;&gt;(); while (true) { list.add(new Picture(new Random().nextInt(1024 * 1024))); } }} 我们简单的写一个 OOM 例子 12345678public class OOMTest { public static void main(String[] args) { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); while(true) { list.add(999999999); } }} 然后设置启动参数 1-Xms10m -Xmx:10m 运行后，就出现 OOM 了，那么我们可以通过 VisualVM 这个工具查看具体是什么参数造成的 OOM 年轻代与老年代存储在 JVM 中的 Java 对象可以被划分为两类： 一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速 生命周期短的，及时回收即可 另外一类对象的生命周期却非常长，在某些极端的情况下还能够与 JVM 的生命周期保持一致 Java 堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（OldGen） 其中年轻代又可以划分为 Eden 空间、Survivor0 空间和 Survivor1 空间（有时也叫做 From 区、To 区） 下面这参数开发中一般不会调： Eden : From : To -&gt; 8 : 1 : 1 新生代 : 老年代 - &gt; 1 : 2 配置新生代与老年代在堆结构的占比。 默认-XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3 可以修改-XX:NewRatio=4，表示新生代占1，老年代占4，新生代占整个堆的1/5 当发现在整个项目中，生命周期长的对象偏多，那么就可以通过调整老年代的大小，来进行调优 在 HotSpot 中，Eden 空间和另外两个 Survivor 空间缺省所占的比例是8 : 1 : 1，当然开发人员可以通过选项“-XX:SurvivorRatio”调整这个空间比例。比如-XX:SurvivorRatio=8 为什么默认是8:1:1，而实际当中是6:1:1？ 答：因为存在自适应机制，即-XX:-UseAdaptiveSizePolicy(+启用，-禁用)，但这种方法一般不能生效，所以一般采用-XX:SurvivorRatio=8 几乎所有的 Java 对象都是在 Eden 区被 new 出来的。绝大部分的 Java 对象的销毁都在新生代进行了。（有些大的对象在 Eden 区无法存储时候，将直接进入老年代） IBM 公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。 可以使用选项”-Xmn”设置新生代最大内存大小(优先级高于-XX:NewRatio) 这个参数一般使用默认值就可以了。 图解对象分配过程概述为新对象分配内存是一件非常严谨和复杂的任务，JVM 的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑 GC 执行完内存回收后是否会在内存空间中产生内存碎片。 new 的对象先放伊甸园区。此区有大小限制。 当伊甸园的空间填满时，程序又需要创建对象，JVM 的垃圾回收器将对伊甸园区进行垃圾回收（MinorGC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区 然后将伊甸园中的剩余对象移动到幸存者0区。 如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。 如果再次经历垃圾回收，此时会重新放回 Survivor0 区，接着再去 Survivor1 区。 啥时候能去养老区呢？可以设置次数。默认是15次。 可以设置参数：-Xx:MaxTenuringThreshold=N进行设置 在养老区，相对悠闲。当养老区内存不足时，再次触发 GC : Major GC，进行养老区的内存清理 若养老区执行了 Major GC 之后，发现依然无法进行对象的保存，就会产生 OOM 异常。 java.lang.OutOfMemoryError: Java heap space 图解过程我们创建的对象，一般都是存放在 Eden 区的，当我们 Eden 区满了后，就会触发 GC 操作，一般被称为 YGC / Minor GC 操作 当我们进行一次垃圾收集后，红色的将会被回收，而绿色的还会被占用着，存放在 S0(Survivor From) 区。同时我们给每个对象设置了一个年龄计数器，一次回收后就是1。 同时 Eden 区继续存放对象，当 Eden 区再次存满的时候，又会触发一个 MinorGC 操作，此时 GC 将会把 Eden 和 Survivor From 中的对象进行一次收集，把存活的对象放到 Survivor To区，同时让年龄 + 1 我们继续不断的进行对象生成和垃圾回收，当 Survivor 中的对象的年龄达到15的时候，将会触发一次 Promotion 晋升的操作，也就是将年轻代中的对象晋升到老年代中 思考：幸存区区满了后？特别注意，在 Eden 区满了的时候，才会触发 Minor GC，而 Survivor 区满了后，不会触发 Minor GC 操作 如果 Survivor 区满了后，将会触发一些特殊的规则，也就是可能直接晋升老年代 举例：以当兵为例，正常人的晋升可能是 ： 新兵 -&gt; 班长 -&gt; 排长 -&gt; 连长 但是也有可能有些人因为做了非常大的贡献，直接从 新兵 -&gt; 排长 对象分配的特殊情况 代码演示对象分配过程我们不断的创建大对象 123456789101112131415public class Test { byte[] buffer = new byte[new Random().nextInt(1024 * 1024)]; public static void main(String[] args) { ArrayList&lt;Test&gt; list = new ArrayList&lt;&gt;(); while (true) { list.add(new Test()); try { Thread.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } } }} 然后设置 JVM 参数 1-Xms600m -Xmx600m 然后 cmd 输入下面命令，打开 VisualVM 图形化界面 1jvisualvm 然后通过执行上面代码，通过 VisualGC 进行动态化查看 最终，在老年代和新生代都满了，就出现 OOM 123Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space at com.atguigu.java.chapter08.HeapInstanceTest.&lt;init&gt;(HeapInstanceTest.java:13) at com.atguigu.java.chapter08.HeapInstanceTest.main(HeapInstanceTest.java:17) 常用的调优工具 JDK命令行 Eclipse：Memory Analyzer Tool Jconsole Visual VM（实时监控 推荐~） Jprofiler（推荐~） Java Flight Recorder（实时监控） GCViewer GCEasy 总结 针对幸存者 S0，S1 区的总结：复制之后有交换，谁空谁是 To 关于垃圾回收：频繁在新生区收集，很少在老年代收集，几乎不再永久代和元空间进行收集 新生代采用复制算法的目的：是为了减少内碎片 Minor GC，MajorGC、Full GC Minor GC：新生代的 GC Major GC：老年代的 GC Full GC：整堆收集，收集整个 Java 堆和方法区的垃圾收集 我们都知道，JVM 的调优的一个环节，也就是垃圾收集，我们需要尽量的避免垃圾回收，因为在垃圾回收的过程中，容易出现 STW 的问题 而 Major GC 和 Full GC 出现 STW 的时间，是 Minor GC 的10倍以上 JVM 在进行 GC 时，并非每次都对上面三个内存（新生代、老年代；方法区）区域一起回收的，大部分时候回收的都是指新生代。 针对 HotSpot VM 的实现，它里面的 GC 按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（Full GC） 部分收集：不是完整收集整个 Java 堆的垃圾收集。其中又分为： 新生代收集（Minor GC/Young GC）：只是新生代的垃圾收集 老年代收集（Major GC/Old GC）：只是老年代的圾收集。 目前，只有 CMS GC 会有单独收集老年代的行为。 注意，很多时候 Major GC会和 Full GC 混淆使用，需要具体分辨是老年代回收还是整堆回收。 混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集。 目前，只有 G1 GC 会有这种行为 整堆收集（Full GC）：收集整个 Java 堆和方法区的垃圾收集。 Minor GC年轻代GC（Minor GC）触发机制： 当年轻代空间不足时，就会触发 Minor GC ，这里的年轻代满指的是 Eden 代满，Survivor 满不会引发 GC 。（每次 Minor GC 会清理年轻代的内存。） 因为 Java 对象大多都具备朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。 Minor GC 会引发 STW ，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行 STW：Stop The World Major GC老年代GC（Major GC/Full GC）触发机制： 指发生在老年代的 GC ，对象从老年代消失时，我们说 “Major GC” 或 “Full GC” 发生了 出现了 Major GC ，经常会伴随至少一次的 Minor GC （但非绝对的，在 Parallel Scavenge 收集器的收集策略里就有直接进行 Major GC 的策略选择过程） 也就是在老年代空间不足时，会先尝试触发 Minor GC 。如果之后空间还不足，则触发 Major GC Major GC 的速度一般会比 Minor GC 慢10倍以上， STW 的时间更长 如果 Major GC 后，内存还不足，就报 OOM 了 Full GC触发 Full GC 执行的情况有如下五种： 调用 System.gc（） 时，系统建议执行 Full GC ，但是不必然执行 老年代空间不足 方法区空间不足 通过 Minor GC 后进入老年代的平均大小大于老年代的可用内存 由 Eden 区、Survivor space0（From Space）区向 Survivor space1（To Space）区复制时，对象大小大于 To Space 可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小 说明：Full GC 是开发或调优中尽量要避免的。这样暂时时间会短一些 GC 举例我们编写一个 OOM 的异常，因为我们在不断的创建字符串，是存放在元空间的 12345678910111213141516public class GCTest { public static void main(String[] args) { int i = 0; try { List&lt;String&gt; list = new ArrayList&lt;&gt;(); String a = \"mogu blog\"; while(true) { list.add(a); a = a + a; i++; } }catch (Exception e) { e.getStackTrace(); } }} 设置 JVM 启动参数 1-Xms10m -Xmx10m -XX:+PrintGCDetails 打印出的日志 1234567891011121314151617181920[GC (Allocation Failure) [PSYoungGen: 2038K-&gt;500K(2560K)] 2038K-&gt;797K(9728K), 0.3532002 secs] [Times: user=0.01 sys=0.00, real=0.36 secs] [GC (Allocation Failure) [PSYoungGen: 2108K-&gt;480K(2560K)] 2405K-&gt;1565K(9728K), 0.0014069 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC (Ergonomics) [PSYoungGen: 2288K-&gt;0K(2560K)] [ParOldGen: 6845K-&gt;5281K(7168K)] 9133K-&gt;5281K(9728K), [Metaspace: 3482K-&gt;3482K(1056768K)], 0.0058675 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] [GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2560K)] 5281K-&gt;5281K(9728K), 0.0002857 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2560K)] [ParOldGen: 5281K-&gt;5263K(7168K)] 5281K-&gt;5263K(9728K), [Metaspace: 3482K-&gt;3482K(1056768K)], 0.0058564 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] Heap PSYoungGen total 2560K, used 60K [0x00000000ffd00000, 0x0000000100000000, 0x0000000100000000) eden space 2048K, 2% used [0x00000000ffd00000,0x00000000ffd0f138,0x00000000fff00000) from space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000) to space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000) ParOldGen total 7168K, used 5263K [0x00000000ff600000, 0x00000000ffd00000, 0x00000000ffd00000) object space 7168K, 73% used [0x00000000ff600000,0x00000000ffb23cf0,0x00000000ffd00000) Metaspace used 3514K, capacity 4498K, committed 4864K, reserved 1056768K class space used 388K, capacity 390K, committed 512K, reserved 1048576K Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space at java.util.Arrays.copyOfRange(Arrays.java:3664) at java.lang.String.&lt;init&gt;(String.java:207) at java.lang.StringBuilder.toString(StringBuilder.java:407) at com.atguigu.java.chapter08.GCTest.main(GCTest.java:20) 触发 OOM 的时候，一定是进行了一次 Full GC ，因为只有在老年代空间不足时候，才会爆出 OOM 异常 堆空间分代思想为什么要把 Java 堆分代？不分代就不能正常工作了吗？经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。 新生代：有 Eden 、两块大小相同的 Survivor（又称为 From/To，S0/S1）构成，To 总为空。 老年代：存放新生代中经历多次 GC 仍然存活的对象。 其实不分代完全可以，分代的唯一理由就是优化 GC 性能。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。 GC 的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当 GC 的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。 内存分配策略如果对象在 Eden 出生并经过第一次 Minor GC 后仍然存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为1。对象在 Survivor 区中每熬过一次 Minor GC ，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，其实每个 JVM 、每个 GC 都有所不同）时，就会被晋升到老年代 对象晋升老年代的年龄阀值，可以通过选项 -XX:MaxTenuringThreshold 来设置 针对不同年龄段的对象分配原则如下所示： 优先分配到 Eden 开发中比较长的字符串或者数组，会直接存在老年代，但是因为新创建的对象都是朝生夕死的，所以这个大对象可能也很快被回收，但是因为老年代触发 Major GC 的次数比 Minor GC 要更少，因此可能回收起来就会比较慢 大对象直接分配到老年代 尽量避免程序中出现过多的大对象 长期存活的对象分配到老年代 动态对象年龄判断 如果 Survivor 区中相同年龄的所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到 MaxTenuringThreshold 中要求的年龄。 空间分配担保： -XX:HandlePromotionFailure 也就是经过 Minor GC 后，所有的对象都存活，因为 Survivor 比较小，所以就需要将 Survivor 无法容纳的对象，存放到老年代中。 为对象分配内存：TLAB问题：堆空间都是共享的么？不一定，因为还有 TLAB 这个概念，在堆中划分出一块区域，为每个线程所独占 为什么有 TLAB？TLAB：Thread Local Allocation Buffer，也就是为每个线程单独分配了一个缓冲区 堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据 由于对象实例的创建在 JVM 中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的 为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。 什么是 TLAB 从内存模型而不是垃圾收集的角度，对 Eden 区域继续进行划分， JVM 为每个线程分配了一个私有缓存区域，它包含在 Eden 空间内。 多线程同时分配内存时，使用 TLAB 可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略。 据我所知所有 OpenJDK 衍生出来的 JVM 都提供了 TLAB 的设计。 说明： 尽管不是所有的对象实例都能够在 TLAB 中成功分配内存，但 JVM 确实是将 TLAB 作为内存分配的首选。 在程序中，开发人员可以通过选项“-XX:UseTLAB”设置是否开启 TLAB 空间。 默认情况下，TLAB 空间的内存非常小，仅占有整个 Eden 空间的1%，当然我们可以通过选项“-XX:TLABWasteTargetPercent”设置 TLAB 空间所占用 Eden 空间的百分比大小。 一旦对象在 TLAB 空间分配内存失败时，JVM 就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在 Eden 空间中分配内存。 TLAB分配过程对象首先是通过 TLAB 开辟空间，如果不能放入，那么需要通过 Eden 来进行分配 小结堆空间的参数设置 -XX：+PrintFlagsInitial：查看所有的参数的默认初始值 -XX：+PrintFlagsFinal：查看所有的参数的最终值（可能会存在修改，不再是初始值） -Xms：初始堆空间内存（默认为物理内存的1/64） -Xmx：最大堆空间内存（默认为物理内存的1/4） -Xmn：设置新生代的大小。（初始值及最大值） -XX:NewRatio：配置新生代与老年代在堆结构的占比 -XX:SurvivorRatio：设置新生代中Eden和S0/S1空间的比例 -XX:MaxTenuringThreshold：设置新生代垃圾的最大年龄 -XX：+PrintGCDetails：输出详细的GC处理日志 打印gc简要信息：①-Xx：+PrintGC ② - verbose:gc -XX:HandlePromotionFalilure：是否设置空间分配担保 在发生 Minor GC 之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。 如果大于，则此次 Minor GC 是安全的 如果小于，则虚拟机会查看 -XX:HandlePromotionFailure 设置值是否允担保失败。 如果 HandlePromotionFailure=true ，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小。 如果大于，则尝试进行一次 Minor GC ，但这次 Minor GC 依然是有风险的； 如果小于，则改为进行一次 Full GC 。 如果 HandlePromotionFailure=false，则改为进行一次 Full GC 。 在 JDK 6 Update24 之后，HandlePromotionFailure 参数不会再影响到虚拟机的空间分配担保策略，观察 OpenJDK 中的源码变化，虽然源码中还定义了 HandlePromotionFailure 参数，但是在代码中已经不会再使用它。 JDK6 Update24 之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行 Minor GC ，否则将进行 Full GC 。 堆是分配对象的唯一选择么？逃逸分析在《深入理解Java虚拟机》中关于 Java 堆内存有这样一段描述： 随着 JIT 编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。 在 Java 虚拟机中，对象是在 Java 堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。 此外，前面提到的基于 OpenJDK 深度定制的 TaoBao VM ，其中创新的 GCIH（GC Invisible Heap）技术实现Off-Heap，将生命周期较长的 Java 对象从 Heap 中移至 Heap 外，并且 GC 不能管理 GCIH 内部的 Java 对象，以此达到降低 GC 的回收频率和提升 GC 的回收效率的目的。 如何将堆上的对象分配到栈，需要使用逃逸分析手段。 这是一种可以有效减少 Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。 通过逃逸分析， Java HotSpot 编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。 逃逸分析的基本行为就是分析对象动态作用域： 当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。 当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。 如何快速的判断是否发生了逃逸分析，就看 new 的对象是否在方法外被调用。 逃逸分析举例没有发生逃逸的对象，则可以分配到栈上，随着方法执行的结束，栈空间就被移除，每个栈里面包含了很多栈帧，也就是发生逃逸分析 针对下面的代码 123456public static StringBuffer createStringBuffer(String s1, String s2) { StringBuffer sb = new StringBuffer(); sb.append(s1); sb.append(s2); return sb;} 如果想要 StringBuffer sb 不发生逃逸，可以这样写 123456public static String createStringBuffer(String s1, String s2) { StringBuffer sb = new StringBuffer(); sb.append(s1); sb.append(s2); return sb.toString();} 完整的逃逸分析代码举例 12345678910111213141516171819202122232425262728293031323334public class EscapeAnalysis { public EscapeAnalysis obj; /** * 方法返回EscapeAnalysis对象，发生逃逸 * @return */ public EscapeAnalysis getInstance() { return obj == null ? new EscapeAnalysis():obj; } /** * 为成员属性赋值，发生逃逸 */ public void setObj() { this.obj = new EscapeAnalysis(); } /** * 对象的作用于仅在当前方法中有效，没有发生逃逸 */ public void useEscapeAnalysis() { EscapeAnalysis e = new EscapeAnalysis(); } /** * 引用成员变量的值，发生逃逸 */ public void useEscapeAnalysis2() { EscapeAnalysis e = getInstance(); // getInstance().XXX 发生逃逸 }} 参数设置在 JDK 6u23 版本之后， HotSpot 中默认就已经开启了逃逸分析 如果使用的是较早的版本，开发人员则可以通过： 选项 “-XX：+DoEscapeAnalysis” 显式开启逃逸分析 通过选项 “-XX：+PrintEscapeAnalysis” 查看逃逸分析的筛选结果 结论开发中能使用局部变量的，就不要使用在方法外定义。 使用逃逸分析，编译器可以对代码做如下优化： 栈上分配：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配 同步省略：如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。 分离对象或标量替换：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在 CPU 寄存器中。 栈上分配 JIT 编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。 常见的栈上分配的场景： 在逃逸分析中，已经说明了。分别是给成员变量赋值、方法返回值、实例引用传递。 举例我们通过举例来说明 开启逃逸分析和未开启逃逸分析时候的情况 123456789101112131415161718192021222324class User { private String name; private String age; private String gender; private String phone;}public class StackAllocation { public static void main(String[] args) throws InterruptedException { long start = System.currentTimeMillis(); for (int i = 0; i &lt; 100000000; i++) { alloc(); } long end = System.currentTimeMillis(); System.out.println(\"花费的时间为：\" + (end - start) + \" ms\"); // 为了方便查看堆内存中对象个数，线程sleep Thread.sleep(10000000); } private static void alloc() { User user = new User(); }} 设置 JVM 参数，表示未开启逃逸分析 1-Xmx1G -Xms1G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails 运行结果，同时还触发了 GC 操作 1花费的时间为：664 ms 然后查看内存的情况，发现有大量的 User 存储在堆中 我们再开启逃逸分析 1-Xmx1G -Xms1G -XX:+DoEscapeAnalysis -XX:+PrintGCDetails 然后查看运行时间，我们能够发现花费的时间快速减少，同时不会发生 GC 操作 1花费的时间为：5 ms 然后再看内存情况，我们发现只有很少的 User 对象，说明 User 发生了逃逸，因为他们存储在栈中，随着栈的销毁而消失 同步省略线程同步的代价是相当高的，同步的后果是降低并发性和性能。 在动态编译同步块的时候， JIT 编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。如果没有，那么 JIT 编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫锁消除。 例如下面的代码 123456public void f() { Object hellis = new Object(); synchronized(hellis) { System.out.println(hellis); }} 代码中对 hellis 这个对象加锁，但是 hellis 对象的生命周期只在 f() 方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉，优化成： 1234public void f() { Object hellis = new Object(); System.out.println(hellis);} 我们将其转换成字节码 分离对象和标量替换标量（Scalar）是指一个无法再分解成更小的数据的数据。 Java 中的原始数据类型就是标量。 相对的，那些还可以分解的数据叫做聚合量（Aggregate）， Java 中的对象就是聚合量，因为他可以分解成其他聚合量和标量。 在 JIT 阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过 JIT 优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。 12345678910111213public static void main(String args[]) { alloc();}class Point { private int x; private int y;}private static void alloc() { Point point = new Point(1,2); System.out.println(\"point.x\" + point.x + \";point.y\" + point.y);} 以上代码，经过标量替换后，就会变成 12345private static void alloc() { int x = 1; int y = 2; System.out.println(\"point.x = \" + x + \"; point.y=\" + y);} 可以看到，Point 这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个聚合量了。那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。标量替换为栈上分配提供了很好的基础。 标量替换1234567891011121314151617181920212223242526public class StackAllocation { public static void main(String[] args) { long start = System.currentTimeMillis(); for (int i = 0; i &lt; 100000000; i++) { alloc(); } // 查看执行时间 long end = System.currentTimeMillis(); System.out.println(\"花费的时间为： \" + (end - start) + \" ms\"); // 为了方便查看堆内存中对象个数，线程sleep try { Thread.sleep(1000000); } catch (InterruptedException e1) { e1.printStackTrace(); } } private static void alloc() { User user = new User();//未发生逃逸 } static class User { }} 上述代码在主函数中进行了1亿次 alloc 。调用进行对象创建，由于 User 对象实例需要占据约16字节的空间，因此累计分配空间达到将近1.5GB。如果堆空间小于这个值，就必然会发生 GC 。使用如下参数运行上述代码： 1-server -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations 这里设置参数如下： 参数 -server：启动 Server 模式，因为在 Server 模式下，才可以启用逃逸分析。 参数 -XX:+DoEscapeAnalysis：启用逃逸分析 参数 -Xmx10m：指定了堆空间最大为10MB 参数 -XX:+PrintGC：将打印 GC 日志。 参数 -XX：+EliminateAllocations：开启了标量替换（默认打开），允许将对象打散分配在栈上，比如对象拥有 id 和 name 两个字段，那么这两个字段将会被视为两个独立的局部变量进行分配 逃逸分析的不足关于逃逸分析的论文在1999年就已经发表了，但直到 JDK 1.6 才有实现，而且这项技术到如今也并不是十分成熟的。 其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。 一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。 虽然这项技术并不十分成熟，但是它也是即时编译器优化技术中一个十分重要的手段。 注意到有一些观点，认为通过逃逸分析， JVM 会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于 JVM 设计者的选择。据我所知， Oracle HotSpot JVM 中并未这么做，这一点在逃逸分析相关的文档里已经说明，所以可以明确所有的对象实例都是创建在堆上。 目前很多书籍还是基于 JDK 7 以前的版本， JDK 已经发生了很大变化，intern 字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，intern 字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：对象实例都是分配在堆上。 小结 年轻代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。 老年代放置长生命周期的对象，通常都是从 Survivor 区域筛选拷贝过来的 Java 对象。当然，也有特殊情况，我们知道普通的对象会被分配在 TLAB 上；如果对象较大，JVM 会试图直接分配在 Eden 其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM 就会直接分配到老年代。 当 GC 只发生在年轻代中，回收年轻代对象的行为被称为 Minor GC 。当 GC 发生在老年代时则被称为 Major GC 或者 Full GC 。一般的，Minor GC 的发生频率要比 Major GC 高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。","link":"/2020/10/16/%E5%B0%9A%E7%A1%85%E8%B0%B7JVM/%E7%AC%AC%E5%85%AB%E7%AB%A0_%E5%A0%86/"},{"title":"尚硅谷JVM&#x2F;第五章_虚拟机栈","text":"虚拟机栈虚拟机栈概述 由于跨平台性的设计，Java 的指令都是根据栈来设计的。不同平台 CPU 架构不同，所以不能设计为基于寄存器的。优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。 有不少 Java 开发人员一提到 Java 内存结构，就会非常粗粒度地将 JVM 中的内存区理解为仅有 Java 堆（heap）和 Java 栈（stack）？为什么？ 首先栈是运行时的单位，而堆是存储的单位 栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。 堆解决的是数据存储的问题，即数据怎么放，放哪里 Java虚拟机栈是什么Java 虚拟机栈（Java Virtual Machine Stack），早期也叫 Java 栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的 Java 方法调用。 是线程私有的 生命周期生命周期和线程一致，也就是线程结束了，该虚拟机栈也销毁了 作用主管 Java 程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。 局部变量，它是相比于成员变量来说的（或属性） 基本数据类型变量 VS 引用类型变量（类、数组、接口） 栈的特点（优点）栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。JVM 直接对 Java 栈的操作只有两个： 每个方法执行，伴随着进栈（入栈、压栈） 执行结束后的出栈工作 对于栈来说不存在垃圾回收问题（栈存在溢出的情况） 开发中遇到哪些异常？栈中可能出现的异常 Java 虚拟机规范允许 Java 栈的大小是动态的或者是固定不变的。 如果采用固定大小的 Java 虚拟机栈，那每一个线程的 Java 虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过 Java 虚拟机栈允许的最大容量，Java 虚拟机将会抛出一个 StackoverflowError 异常。 如果 Java 虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那 Java 虚拟机将会抛出一个 OutOfMemoryError 异常。 123456789public static void main(String[] args) { test();}public static void test() { test();}//抛出异常：Exception in thread \"main\" java.lang.StackOverflowError//程序不断地进行递归调用，而且没有退出条件，就会导致不断地进行压栈 12345678public static int show(int a) { a++; if (a &gt; 8) return a; show(a); return a;}//Exception in thread \"main\" java.lang.StackOverflowError 1234567public class StackErrorTest { private static int count = 1; public static void main(String[] args) { System.out.println(count++); main(args); }} 设置栈内存大小我们可以使用参数 -Xss 选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度 12-Xss1m-Xss1k 1234567891011121314151617public class StackDeepTest { private static int count = 0; public static void recursion() { count++; recursion(); } public static void main(String[] args) { try { recursion(); } catch (Throwable throwable) { System.out.println(\"deep of calling = \" + count); throwable.printStackTrace(); } }} 栈的存储单位栈中存储什么？ 每个线程都有自己的栈，栈中的数据都是以栈帧（Stack Frame）的格式存在。 在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）。 栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。 OOP 的基本概念：类和对象 类中基本结构：field（属性、字段、域）、method 栈运行原理 JVM 直接对 Java 栈的操作只有两个，就是对栈帧的压栈和出栈，遵循“先进后出”/“后进先出”原则。 在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为当前栈帧（Current Frame），与当前栈帧相对应的方法就是当前方法（Current Method），定义这个方法的类就是当前类（Current Class）。 执行引擎运行的所有字节码指令只针对当前栈帧进行操作。 如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。 下面写一个简单的代码 1234567891011121314151617181920212223242526public class StackFrameTest { public static void main(String[] args) { method01(); } private static int method01() { System.out.println(\"方法1的开始\"); int i = method02(); System.out.println(\"方法1的结束\"); return i; } private static int method02() { System.out.println(\"方法2的开始\"); int i = method03(); System.out.println(\"方法2的结束\"); return i; } private static int method03() { System.out.println(\"方法3的开始\"); int i = 30; System.out.println(\"方法3的结束\"); return i; }} 输出结果为 123456方法1的开始方法2的开始方法3的开始方法3的结束方法2的结束方法1的结束 满足栈先进后出的概念，通过 Idea 的 DEBUG ，能够看到栈信息 不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。 如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。 Java 方法有两种返回函数的方式，一种是正常的函数返回，使用 return 指令；另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。 栈帧的内部结构每个栈帧中存储着： 局部变量表（Local Variables） 操作数栈（Operand Stack）（或表达式栈） 动态链接（Dynamic Linking）（或指向运行时常量池的方法引用） 方法返回地址（Return Address）（或方法正常退出或者异常退出的定义） 一些附加信息 并行每个线程下的栈都是私有的，因此每个线程都有自己各自的栈，并且每个栈里面都有很多栈帧，栈帧的大小主要由局部变量表和操作数栈决定的 局部变量表局部变量表：Local Variables，被称之为局部变量数组或本地变量表 定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量，这些数据类型包括各类基本数据类型、对象引用（reference），以及 returnAddress 类型。 由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题 局部变量表所需的容量大小是在编译期确定下来的，并保存在方法的 Code 属性的 Maximum Local Variables 数据项中。在方法运行期间是不会改变局部变量表的大小的。 方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。 局部变量表中的变量只在当前方法调用中有效。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。 关于 Slot 的理解参数值的存放总是在局部变量数组的 index0 开始，到数组长度-1的索引结束。 局部变量表，最基本的存储单元是 Slot（变量槽）局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference）、returnAddress 类型的变量。 在局部变量表里，32位以内的类型只占用一个 slot（包括 returnAddress 类型），64位的类型（long 和double）占用两个 Slot。 byte、short、char 在存储前被转换为 int，boolean 也被转换为 int，0表示 false，非0表示 true。 long 和 double 则占据两个 Slot。 JVM 会为局部变量表中的每一个 Slot 都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值 当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个 Slot 上 如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。（比如：访问 long 或double 类型变量） 如果当前帧是由构造方法或者实例方法创建的，那么该对象引用 this 将会存放在 index 为0的 Slot 处，其余的参数按照参数表顺序继续排列。 Slot 的重复利用栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。 举例：静态变量与局部变量的对比变量的分类： 按数据类型分：基本数据类型、引用数据类型 按类中声明的位置分：成员变量（类变量，实例变量）、局部变量 类变量：linking 的 prepare 阶段，给类变量默认赋值，init 阶段给类变量显示赋值即静态代码块 实例变量：随着对象创建，会在堆空间中分配实例变量空间，并进行默认赋值 局部变量：在使用前必须进行显式赋值，不然编译不通过。 参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。 我们知道类变量表有两次初始化的机会，第一次是在“准备阶段”，执行系统初始化，对类变量设置零值，另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值。 和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。 在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。 局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。 操作数栈概念操作数栈：Operand Stack 每一个独立的栈帧中除了包含局部变量表以外，还包含一个后进先出（Last - In - First -Out）的操作数栈，也可以称之为表达式栈（Expression Stack） 操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）和 出栈（pop） 某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈 比如：执行复制、交换、求和等操作 操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。 操作数栈就是 JVM 执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的。. 这个时候数组是有长度的，因为数组一旦创建，那么就是不可变的 每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code 属性中，为 max_stack 的值。 栈中的任何一个元素都是可以任意的 Java 数据类型 32bit的类型占用一个栈单位深度 64bit的类型占用两个栈单位深度 操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问 如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。 操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。| 另外，我们说 Java 虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈。 代码追踪我们给定代码 12345public void testAddOperation() { byte i = 15; int j = 8; int k = i + j;} 使用 javap 命令反编译 class 文件： javap -v 类名.class byte、short、char、boolean 内部都是使用 int 型来进行保存的 从上面的代码我们可以知道，我们都是通过 bipush 对操作数 15 和 8 进行入栈操作 同时使用的是 iadd 方法进行相加操作，i -&gt; 代表的就是 int，也就是 int 类型的加法操作 执行流程如下所示： 首先执行第一条语句，PC 寄存器指向的是0，也就是指令地址为0，然后使用 bipush 让操作数15入栈。 执行完后，让 PC + 1，指向下一行代码，下一行代码就是将操作数栈的元素存储到局部变量表1的位置，我们可以看到局部变量表的已经增加了一个元素 为什么局部变量表不是从0开始的呢？ 其实局部变量表也是从0开始的，但是因为0号位置存储的是this指针，所以说就直接省略了 然后 PC + 1，指向的是下一行。让操作数8也入栈，同时执行 istore 操作，存入局部变量表中 然后从局部变量表中，依次将数据放在操作数栈中 然后将操作数栈中的两个元素执行相加操作，并存储在局部变量表3的位置 最后 PC 寄存器的位置指向10，也就是 return 方法，则直接退出方法 i++ 和++i 的区别？ 从字节码角度来讲，i++ 和 ++i 没有区别 栈顶缓存技术栈顶缓存技术：Top Of Stack Cashing 前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（Instruction Dispatch）次数和内存读/写次数。 由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM 的设计者们提出了栈顶缓存（ToS，Top-of-Stack Cashing）技术，将栈顶元素全部缓存在物理CPU 的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。 寄存器：指令更少，执行速度快 动态链接动态链接：Dynamic Linking 动态链接、方法返回地址、附加信息 ： 有些地方被称为帧数据区 每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用，包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接（Dynamic Linking）。比如：invokedynamic 指令 在 Java 源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在 class 文件的常量池里。 比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。 为什么需要运行时常量池？ 因为在不同的方法，都可能调用常量或者方法，所以只需要存储一份即可，节省了空间 常量池的作用，就是为了提供一些符号和常量，便于指令的识别 方法调用：解析与分配在 JVM 中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关 链接静态链接当一个字节码文件被装载进 JVM 内部时，如果被调用的目标方法在编译期可知，且运行期保持不变时，这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接 动态链接如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用的方法的符号转换为直接引用，由于这种引用转换过程具备动态性，因此也被称之为动态链接。 绑定机制对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。 早期绑定早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。 晚期绑定如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定。 早晚期绑定的发展历史随着高级语言的横空出世，类似于 Java 一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性，既然这一类的编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式。 Java 中任何一个普通的方法其实都具备虚函数的特征，它们相当于 C++ 语言中的虚函数（C++ 中则需要使用关键字 virtual 来显式定义）。如果在 Java 程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字 final 来标记这个方法。 虚方法和非虚方法 如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。 静态方法、私有方法、final 方法、实例构造器、父类方法都是非虚方法。 其他方法称为虚方法。 子类对象的多态的使用前提 类的继承关系 方法的重写 虚拟机中提供了以下几条方法调用指令： 普通调用指令： invokestatic：调用静态方法，解析阶段确定唯一方法版本 invokespecial：调用 方法、私有及父类方法，解析阶段确定唯一方法版本 invokevirtual：调用所有虚方法 invokeinterface：调用接口方法 动态调用指令： invokedynamic：动态解析出需要调用的方法，然后执行 前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而 invokedynamic 指令则支持由用户确定方法版本。其中 invokestatic 指令和 invokespecial 指令调用的方法称为非虚方法，其余的（final 修饰的除外）称为虚方法。 invokednamic 指令JVM 字节码指令集一直比较稳定，一直到 Java 7 中才增加了一个 invokedynamic 指令，这是 Java 为了实现动态类型语言支持而做的一种改进。 但是在 Java 7 中并没有提供直接生成 invokedynamic 指令的方法，需要借助 ASM 这种底层字节码工具来产生invokedynamic 指令。直到 Java 8 的 Lambda 表达式的出现，invokedynamic 指令的生成，在 Java 中才有了直接的生成方式。 Java 7 中增加的动态语言类型支持的本质是对 Java 虚拟机规范的修改，而不是对 Java 语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在 Java 平台的动态语言的编译器。 动态类型语言和静态类型语言动态类型语言和静态类型语言两者的区别就在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之是动态类型语言。 说的再直白一点就是，静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征。 Java：String info = “atiguigu”; (Java 是静态类型语言的，会先编译就进行类型检查) JS：var name = “shkstart”; var name = 10; （运行时才进行检查） 方法重写的本质Java 语言中方法重写的本质： 找到操作数栈顶的第一个元素所执行的对象的实际类型，记作 C。 如果在类型 C 中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回 java.lang.illegalAccessError 异常。 否则，按照继承关系从下往上依次对 C 的各个父类进行第2步的搜索和验证过程。 如果始终没有找到合适的方法，则抛出 java.lang.AbstractMethodserror 异常。 IllegalAccessError介绍程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。 方法的调用：虚方法表在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，JVM 采用在类的方法区建立一个虚方法表（Virtual Method Table）（非虚方法不会出现在表中）来实现。使用索引表来代替查找。 每个类中都有一个虚方法表，表中存放着各个方法的实际入口。 虚方法表是什么时候被创建的呢？ 虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM 会把该类的方法表也初始化完毕。 如上图所示：如果类中重写了方法，那么调用的时候，就会直接在虚方法表中查找，否则将会直接连接到 Object的方法中。 方法返回地址存放调用该方法的 PC 寄存器的值。一个方法的结束，有两种方式： 正常执行完成 出现未处理的异常，非正常退出 无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的 PC 计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。 本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置 PC 寄存器值等，让调用者方法继续执行下去。 正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。 当一个方法开始执行后，只有两种方式可以退出这个方法： 执行引擎遇到任意一个方法返回的字节码指令（return），会将返回值传递给上层的方法调用者，简称正常完成出口； 一个方法在正常调用完成之后，究竟需要使用哪一个返回指令，还需要根据方法返回值的实际数据类型而定。 在字节码指令中，返回指令包含 ireturn（当返回值是 boolean，byte，char，short 和 int 类型时使用），lreturn（Long类型），freturn（Float类型），dreturn（Double类型），areturn（引用类型）。另外还有一个 return 指令声明为 void 的方法，实例初始化方法，类和接口的初始化方法使用。 在方法执行过程中遇到异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，简称异常完成出口。 方法执行过程中抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码 一些附加信息 栈帧中还允许携带与 Java 虚拟机实现相关的一些附加信息。例如：对程序调试提供支持的信息。 栈的相关面试题 举例栈溢出的情况？（StackOverflowError） 通过 -Xss 设置栈的大小 调整栈大小，就能保证不出现溢出么？ 不能保证不溢出 分配的栈内存越大越好么？ 不是，一定时间内降低了 OOM 概率，但是会挤占其它的线程空间，因为整个空间是有限的。 垃圾回收是否涉及到虚拟机栈？ 不会 方法中定义的局部变量是否线程安全？ 具体问题具体分析 总结一句话就是：如果对象是在内部产生，并在内部消亡，没有返回到外部，那么它就是线程安全的，反之则是线程不安全的。 运行时数据区，是否存在 Error 和 GC ？ 运行时数据区 是否存在Error 是否存在GC 程序计数器 否 否 虚拟机栈 是 否 本地方法栈 是 否 方法区 是（OOM） 是 堆 是 是","link":"/2020/10/16/%E5%B0%9A%E7%A1%85%E8%B0%B7JVM/%E7%AC%AC%E4%BA%94%E7%AB%A0_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/"},{"title":"尚硅谷JVM&#x2F;第十三章_StringTable","text":"StringTableString的基本特性 String：字符串，使用一对 “” 引起来表示 String s1 = “mogublog” ; // 字面量的定义方式 String s2 = new String(“moxi”); String 声明为 final 的，不可被继承 String 实现了 Serializable 接口：表示字符串是支持序列化的。实现了 Comparable 接口：表示 String 可以比较大小 String 在 JDK 8 及以前内部定义了 final char[] value 用于存储字符串数据。JDK 9 时改为 byte[] 为什么 JDK 9 改变了结构String 类的当前实现将字符存储在 char 数组中，每个字符使用两个字节(16位)。从许多不同的应用程序收集的数据表明，字符串是堆使用的主要组成部分，而且，大多数字符串对象只包含拉丁字符。这些字符只需要一个字节的存储空间，因此这些字符串对象的内部 char 数组中有一半的空间将不会使用。 Motivation The current implementation of the String class stores characters in a char array, using two bytes (sixteen bits) for each character. Data gathered from many different applications indicates that strings are a major component of heap usage and, moreover, that most String objects contain only Lation-1 character. Such characters require only one byte of storage, hence half of the space in the internal char arrays of such String objects is going unused. Description We propose to change the internal representation of the String class from a UTF-16 char array to a byte array plus an encoding-flag field. The new String class will store characters encoded either as ISO-8859-1/Latin-1 (one byte per character), or as UTF-16(two bytes per character), based upon the contents of the string. The encoding flag will indicate which encoding is used. 我们建议改变字符串的内部表示 Class 从 UTF-16 字符数组到字节数组+一个 encoding-flag 字段。新的 String 类将根据字符串的内容存储编码为 ISO-8859-1/Latin-1(每个字符一个字节)或 UTF-16 (每个字符两个字节)的字符。编码标志将指示使用哪种编码。 结论：String 再也不用 char[] 来存储了，改成了 byte [] 加上编码标记，节约了一些空间 1234// 之前private final char value[];// 之后private final byte[] value 同时基于 String 的数据结构，例如 StringBuffer 和 StringBuilder 也同样做了修改 String的不可变性String：代表不可变的字符序列。简称：不可变性。 当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的 value 进行赋值。 当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的 value 进行赋值。 当调用 String 的 replace() 方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的 value 进行赋值。 通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。 代码 12345678910111213141516171819202122232425262728293031323334353637public class StringTest1 { public static void test1() { // 字面量定义的方式，“abc”存储在字符串常量池中 String s1 = \"abc\"; String s2 = \"abc\"; System.out.println(s1 == s2); s1 = \"hello\"; System.out.println(s1 == s2); System.out.println(s1); System.out.println(s2); System.out.println(\"----------------\"); } public static void test2() { String s1 = \"abc\"; String s2 = \"abc\"; // 只要进行了修改，就会重新创建一个对象，这就是不可变性 s2 += \"def\"; System.out.println(s1); System.out.println(s2); System.out.println(\"----------------\"); } public static void test3() { String s1 = \"abc\"; String s2 = s1.replace('a', 'm'); System.out.println(s1); System.out.println(s2); } public static void main(String[] args) { test1(); test2(); test3(); }} 运行结果 12345678910truefalsehelloabc----------------abcabcdef----------------abcmbc 面试题12345678910111213141516public class StringExer { String str = new String(\"good\"); char [] ch = {'t','e','s','t'}; public void change(String str, char ch []) { str = \"test ok\"; ch[0] = 'b'; } public static void main(String[] args) { StringExer ex = new StringExer(); ex.change(ex.str, ex.ch); System.out.println(ex.str); System.out.println(ex.ch); }} 输出结果 12goodbest 注意字符串常量池是不会存储相同内容的字符串的 String 的 String Pool 是一个固定大小的 Hashtable ，默认值大小长度是1009。如果放进 String Pool 的 String 非常多，就会造成 Hash 冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用 String.intern 时性能会大幅下降。 使用 -XX:StringTablesize 可设置 StringTable 的长度 在 JDK 6 中 StringTable 是固定的，就是 1009 的长度，所以如果常量池中的字符串过多就会导致效率下降很快。StringTablesize 设置没有要求 在 JDK 7 中，StringTable 的长度默认值是 60013 ，StringTablesize 设置没有要求 在 JDK 8 中，StringTable 可以设置的最小值为 1009 String的内存分配在 Java 语言中有8种基本数据类型和一种比较特殊的类型 String 。这些类型为了使它们在运行过程中速度更快、更节省内存，都提供了一种常量池的概念。 常量池就类似一个 Java 系统级别提供的缓存。8种基本数据类型的常量池都是系统协调的，String 类型的常量池比较特殊。它的主要使用方法有两种。 直接使用双引号声明出来的 String 对象会直接存储在常量池中。 比如：String info = “atguigu.com”； 如果不是用双引号声明的 String 对象，可以使用 String 提供的 intern() 方法。 Java 6 及以前，字符串常量池存放在永久代 Java 7 中 Oracle 的工程师对字符串池的逻辑做了很大的改变，即将字符串常量池的位置调整到 Java 堆内 所有的字符串都保存在堆（Heap）中，和其他普通对象一样，这样可以让你在进行调优应用时仅需要调整堆大小就可以了。 字符串常量池概念原本使用得比较多，但是这个改动使得我们有足够的理由让我们重新考虑在 Java 7 中使用 String.intern()。 Java 8 元空间，字符串常量在堆 为什么 StringTable 从永久代调整到堆中在 JDK 7 中，interned 字符串不再在 Java 堆的永久代中分配，而是在 Java 堆的主要部分(称为年轻代和年老代)中分配，与应用程序创建的其他对象一起分配。此更改将导致驻留在主 Java 堆中的数据更多，驻留在永久生成中的数据更少，因此可能需要调整堆大小。由于这一变化，大多数应用程序在堆使用方面只会看到相对较小的差异，但加载许多类或大量使用字符串的较大应用程序会出现这种差异。intern() 方法会看到更显著的差异。 永久代的默认比较小 永久代垃圾回收频率低 String 的基本操作Java 语言规范里要求完全相同的字符串字面量，应该包含同样的 Unicode 字符序列（包含同一份码点序列的常量），并且必须是指向同一个 String 类实例。 12345678910111213class Memory { public static void main(String[] args) { int i = 1; Object obj = new Object(); Memory mem = new Memory(); mem.foo(obj); } private void foo(Object param) { String str = param.toString(); System.out.println(str); }} 字符串拼接操作 常量与常量的拼接结果在常量池，原理是编译期优化 常量池中不会存在相同内容的变量 只要其中有一个是变量，结果就在堆中。变量拼接的原理是 StringBuilder 如果拼接的结果调用 intern() 方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象地址 123456789101112131415161718192021222324252627282930public static void test1() { String s1 = \"a\" + \"b\" + \"c\"; // 得到 abc的常量池 String s2 = \"abc\"; // abc存放在常量池，直接将常量池的地址返回 /** * 最终java编译成.class，再执行.class */ System.out.println(s1 == s2); // true，因为存放在字符串常量池 System.out.println(s1.equals(s2)); // true}public static void test2() { String s1 = \"javaEE\"; String s2 = \"hadoop\"; String s3 = \"javaEEhadoop\"; String s4 = \"javaEE\" + \"hadoop\"; String s5 = s1 + \"hadoop\"; String s6 = \"javaEE\" + s2; String s7 = s1 + s2; System.out.println(s3 == s4); // true System.out.println(s3 == s5); // false System.out.println(s3 == s6); // false System.out.println(s3 == s7); // false System.out.println(s5 == s6); // false System.out.println(s5 == s7); // false System.out.println(s6 == s7); // false String s8 = s6.intern(); System.out.println(s3 == s8); // true} 从上述的结果我们可以知道： 如果拼接符号的前后出现了变量，则相当于在堆空间中 new String() ，具体的内容为拼接的结果 而调用 intern() 方法，则会判断字符串常量池中是否存在 “javaEEhadoop” 值，如果存在则返回常量池中的值，否者就在常量池中创建 底层原理拼接操作的底层其实使用了 StringBuilder s1 + s2 的执行细节 StringBuilder s = new StringBuilder(); s.append(s1); s.append(s2); s.toString(); -&gt; 类似于new String(“ab”); 在 JDK 5 之后，使用的是 StringBuilder，在 JDK 5 之前使用的是 StringBuffer String StringBuffer StringBuilder String 的值是不可变的，这就导致每次对 String 的操作都会生成新的 String 对象，不仅效率低下，而且浪费大量优先的内存空间 StringBuffer 是可变类，和线程安全的字符串操作类，任何对它指向的字符串的操作都不会产生新的对象。每个 StringBuffer 对象都有一定的缓冲区容量，当字符串大小没有超过容量时，不会分配新的容量，当字符串大小超过容量时，会自动增加容量 可变类，速度更快 不可变 可变 可变 线程安全 线程不安全 多线程操作字符串 单线程操作字符串 注意，我们左右两边如果是变量的话，就是需要 new StringBuilder 进行拼接，但是如果使用的是 final 修饰，则是从常量池中获取。所以说拼接符号左右两边都是字符串常量或常量引用 则仍然使用编译器优化。也就是说被 final 修饰的变量，将会变成常量，类和方法将不能被继承 在开发中，能够使用 final 的时候，建议使用上 1234567public static void test4() { final String s1 = \"a\"; final String s2 = \"b\"; String s3 = \"ab\"; String s4 = s1 + s2; System.out.println(s3 == s4);} 运行结果 1true 拼接操作和 append 性能对比12345678910111213public static void method1(int highLevel) { String src = \"\"; for (int i = 0; i &lt; highLevel; i++) { src += \"a\"; // 每次循环都会创建一个StringBuilder对象 }}public static void method2(int highLevel) { StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; highLevel; i++) { sb.append(\"a\"); }} 方法1耗费的时间：4005ms，方法2消耗时间：7ms 结论： 通过 StringBuilder 的 append() 方式添加字符串的效率，要远远高于 String 的字符串拼接方法 好处 StringBuilder 的 append 的方式，自始至终只创建一个 StringBuilder 的对象 对于字符串拼接的方式，还需要创建很多 StringBuilder 对象和调用 toString 时候创建的String 对象 内存中由于创建了较多的 StringBuilder 和 String 对象，内存占用过大，如果进行 GC 那么将会耗费更多的时间 改进的空间 我们使用的是 StringBuilder 的空参构造器，默认的字符串容量是16，然后将原来的字符串拷贝到新的字符串中， 我们也可以默认初始化更大的长度，减少扩容的次数 因此在实际开发中，我们能够确定，前前后后需要添加的字符串不高于某个限定值，那么建议使用构造器创建一个阈值的长度 intern() 的使用intern() 是一个 native 方法，调用的是底层 C 的方法 字符串池最初是空的，由 String 类私有地维护。在调用 intern() 方法时，如果池中已经包含了由 equals(object) 方法确定的与该字符串对象相等的字符串，则返回池中的字符串。否则，该字符串对象将被添加到池中，并返回对该字符串对象的引用。 如果不是用双引号声明的 String 对象，可以使用 String 提供的 intern() 方法：intern() 方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中。 比如： 1String myInfo = new string(&quot;I love atguigu&quot;).intern(); 也就是说，如果在任意字符串上调用 String.intern() 方法，那么其返回结果所指向的那个类实例，必须和直接以常量形式出现的字符串实例完全相同。因此，下列表达式的值必定是 true 1（\"a\"+\"b\"+\"c\"）.intern（）==\"abc\" 通俗点讲，Interned String 就是确保字符串在内存里只有一份拷贝，这样可以节约内存空间，加快字符串操作任务的执行速度。注意，这个值会被存放在字符串内部池（String Intern Pool） 1234567891011121314151617181920212223242526/** * 如何保证变量s指向的是字符串常量池中的数据呢？ * 有两种方式： * 方式一： String s = \"shkstart\";//字面量定义的方式 * 方式二： 调用intern() * String s = new String(\"shkstart\").intern(); * String s = new StringBuilder(\"shkstart\").toString().intern(); * */public class StringIntern { public static void main(String[] args) { String s = new String(\"1\"); s.intern();//调用此方法之前，字符串常量池中已经存在了\"1\" String s2 = \"1\"; System.out.println(s == s2);//jdk6：false jdk7/8：false String s3 = new String(\"1\") + new String(\"1\");//s3变量记录的地址为：new String(\"11\") //执行完上一行代码以后，字符串常量池中，是否存在\"11\"呢？答案：不存在！！ s3.intern();//在字符串常量池中生成\"11\"。如何理解：jdk6:创建了一个新的对象\"11\",也就有新的地址。 // jdk7:此时常量中并没有创建\"11\",而是创建一个指向堆空间中new String(\"11\")的地址 String s4 = \"11\";//s4变量记录的地址：使用的是上一行代码代码执行时，在常量池中生成的\"11\"的地址 System.out.println(s3 == s4);//jdk6：false jdk7/8：true }} intern() 的空间效率测试我们通过测试一下，使用了 intern 和不使用的时候，其实相差还挺多的 1234567891011121314151617181920public class StringIntern2 { static final int MAX_COUNT = 1000 * 10000; static final String[] arr = new String[MAX_COUNT]; public static void main(String[] args) { Integer [] data = new Integer[]{1,2,3,4,5,6,7,8,9,10}; long start = System.currentTimeMillis(); for (int i = 0; i &lt; MAX_COUNT; i++) { arr[i] = new String(String.valueOf(data[i%data.length])).intern(); } long end = System.currentTimeMillis(); System.out.println(\"花费的时间为：\" + (end - start)); try { Thread.sleep(1000000); } catch (Exception e) { e.getStackTrace(); } }} 结论：对于程序中大量使用存在的字符串时，尤其存在很多已经重复的字符串时，使用 intern() 方法能够节省内存空间。 大的网站平台，需要内存中存储大量的字符串。比如社交网站，很多人都存储：北京市、海淀区等信息。这时候如果字符串都调用 intern() 方法，就会很明显降低内存的大小。 面试题new String(“ab”)会创建几个对象123456789/** * new String(\"ab\") 会创建几个对象？ 看字节码就知道是2个对象 * */public class StringNewTest { public static void main(String[] args) { String str = new String(\"ab\"); }} 我们转换成字节码来查看 123456 0 new #2 &lt;java/lang/String&gt; 3 dup 4 ldc #3 &lt;ab&gt; 6 invokespecial #4 &lt;java/lang/String.&lt;init&gt;&gt; 9 astore_110 return 这里面就是两个对象 一个对象是：new 关键字在堆空间中创建 另一个对象：字符串常量池中的对象 new String(“a”) + new String(“b”) 会创建几个对象123456789/** * new String(\"ab\") 会创建几个对象？ * */public class StringNewTest { public static void main(String[] args) { String str = new String(\"a\") + new String(\"b\"); }} 字节码文件为 12345678910111213141516 0 new #2 &lt;java/lang/StringBuilder&gt; 3 dup 4 invokespecial #3 &lt;java/lang/StringBuilder.&lt;init&gt;&gt; 7 new #4 &lt;java/lang/String&gt;10 dup11 ldc #5 &lt;a&gt;13 invokespecial #6 &lt;java/lang/String.&lt;init&gt;&gt;16 invokevirtual #7 &lt;java/lang/StringBuilder.append&gt;19 new #4 &lt;java/lang/String&gt;22 dup23 ldc #8 &lt;b&gt;25 invokespecial #6 &lt;java/lang/String.&lt;init&gt;&gt;28 invokevirtual #7 &lt;java/lang/StringBuilder.append&gt;31 invokevirtual #9 &lt;java/lang/StringBuilder.toString&gt;34 astore_135 return 我们创建了6个对象 对象1：new StringBuilder() 对象2：new String(“a”) 对象3：常量池的 a 对象4：new String(“b”) 对象5：常量池的 b 对象6：toString 中会创建一个 new String(“ab”) 调用 toString 方法，不会在常量池中生成 ab intern() 的使用：JDK 6 和 JDK 7JDK 6 中123456789String s = new String(\"1\"); // 在常量池中已经有了s.intern(); // 将该对象放入到常量池。但是调用此方法没有太多的区别，因为已经存在了1String s2 = \"1\";System.out.println(s == s2); // falseString s3 = new String(\"1\") + new String(\"1\");s3.intern();String s4 = \"11\";System.out.println(s3 == s4); // true 输出结果 12falsetrue 为什么对象会不一样呢？ 一个是 new 创建的对象，一个是常量池中的对象，显然不是同一个 如果是下面这样的，那么就是 true 1234String s = new String(\"1\");s = s.intern();String s2 = \"1\";System.out.println(s == s2); // true 而对于下面的来说，因为 s3 变量记录的地址是 new String(“11”)，然后这段代码执行完以后，常量池中不存在 “11”，这是 JDK 6 的关系，然后执行 s3.intern() 后，就会在常量池中生成 “11”，最后 s4 用的就是 s3 的地址 为什么最后输出的 s3 == s4 会为 false 呢？ 这是因为在 JDK 6 中创建了一个新的对象 “11”，也就是有了新的地址， s2 = 新地址 而在 JDK 7 中，在 JDK 7 中，并没有创新一个新对象，而是指向常量池中的新对象 JDK 7 中123456789String s = new String(\"1\");s.intern();String s2 = \"1\";System.out.println(s == s2); // trueString s3 = new String(\"1\") + new String(\"1\");s3.intern();String s4 = \"11\";System.out.println(s3 == s4); // true 扩展1234String s3 = new String(\"1\") + new String(\"1\");String s4 = \"11\"; // 在常量池中生成的字符串s3.intern(); // 然后s3就会从常量池中找，发现有了，就什么事情都不做System.out.println(s3 == s4); 我们将 s4 的位置向上移动一行，发现变化就会很大，最后得到的是 false 总结总结 String 的 intern() 的使用： JDK 1.6 中，将这个字符串对象尝试放入串池。 如果串池中有，则并不会放入。返回已有的串池中的对象的地址 如果没有，会把此对象复制一份，放入串池，并返回串池中的对象地址 JDK 1.7 起，将这个字符串对象尝试放入串池。 如果串池中有，则并不会放入。返回已有的串池中的对象的地址 如果没有，则会把对象的引用地址复制一份，放入串池，并返回串池中的引用地址 练习： 在 JDK 6 中，在字符串常量池中创建一个字符串 “ab” 在 JDK 8 中，在字符串常量池中没有创建 “ab”，而是将堆中的地址复制到串池中。 所以上述结果，在 JDK 6 中是： 12truefalse 在 JDK 8 中是 12truetrue 针对下面这题，在 JDK 6 和 JDK 8 中表现的是一样的 StringTable的垃圾回收1234567891011/** * String的垃圾回收 * -Xms15m -Xmx15m -XX:+PrintStringTableStatistics -XX:+PrintGCDetails */public class StringGCTest { public static void main(String[] args) { for (int i = 0; i &lt; 100000; i++) { String.valueOf(i).intern(); } }} G1 中的 String 去重操作注意这里说的重复，指的是在堆中的数据，而不是常量池中的，因为常量池中的本身就不会重复 描述背景：对许多 Java 应用（有大的也有小的）做的测试得出以下结果： 堆存活数据集合里面 String 对象占了25% 堆存活数据集合里面重复的 String 对象有13.5% String 对象的平均长度是45 许多大规模的 Java 应用的瓶颈在于内存，测试表明，在这些类型的应用里面，Java 堆中存活的数据集合差不多25%是 String 对象。更进一步，这里面差不多一半 String 对象是重复的，重复的意思是说：string1.equals(string2) = true。堆上存在重复的 String 对象必然是一种内存的浪费。这个项目将在 G1 垃圾收集器中实现自动持续对重复的 String 对象进行去重，这样就能避免浪费内存。 实现 当垃圾收集器工作的时候，会访问堆上存活的对象。对每一个访问的对象都会检查是否是候选的要去重的 String 对象。 如果是，把这个对象的一个引用插入到队列中等待后续的处理。一个去重的线程在后台运行，处理这个队列。处理队列的一个元素意味着从队列删除这个元素，然后尝试去重它引用的 String 对象。 使用一个 Hashtable 来记录所有的被 String 对象使用的不重复的 char 数组。当去重的时候，会查这个 Hashtable ，来看堆上是否已经存在一个一模一样的 char 数组。 如果存在，String 对象会被调整引用那个数组，释放对原来的数组的引用，最终会被垃圾收集器回收掉。 如果查找失败，char 数组会被插入到 Hashtable，这样以后的时候就可以共享这个数组了。 命令行选项 UsestringDeduplication（bool）：开启 String 去重，默认是不开启的，需要手动开启 PrintStringDeduplicationStatistics（bool）：打印详细的去重统计信息 StringDeduplicationAgeThreshold（uintx）：达到这个年龄的 String 对象被认为是去重的候选对象","link":"/2020/10/25/%E5%B0%9A%E7%A1%85%E8%B0%B7JVM/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0_StringTable/"},{"title":"尚硅谷JVM&#x2F;第十九章_字节码指令集与解析举例","text":"字节码指令集与解析举例概述 Java 字节码对于虚拟机，就好像汇编语言对于计算机，属于基本执行命令 Java 虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字(称为操作码，Opcode)以及跟随其后的零至多个代表此操作所需参数(称为操作数，Operands)而构成，由于 Java 虚拟机采用面向操作数栈而不是寄存器的结构，所以大多数的指令都不包含操作数，只有一个操作码 由于限制了 Java 虚拟机操作码的长度为一个字节(即0~255)，这意味着指令集的操作码总数不可能超过256条 官方文档：https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html 熟悉虚拟机的指令对于动态字节码生成、反编译 Class 文件、 Class 文件修补都有着非常重要的价值。因此，阅读字节码作为了解 Java 虚拟机的基础技能，需要熟练掌握常见指令 执行模型如果不考虑异常处理的话，那么 Java 虚拟机的解释器可以使用下面这个伪代码当做最基本的执行模型来理解 123456do { 自动计算PC寄存器的值加1; 根据PC寄存器的指示位置，从字节码流中取出操作码; if(字节码存在操作数) 从字节码流中取出操作数; 执行操作码所定义的操作;}while(字节码长度&gt;0) 字节码与数据类型在 Java 虚拟机的指令集中，大多数的指令都包含了其操作所对应的数据类型信息。例如，iload 指令用于从局部变量表中加载 int 类型的数据到操作数栈中，而 fload 指令加载的则是 float 类型的数据 对于大部分与数据类型相关的字节码指令，它们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务： i 代表对 int 类型的数据操作 l 代表 long s 代表 short b 代表 byte c 代表 char f 代表 float d 代表 double 也有一些指令的助记符中没有明确地指明操作类型的字母，如 arraylength 指令，它没有代表数据类型的特殊字符，但操作数永远只能是一个数组类型的对象 还有另一些指令，如无条件跳转指令 goto 则是与数据类型无关的 大部分的指令都没有支持整数类型 byte、char 和 short，甚至没有任何指令支持 boolean 类型。编译器会在编译器或运行期将 byte 和short 类型的数据带符号扩展(Sign-Extend)为相应的 int 类型数据，将 boolean 和 char 类型数据零位扩展(Zero-Extend)为相应的 int 类型数据。与之类似，在处理 boolean、byte、short 和 char 类型的数组时，也会转换为使用对应的 init 类型的字节码指令来处理。因此，大多数对于 boolean、byte、short 和 char 类型数据的操作，实际上都是使用相应的 int 类型作为运算类型 指令分类由于完全介绍和学习这些指令需要花费大量时间，为了让大家能够更快地熟悉和了解这些基本指令，这里将 JVM 中的字节码指令集按用途大致分成9类： 加载与存储指令 算术指令 类型转换指令 对象的创建与访问指令 方法调用与返回指令 操作数栈管理指令 比较控制指令 异常处理指令 同步控制指令 在做值相关操作时： 一个指令，可以从局部变量表、常量池、堆中对象、方法调用、系统调用等中取得数据，这些数据(可能是值，可能是对象的引用)被压入操作数栈 一个指令，也可以从操作数栈中取出一到多个值(pop 多次)，完成赋值、加减乘除、方法传参、系统调用等操作 加载与存储指令 作用 加载和存储指令用于将数据从栈帧的局部变量表和操作数栈之间来回传递 常用指令 「局部变量压栈指令」将一个局部变量加载到操作数栈：xload、xload_&lt;n&gt;(其中 x 为 i、l、f、d、a，n 为 0 到 3)；xaload、xaload&lt;n&gt;(其 x 为 i、l、f、d、a、b、c、s，n 为 0 到 3) 「常量入栈指令」将一个常量加载到操作数栈：bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、iconst_m1、iconst_&lt;i&gt;、iconst_&lt;l&gt;、fconst_&lt;f&gt;、dconst_&lt;d&gt; 「出栈装入局部变量表指令」将一个数值从操作数栈存储到局部变量表：xstore、xstore_&lt;n&gt;(其中 x 为 i、l、f、d、a，n 为 0 到 3); xastore(其中 x 为 i、l、f、d、a、b、c、s) 扩充局部变量表的访问索引的指令：wide 上面所列举的指令助记符中，有一部分是以尖括号结尾的(例如iload_&lt;n&gt;)。这些指令助记符实际上代表了一组指令(例如iload_&lt;n&gt;代表了iload_0、iload_1、iload_2和iload_3这几个指令)。这几组指令都是某个带有一个操作数的通用指令(例如 iload)的特殊形式，对于这若干组特殊指令来说，它们表面上没有操作数，不需要进行取操作数的动作，但操作数都隐含在指令中 除此之外，它们的语义与原生的通用指令完全一致(例如 iload_0的语义与操作数为0时的iload指令语义完全一致)。在尖括号之间的字母指定了指令隐含操作数的数据类型，&lt;n&gt;代表非负的整数，&lt;i&gt;代表是 int 类型数据，&lt;l&gt;代表 long 类型，&lt;f&gt;代表 float 类型，&lt;d&gt;代表 double 类型 操作 byte、char、short 和 boolean 类型数据时，经常用 int 类型的指令来表示 复习：再谈操作数栈与局部变量表 操作数栈(Operand Stacks) 我们知道，Java 字节码是 Java 虚拟机所使用的指令集。因此，它与 Java 虚拟机基于栈的计算模型是密不可分的 在解释执行过程中，每当为 Java 方法分配栈帧时，Java 虚拟机往往需要开辟一块额外的空间作为操作数栈，来存放计算的操作数以及返回结果 具体来说便是：执行每一条指令之前，Java 虚拟机要求该指令的操作数已被压入操作数栈中。在执行指令时，Java 虚拟机会将该指令所需的操作数弹出，并且将指令的结果重新压入栈中 以加法指令 iadd 为例。假设在执行该指令之前，栈顶的两个元素分别为 int 值 1 和 int 值 2，那么 iadd 指令将弹出这两个 int，并将求得的和 int 值为 3 压入栈中 由于 iadd 指令只消耗栈顶的两个元素，因此，对于离栈顶距离为 2 的元素，即图中的问号，iadd 指令并不关心它是否存在，更加不会对其进行修改 局部变量表(Local Variables) Java 方法栈帧的另外一个重要组成部分则是局部变量区，字节码程序可以将计算的结果缓存在局部变量区之中 实际上，Java 虚拟机将局部变量区当成一个数组，依次存放 this 指针(仅非静态方法)，所传入的参数，以及字节码中的局部变量。 和操作数栈一样，long 类型以及 double 类型的值将占据两个单元，其余类型仅占据一个单元 举例： 12345678public void foo(long l, float f) { { int i = 0; } { String s = \"Hello, World\" }} 在栈帧中，与性能调优关系最为密切的部分就是局部变量表。局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收 在方法执行时，虚拟机使用局部变量表完成方法的传递 局部变量压栈指令局部变量压栈指令将给定的局部变量表中的数据压入操作数栈 这类指令大体可以分为： xload_&lt;n&gt;(x为i、l、f、d、a，n为 0 到 3) xload(x为i、l、f、d、a) 说明：在这里，x的取值表示数据类型 指令xload_n表示将第n个局部变量压入操作数栈，比如iload_1、fload_0、aload_0等指令。其中aload_n表示将一个对象引用压栈 指令xload通过指定参数的形式，把局部变量压入操作数栈，当使用这个命令时，表示局部变量的数量可能超过了4个，比如指令iload、fload等 常量入栈指令常量入栈指令的功能是将常数压入操作数栈，根据数据类型和入栈内容的不同，又可以分为 const 系列、push 系列和 ldc 指令 指令 const 系列：用于对特定的常量入栈，入栈的常量隐含在指令本身里。指令有：iconst_&lt;i&gt;(i从-1到5)、lconst_&lt;l&gt;(l从0到1)、fconst_&lt;f&gt;(f从0到2)、dconst_&lt;d&gt;(d从0到1)、aconst_null 比如： iconst_m1将-1压入操作数栈 iconst_x(x为0到5)将 x 压入栈 lconst_0、lconst_1 分别将长整数0和1压入栈 fconst_0、fconst_1、fconst_2 分别将浮点数0、1、2压入栈 dconst_0 和 dconst_1 分别将 double 型0和1压入栈 aconst_null 将 null 压入操作数栈 从指令的命名上不难找出规律，指令助记符的第一个字符总是喜欢表示数据类型，i 表示整数，l 表示长整型，f 表示浮点数，d 表示双精度浮点，习惯上用 a 表示对象引用。如果指令隐含操作的参数，会以下划线形式给出 指令 push 系列：主要包括 bipush 和 sipush，它们的区别在于接受数据类型的不同，bipush 接收8位整数作为参数，sipush 接收16位整数，它们都将参数压入栈 指令 ldc 系列：如果以上指令都不能满足需求，那么可以使用万能的 ldc 指令，它可以接收一个8位的参数，该参数指向常量池中的 int、float 或者 String 的索引，将指定的内容压入堆栈 类似的还有 ldc_w，它接收两个8位参数，能支持的索引范围大于 ldc 如果要压入的元素是 long 或者 double 类型的，则使用 ldc2_w 指令，使用方式都是类似的 总结如下： 出栈装入局部变量表指令出栈装入局部变量表指令用于将操作数栈中栈顶元素弹出后，装入局部变量表的指定位置，用于给局部变量赋值 这类指令主要以 store 的形式存在，比如 xstore (x 为 i、l、f、d、a)、xstore_n(x 为 i、l、f、d、a，n 为0至3)和 pasture(x 为 i、l、f、d、a、b、c、s) 其中，指令 istore_n 将从操作数栈中弹出一个整数，并把它赋值给局部变量 n 指令 xstore 由于没有隐含参数信息，故需要提供一个 byte 类型的参数类指定目标局部变量表的位置 xastore 则专门针对数组操作，以 iastore 为例，它用于给一个 int 数组的给定索引赋值。在 iastore 执行前，操作数栈顶需要以此准备3个元素：值、索引、数组引用，iastore 会弹出这3个值，并将值赋给数组中指定索引的位置 一般说来，类似像 store 这样的命令需要带一个参数，用来指明将弹出的元素放在局部变量表的第几个位置。但是，为了尽可能压缩指令大小，使用专门的 istore_1 指令表示将弹出的元素放置在局部变量表第1个位置。类似的还有 istore_0、istore_2、istore_3，它们分别表示从操作数栈顶弹出一个元素，存放在局部变量表第0、2、3个位置 由于局部变量表前几个位置总是非常常用，因此这种做法虽然增加了指令数量，但是可以大大压缩生成的字节码的体积。如果局部变量表很大，需要存储的槽位大于3，那么可以使用 istore 指令，外加一个参数，用来表示需要存放的槽位位置 算术指令 作用 算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新压入操作数栈 分类 大体上算术指令可以分为两种：对整型数据进行运算的指令与对浮点型类型数据进行运算的指令 byte、short、char 和 boolean 类型说明 在每一大类中，都有针对 Java 虚拟机具体数据类型的专用算术指令。但没有直接支持 byte、short、char 和 boolean 类型的算术指令，对于这些数据的运算，都使用 int 类型的指令来处理。此外，在处理 boolean、byte、short 和 char 类型的数组时，也会转换为使用对应的 int 类型的字节码指令来处理 运算时的溢出 数据运算可能会导致溢出，例如两个很大的正整数相加，结果可能是一个负数。其实 Java 虚拟机规范并无明确规定过整型数据溢出的具体结果，仅规定了在处理整型数据时，只有除法指令以及求余指令中当出现除数为0时会导致虚拟机抛出异常 ArithmeticException 运算模式 向最接近数舍入模式：JVM 要求在进行浮点数计算时，所有的运算结果都必须舍入到适当的精度，非精确结果必须舍入为可被表示的最接近的精确值，如果有两种可表示的形式与该值一样接近，将优先选择最低有效位为零的 向零舍入模式：将浮点数转换为整数时，采用该模式，该模式将在目标数值类型中选择一个最接近但是不大于原值的数字作为最精确的舍入结果 NaN 值使用 当一个操作产生溢出时，将会使用有符号的无穷大表示，如果某个操作结果没有明确的数学定义的话，将会使用 NaN 值来表示。而且所有使用 NaN 值作为操作数的算术操作，结果都会返回 NaN 所有算数指令所有算术指令包括： 加法指令：iadd、ladd、fadd、dadd 减法指令：isub、lsub、fsub、dsub 乘法指令：imul、lmul、fmul、dmul 除法指令：idiv、ldiv、fdiv、ddiv 求余指令：irem、lrem、frem、drem(remainder：余数) 取反指令：ineg、lneg、fneg、dneg(negation：取反) 自增指令：iinc 位运算指令，又可分为： 位移指令：ishl、ishr、iushr、lshl、lshr、lushr 按位或指令：ior、lor 按位与指令：iand、land 按位异或指令：ixor、lxor 比较指令：dcmpg、dcmlp、fcmpg、fcmpl、lcmp 举例： 123public static int bar(int i) { return ((i + 1) - 2) * 3 / 4;} 字节码指令对应的图示： 比较指令的说明 比较指令的作用是比较栈顶两个元素的大小，并将比较结果入栈 比较指令有：dcmpg、dcmpl、fcmpg、fcmpl、lcmp 与前面讲解的指令类似，首字符 d 表示 double 类型，f 表示 float，l 表示 long 对于 double 和 float 类型的数字，由于 NaN 的存在，各有两个版本的比较指令，以 float 为例，有 fcmpg 和 fcmpl 两个指令，它们的区别在于在数字比较时，若遇到 NaN 值，处理结果不同 指令 dcmpl 和 dcmpg 也是类似的，根据其命名可以推测其含义，在此不再赘述 指令 lcmp 针对 long 型整数，由于 long 型整数没有 NaN 值，故无需准备两套指令 举例： 指令 fcmpg 和 fcmpl 都从栈中弹出两个操作数，并将它们做比较，设栈顶的元素为 v2， 栈顶顺位第2位元素为 v1，若 v1 = v2，则压入0；若 v1 &gt; v2 则压入1；若 v1 &lt; v2 则压入-1 两个指令的不同之处在于，如果遇到 NaN 值，fcmpg 会压入1，而 fcmpl 会压入-1 数值类型的数据才可以谈大小，boolean、引用数据类型不能比较大小 类型转换指令类型转换指令说明： 类型转换指令可以将两种不同的数值类型进行相互转换 这些转换操作一般用于实现用户代码中的显式类型转换操作，或者用来处理字节码指令集中数据类型相关指令无法与数据类型一一对应的问题 宽化类型转换(Widening Numeric Conversions) 转换规则 Java 虚拟机直接支持以下数值的宽化类型转换(Widening Numeric Conversion，小范围类型向大范围类型的安全转换)。也就是说，并不需要指令执行，包括： 从 int 类型到 long、float 或者 double 类型，对应的指令为：i2l、i2f、i2d 从 long 类型到 float、double 类型。对应的指令为：l2f、l2d 从 flaot 类型到 double 类型。对应的指令为：f2d 简化为：int —&gt; long —&gt; float —&gt; double 精度损失问题 宽化类型转换是不会因为超过目标类型最大值而丢失信息的，例如，从 int 转换到 long，或者从 int 转换到 double，都不会丢失任何信息，转换前后的值是精确相等的 从 int、long 类型数值转换到 float，或者 long 类型树脂转换到 double 时，将可能发生丢失精度——可能丢失掉几个最低有效位上的值，转换后的浮点数值是根据 IEEE754 最接近舍入模式所得到的正确整数数值。尽管宽化类型转换实际上是可能发生精度丢失的，但是这种转换永远不会导致 Java 虚拟机抛出运行时异常 从 byte、char 和 short 类型到 int 类型的宽化类型转换实际上是不存在的，对于 byte 类型转换为 int，虚拟机并没有做实质性的转化处理，知识简单地通过操作数栈交换了两个数据。而 byte 转为 long 时，使用的是 i2l，可以看到在内部 byte 在这里已经等同于 int 类型处理，类似的还有 short 类型，这种处理方式有两个特点： 一方面可以减少实际的数据类型，如果为 short 和 byte 都准备一套指令，那么指令的数量就会大增，而虚拟机目前的设计上，只愿意使用一个字节表示指令，因此指令总数不能超过256个，为了节省指令资源，将 short 和 byte 当作 int 处理也是情理之中 另一方面，由于局部变量表中的槽位固定为32位，无论是 byte 或者 short 存入局部变量表，都会占用32位空间。从这个角度来说，也没有必要特意区分这几种数据类型 窄化类型转换(Narrowing Numeric Conversion) 转换规则 Java 虚拟机也直接支持以下窄化类型转换： 从 int 类型至 byte、short 或者 char 类型。对应的指令有：i2b、i2c、i2s 从 long 类型到 int 类型。对应的指令有：l2i 从 float 类型到 int 或者 long 类型。对应的指令有：f2i、f2l 从 double 类型到 int、long 或者 float 类型。对应的指令有：d2i、d2l、d2f 精度损失问题 窄化类型转换可能会导致转换结果具备不同的正负号、不同的数量级，因此，转换过程很可能会导致数值丢失精度 尽管数据类型窄化转换可能会发生上限溢出、下限溢出和精度丢失等情况，但是 Java 虚拟机规范中明确规定数值类型的窄化转换指令永远不可能导致虚拟机抛出运行时异常 补充说明 当一个浮点值窄化转换为整数类型 T(T 限于 int 或 long 类型之一)的时候，将遵循以下转换规则： 如果浮点值是 NaN，那转换结果就是 int 或 long 类型的0 如果浮点值不是无穷大的话，浮点值使用 IEEE754 的向零舍入模式取整，获得整数值 v，如果 v 在目标类型 T(int 或 long)的表示范围之内，那转换结果就是 v。否则，将根据 v 的符号，转换为 T 所能表示的最大或者最小正数 当一个 double 类型窄化转换为 float 类型时，将遵循以下转换规则： 通过向最接近数舍入模式舍入一个可以使用 float 类型表示的数字。最后结果根据下面这3条规则判断： 如果转换结果的绝对值太小而无法使用 float 来表示，将返回 float 类型的正负零 如果转换结果的绝对值太大而无法使用 float 来表示，将返回 float 类型的正负无穷大 对于 double 类型的 NaN 值将按规定转换为 float 类型的 NaN 值 对象的创建与访问指令Java 是面向对象的程序设计语言，虚拟机平台从字节码层面就对面向对象做了深层次的支持。有一系列指令专门用于对象操作，可进一步细分为创建指令、字段访问指令、数组操作指令和类型检查指令 创建指令虽然类实例和数组都是对象，但 Java 虚拟机对类实例和数组的创建与操作使用了不同的字节码指令 创建类实例的指令： 创建类实例的指令：new 它接收一个操作数，为指向常量池的索引，表示要创建的类型，执行完成后，将对象的引用压入栈 创建数组的指令： 创建数组的指令：newarray、anewarray、multianewarray newarray：创建基本类型数组 anewarray：创建引用类型数组 multianewarray：创建多维数组 上述创建指令可以用于创建对象或者数组，由于对象和数组在 Java 中的广泛使用，这些指令的使用频率也很高 字段访问指令对象创建后，就可以通过对象访问指令获取对象实例或数组实例中的字段或者数组元素 访问类字段(static 字段，或者称为类变量)的指令：getstatic、putstatic 访问类实例字段(非 static 字段，或者称为实例变量)的指令：getfield、putfield 举例： 以 getstatic 指令为例，它含有一个操作数，为指向常量池的 Fieldref 索引，它的作用就是获取 Fieldref 指定的对象或者值，并将其压入操作数栈 123public void sayHello() { System.out.println(\"Hello\");} 对应的字节码指令： 12340 getstatic #8 &lt;java/lang/System.out&gt;3 ldc #9 &lt;Hello&gt;5 invokevirtual #10 &lt;java/io/PrintStream.println&gt;8 return 图示： 数组操作指令数组操作指令主要有：xastore 和 xaload 指令。具体为： 把一个数组元素加载到操作数栈的指令：baload、caload、saload、iaload、laload、faload、daload、aaload 将一个操作数栈的值存储到数组元素中的指令：bastore、castore、sastore、iastore、lastore、fastore、dastore、aastore 即： 取数组长度的指令：arraylength 该指令弹出栈顶的数组元素，获取数组的长度，将长度压入栈 说明： 指令 xaload 表示将数组的元素压栈，比如 saload、caload 分别表示压入 short 数组和 char 数组。指令 xaload 在执行时，要求操作数中栈顶元素为数组索引 i，栈顶顺位第2个元素为数组引用 a，该指令会弹出栈顶这两个元素，并将 a[i] 重新压入堆栈 xastore 则专门针对数组操作，以 iastore 为例，它用于给一个 int 数组的给定索引赋值。在 iastore 执行前，操作数栈顶需要以此准备3个元素：值、索引、数组饮用，iastore 会弹出这3个值，并将值赋给数组中指定索引的位置 类型检查指令检查类实例或数组类型的指令：instanceof、checkcast 指令 checkcast 用于检查类型强制转换是否可以进行。如果可以进行，那么 checkcast 指令不会改变操作数栈，否则它会抛出 ClassCastException 异常 指令 instanceof 用来判断给定对象是否是某一个类的实例，它会将判断结果压入操作数栈 方法调用与返回指令方法调用指令方法调用指令：invokevirtual、invokeinterface、invokespecial、invokestatic、invokedynamic 一下5条指令用于方法调用： invokevirtual 指令用于调用对象的实例方法，根据对象的实际类型进行分派(虚方法分派)，支持多态。这也是 Java 语言中最常见的方法分派方式 invokeinterface 指令用于调用接口方法，它会在运行时搜索由特定对象所实现的这个接口方法，并找出适合的方法进行调用 invokespecial 指令用于调用一些需要特殊处理的实例方法，包括实例初始化方法(构造器)、私有方法和父类方法。这些方法都是静态类型绑定的，不会在调用时进行动态派发 invokestatic 指令用于调用命名类中的类方法(static 方法)。这是静态绑定的 invokedynamic 调用动态绑定的方法，这个是 JDK 1.7 后新加入的指令。用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法。前面4条调用指令的分派逻辑都固化在 Java 虚拟机内部，而 invokedynamic 指令的分派逻辑是由用户所设定的引导方法决定的 方法返回指令方法调用结束前，需要进行返回。方法返回指令是根据返回值的类型区分的 包括 ireturn(当返回值是 boolean、byte、char、short 和 int 类型时使用)、lreturn、freturn、dreturn 和 areturn 另外还有一条 return 指令供声明为 void 的方法、实例初始化方法以及类和接口的类初始化方法使用 返回类型 返回指令 void return Int(boolean、byte、char、short) ireturn long lreturn float freturn double dreturn reference Return 举例： 通过 ireturn 指令，将当前函数操作数栈的顶层元素弹出，并将这个元素压入调用者函数的操作数栈中(因为调用者非常关心函数的返回值)，所有在当前函数操作数栈中的其他元素都会被丢弃 如果当前返回的是 synchronized 方法，那么还会执行一个隐含的 monitorexit 指令，退出临界区 最后，会丢弃当前方法的整个帧，恢复调用者的帧，并将控制权转交给调用者 操作数栈管理指令如同操作一个普通数据结构中的堆栈那样，JVM 提供的操作数栈管理指令，可以用于直接操作操作数栈的指令 这类指令包括如下内容： 将一个或两个元素从栈顶弹出，并且直接废弃：pop、pop2 复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：dup、dup2、dup_x1、dup2_x1、du p_x2、dup2_x2 将栈最顶端的两个 Slot 数值位置交换：swap、Java 虚拟机没有提供交换两个64位数据类型(long、double)数值的指令 指令 nop 是一个非常特殊的指令，它的字节码为0x00。和汇编语言中的 nop 一样，它表示什么都不做，这条指令一般可用于调试、占位等 这些指令属于通用型，对栈的压入或者弹出无需知名数据类型 说明： 不带 _x 的指令是复制栈顶数据并压入栈顶。包括两个指令，dup 和 dup2，dup 的系数代表要复制的 Slot 个数 dup 开头的指令用于复制1个 Slot 的数据。例如1个 int 或1个 reference 类型数据 dup2 开头的指令用于复制2个 Slot 的数据。例如1个 long，或2个 int，或1个 int 加1个 float 类型数据 带 _x 的指令是复制栈顶数据并插入栈顶以下的某个位置。共有4个指令，dup_x1、dup2_x1、dup_x2、dup2_x2。对于带 _x 的复制插入指令，只要将指令的 dup 和 x 的系数相加，结果即为需要插入的位置。因此 dup_x1 插入位置：1+1=2，即栈顶2个 Slot 下面 dup_x2 插入位置：1+2=3，即栈顶3个 Slot 下面 dup2_x1 插入位置：2+1=3，即栈顶3个 Slot 下面 dup2_x2 插入位置：2+2=4，即栈顶4个 Slot 下面 pop：将栈顶的1个 Slot 数值出栈。例如1个 short 类型数值 pop2：将栈顶的2个 Slot 数值出栈。例如1个 double 类型数值，或者2个 int 类型数值 控制转移指令程序流程离不开条件控制，为了支持条件跳转，虚拟机提供了大量字节码指令，大体上可以分为比较指令、条件跳转指令、比较条件跳转指令、多条件分支跳转指令、无条件跳转指令等 条件跳转指令条件跳转指令通常和比较指令结合使用。在条件跳转指令执行前，一般可以先用比较指令进行栈顶元素的准备，然后进行条件跳转 条件跳转指令有：ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull。这些指令都接收两个字节的操作数，用于计算跳转的位置(16位符号整数作为当前位置的 offset) 它们的统一含义为：弹出栈顶元素，测试它是否满足某一条件，如果满足条件，则跳转到给定位置 具体说明： 注意： 与前面运算规则一致 对于 boolean、byte、char、short 类型的条件分支比较操作，都是使用 int 类型的比较指令完成 对于 long、float、double 类型的条件分支比较操作，则会先执行相应类型的比较运算指令，运算指令会返回一个整型值到操作数栈中，随后再执行 int 类型的条件分支比较操作来完成整个分支跳转 由于各类型的比较最终都会转为 int 类型的比较操作，所以 Java 虚拟机提供的 int 类型的条件分支指令是最为丰富和强大的 比较条件跳转指令比较条件跳转指令类似于比较指令和条件跳转指令的结合体，它将比较和跳转两个步骤合二为一 这类指令有：if_icmped、if_icmpne、if_icmplt、if_icmpgt、if_icmple、if_icmpge、if_acmped 和 if_acmpne 其中指令助记符加上 “if_” 后，以字符 “i” 开头的指令针对 int 型整数操作(也包括 short 和 byte 类型)，以字符 “a” 开头的指令表示对象引用的比较 具体说明： 这些指令都接收两个字节的操作数作为参数，用于计算跳转的位置。同时在执行指令时，栈顶需要准备两个元素进行比较。指令执行完成后，栈顶的这两个元素被清空，且没有任何数据入栈。如果预设条件成立，则执行跳转，否则，继续执行下一条语句 多条件分支跳转多条件分支跳转指令是专为 switch-case 语句设计的，主要有 tableswitch 和 lookupswitch 从助记符上看，两者都是 switch 语句的实现，它们的区别： tableswitch 要求多个条件分支值是连续的，它内部只存放起始值和终止值，以及若干个跳转偏移量，通过给定的操作数 index，可以立即定位到跳转偏移量位置，因此效率比较高 lookupswitch 内部存放着各个离散的 case-offset 对，每次执行都要搜索全部的 case-offset 对，找到匹配的 case 值，并根据对应的 offset 计算跳转地址，因此效率较低 指令 tableswitch 的示意图如下图所示。由于 tableswitch 的 case 值是连续的，因此只需要记录最低值和最高值，以及每一项对应的 offset 偏移量，根据给定的 index 值通过简单的计算即可直接定位到 offset 指令 lookupswitch 处理的是离散的 case 值，但是出于效率考虑，将 case-offset 对按照 case 值大小排序，给定 index 时，需要查找与 index 相等的 case，获得其 offset，如果找不到则跳转到 default。指令 lookupswitch 如下图所示 无条件跳转目前主要的无条件跳转指令为 goto，指令 goto 接收两个字节的操作数，共同组成一个带符号的整数，用于指定指令的偏移量，指令执行的目的就是跳转到偏移量给定的位置处 如果指令偏移量太大，超过双字节的带符号整数的范围，则可以使用指令 goto_w，它和 goto 有相同的作用，但是它接收4个字节的操作数，可以表示更大的地址范围 指令 jsr、jsr_w、ret 虽然也是无条件跳转的，但主要用于 try-finally 语句，且已经被虚拟机逐渐废弃，故不在这里介绍这两个指令 异常处理指令抛出异常指令 athrow 指令 在 Java 程序中显式抛出异常的操作(throw 语句)都是由 athrow 指令来实现的 除了使用 throw 语句显式抛出异常情况之外，JVM 规范还规定了许多运行时一场会在其它 Java 虚拟机指令检测到异常状况时自动抛出。例如，在之前介绍的整数运算时，当除数为零时，虚拟机会在 idiv 或 ldiv 指令中抛出 ArithmeticException 异常 注意 正常情况下，操作数栈的压入弹出都是一条条指令完成的。唯一的例外情况是在抛异常时，Java 虚拟机会清除操作数栈上的所有内容，而后将异常实例压入调用者操作数栈上 异常及异常的处理： 过程一：异常对象的生成过程 —-&gt; throw(手动/自动) —-&gt; 指令：athrow 过程二：异常的处理：抓抛模型 try-catch-finally —-&gt; 使用异常表 异常处理与异常表 处理异常 在 Java 虚拟机中，处理异常(catch 语句)不是由字节码指令来实现的(早期使用 jsr、ret 指令)，而是采用异常表来完成的 异常表 如果一个方法定义了一个 try-catch 或者 try-finally 的异常处理，就会创建一个异常表。它包含了每个异常处理或者 finally 块的信息。异常表保存了每个异常处理信息。比如： 起始位置 结束位置 程序计数器记录的代码处理的偏移地址 被捕获的异常类在常量池中的索引 当一个异常被抛出时，JVM 会在当前的方法里寻找一个匹配的处理，如果没有找到，这个方法会强制结束并弹出当前栈帧，并且异常会重新抛给上层调用的方法(在调用方法栈帧)。如果在所有栈帧弹出前仍然没有找到合适的异常处理，这个县城将终止。如果这个异常在最后一个非守护线程里抛出，将会导致 JVM 自己终止，比如这个线程是个 main 线程 不管什么时候抛出异常，如果异常处理最终匹配了所有异常类型，代码就会继续执行。在这种情况下， 如果方法结束后没有抛出异常，仍然执行 finally 块，在 return 前，它直接跳到 finally 块来完成目标 同步控制指令Java 虚拟机支持两种同步结构：方法级同步 和 方法内部一段指令序列的同步，这两种同步都是使用 monitor 来支持的 方法级的同步方法级的同步：是隐式的，即无需通过字节码指令来控制，它实现在方法调用和返回操作之中。虚拟机可以从方法常量池的方法表结构中的 ACC_SYNCHRONIZED 访问标志得知一个方法是否声明为同步方法 当调用方法时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否设置 如果设置了，执行线程将先持有同步锁，然后执行方法，最后在方法完成(无论是正常完成还是非正常完成)时释放同步锁 在方法执行期间，执行线程持有了同步锁，其它任何线程都无法再获得同一个锁 如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那么这个同步方法所持有的锁将在异常抛到同步方法之外时自动释放 举例： 1234private int i = 0;public synchronized void add() { i++;} 对应字节码： 12345670 aload_01 dup2 getdield #2 &lt;com/atguigu/java1/SynchronizedTest.i&gt;5 iconst_16 iadd7 putfield #2 &lt;com/atguigu/java1/SynchronizedTest.i&gt;10 return 说明： 这段代码和普通的无同步操作的代码没有什么不同，没有使用 monitorenter 和 monitorexit 进行同步区控制。这是因为，对于同步方法而言，当虚拟机通过方法的访问标识符判断是一个同步方法时，会自动在方法调用前进行加锁，当同步方法执行完毕后，不管方法是正常结束还是有异常抛出，均会由虚拟机释放这个锁。因此，对于同步方法而言，monitorenter 和 monitorexit 指令是隐式存在的，并未直接出现在字节码中 方法内指定指令序列的同步同步一段指令集序列：通常是由 Java 中的 synchronized 语句块来表示的。JVM 的指令集有 monitorenter 和 monitorexit 两条指令来支持 synchronized 关键字的语义 当一个线程进入同步代码块时，它使用 monitorenter 指令请求进入。如果当前对象的监视器计数器为0，则它会被准许进入，若为1，则判断持有当前监视器的线程是否为自己，如果是，则进入，否则进行等待，知道对象的监视器计数器为0，才会被允许进入同步块 当线程退出同步块时，需要使用 monitorexit 声明退出。在 Java 虚拟机中，任何对象都有一个监视器与之相关联，用来判断对象是否被锁定，当监视器被持有后，对象处于锁定状态 指令 monitorenter 和 monitorexit 在执行时，都需要在操作数栈顶压入对象，之后 monitorenter 和 monitorexit 的锁定和释放都是针对这个对象的监视器进行的 编译器必须确保无论方法通过何种方式完成，方法中调用过的每条 monitorenter 指令都必须执行其对应的 monitorexit 指令，而无论这个方法是正常结束还是异常结束 为了保证在方法异常完成时 monitorenter 和 monitorexit 指令依然可以正确配对执行，编译器会自动产生一个异常处理器，这个异常处理器声明可处理所有的异常，它的目的就是用来执行 monitorexit 指令","link":"/2020/10/23/%E5%B0%9A%E7%A1%85%E8%B0%B7JVM/%E7%AC%AC%E5%8D%81%E4%B9%9D%E7%AB%A0_%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/"},{"title":"尚硅谷JVM&#x2F;第十二章_执行引擎","text":"执行引擎执行引擎概述 执行引擎属于 JVM 的下层，里面包括解释器、及时编译器、垃圾回收器 执行引擎是 Java 虚拟机核心的组成部分之一。 “虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而虚拟机的执行引擎则是由软件自行实现的，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式。 JVM 的主要任务是负责装载字节码到其内部，但字节码并不能够直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅只是一些能够被 JVM 所识别的字节码指令、符号表，以及其他辅助信息。 那么，如果想要让一个 Java 程序运行起来，执行引擎（Execution Engine）的任务就是将字节码指令解释/编译为对应平台上的本地机器指令才可以。简单来说，JVM 中的执行引擎充当了将高级语言翻译为机器语言的译者。 执行引擎的工作流程 执行引擎在执行的过程中究竟需要执行什么样的字节码指令完全依赖于 PC 寄存器。 每当执行完一项指令操作后，PC 寄存器就会更新下一条需要被执行的指令地址。 当然方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在 Java 堆区中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息。 从外观上来看，所有的 Java 虚拟机的执行引擎输入、输出都是一致的：输入的是字节码二进制流，处理过程是字节码解析执行的等效过程，输出的是执行过程。 Java代码编译和执行过程大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过上图中的各个步骤 前面橙色部分是生成字节码文件的过程，和 JVM 无关 后面蓝色和绿色才是 JVM 需要考虑的过程 Java 代码编译是由 Java 源码编译器来完成，流程图如下所示： Java 字节码的执行是由 JVM 执行引擎来完成，流程图如下所示 我们用一个总的图，来说说解释器和编译器 什么是解释器（Interpreter）当 Java 虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。 什么是 JIT 编译器JIT（Just In Time Compiler）编译器：就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言。 为什么 Java 是半编译半解释型语言JDK 1.0 时代，将 Java 语言定位为“解释执行”还是比较准确的。再后来，Java 也发展出可以直接生成本地代码的编译器。现在 JVM 在执行 Java 代码的时候，通常都会将解释执行与编译执行二者结合起来进行。 翻译成本地代码后，就可以做一个缓存操作，存储在方法区中 机器码、指令、汇编语言机器码各种用二进制编码方式表示的指令，叫做机器指令码。开始，人们就用它编写程序，这就是机器语言。 机器语言虽然能够被计算机理解和接受，但和人们的语言差别太大，不易被人们理解和记忆，并且用它编程容易出差错。 用它编写的程序一经输入计算机，CPU 直接读取运行，因此和其他语言编的程序相比，执行速度最快。 机器指令与 CPU 紧密相关，所以不同种类的 CPU 所对应的机器指令也就不同。 指令由于机器码是有 0 和 1 组成的二进制序列，可读性实在太差，于是人们发明了指令。 指令就是把机器码中特定的 0 和 1 序列，简化成对应的指令（一般为英文简写，如 mov，inc 等），可读性稍好 由于不同的硬件平台，执行同一个操作，对应的机器码可能不同，所以不同的硬件平台的同一种指令（比如mov），对应的机器码也可能不同。 指令集不同的硬件平台，各自支持的指令，是有差别的。因此每个平台所支持的指令，称之为对应平台的指令集。如常见的 x86 指令集，对应的是 x86 架构的平台 ARM 指令集，对应的是 ARM 架构的平台 汇编语言由于指令的可读性还是太差，于是人们又发明了汇编语言。 在汇编语言中，用助记符（Mnemonics）代替机器指令的操作码，用地址符号（Symbol）或标号（Label）代替指令或操作数的地址。 在不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。 由于计算机只认识指令码，所以用汇编语言编写的程序还必须翻译成机器指令码，计算机才能识别和执行。 高级语言为了使计算机用户编程序更容易些，后来就出现了各种高级计算机语言。高级语言比机器语言、汇编语言更接近人的语言 当计算机执行高级语言编写的程序时，仍然需要把程序解释和编译成机器的指令码。完成这个过程的程序就叫做解释程序或编译程序。 高级语言也不是直接翻译成机器指令，而是翻译成汇编语言，如下面说的 C 和 C++ C、C++源程序执行过程编译过程又可以分成两个阶段：编译和汇编。 编译过程：是读取源程序（字符流），对之进行词法和语法的分析，将高级语言指令转换为功能等效的汇编代码 汇编过程：实际上指把汇编语言代码翻译成目标机器指令的过程。 字节码字节码是一种中间状态（中间码）的二进制代码（文件），它比机器码更抽象，需要直译器转译后才能成为机器码 字节码主要为了实现特定软件运行和软件环境、与硬件环境无关。 字节码的实现方式是通过编译器和虚拟机器。编译器将源码编译成字节码，特定平台上的虚拟机器将字节码转译为可以直接执行的指令。 字节码典型的应用为：Java bytecode 解释器JVM 设计者们的初衷仅仅只是单纯地为了满足 Java 程序实现跨平台特性，因此避免采用静态编译的方式直接生成本地机器指令，从而诞生了实现解释器在运行时采用逐行解释字节码执行程序的想法。 为什么 Java 源文件不直接翻译成不同平台对应的机器指令 ，而是翻译成字节码文件？可能是因为直接翻译的机器指令代价较大，耗时较长 解释器真正意义上所承担的角色就是一个运行时“翻译者”，将字节码文件中的内容“翻译”为对应平台的本地机器指令执行。 当一条字节码指令被解释执行完成后，接着再根据 PC 寄存器中记录的下一条需要被执行的字节码指令执行解释操作。 解释器分类在 Java 的发展历史里，一共有两套解释执行器，即古老的字节码解释器、现在普遍使用的模板解释器。 字节码解释器在执行时通过纯软件代码模拟字节码的执行，效率非常低下。 而模板解释器将每一条字节码和一个模板函数相关联，模板函数中直接产生这条字节码执行时的机器码，从而很大程度上提高了解释器的性能。 在 HotSpot VM 中，解释器主要由 Interpreter 模块和 Code 模块构成。 Interpreter 模块：实现了解释器的核心功能 Code 模块：用于管理 HotSpot VM 在运行时生成的本地机器指令 现状由于解释器在设计和实现上非常简单，因此除了 Java 语言之外，还有许多高级语言同样也是基于解释器执行的，比如 Python、Perl、Ruby 等。但是在今天，基于解释器执行已经沦落为低效的代名词，并且时常被一些 C/C++ 程序员所调侃。 为了解决这个问题，JVM 平台支持一种叫作即时编译的技术。即时编译的目的是避免函数被解释执行，而是将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可，这种方式可以使执行效率大幅度提升。 不过无论如何，基于解释器的执行模式仍然为中间语言的发展做出了不可磨灭的贡献。 JIT 编译器Java 代码的执行分类第一种是将源代码编译成字节码文件，然后在运行时通过解释器将字节码文件转为机器码执行 第二种是编译执行（直接编译成机器码）。现代虚拟机为了提高执行效率，会使用即时编译技术（JIT，Just In Time）将方法编译成机器码后再执行 HotSpot VM 是目前市面上高性能虚拟机的代表作之一。它采用解释器与即时编译器并存的架构。在 Java 虚拟机运行时，解释器和即时编译器能够相互协作，各自取长补短，尽力去选择最合适的方式来权衡编译本地代码的时间和直接解释执行代码的时间。 在今天，Java 程序的运行性能早已脱胎换骨，已经达到了可以和 C/C++ 程序一较高下的地步。 问题来了有些开发人员会感觉到诧异，既然 HotSpot VM 中已经内置 JIT 编译器了，那么为什么还需要再使用解释器来“拖累”程序的执行性能呢？比如 JRockit VM 内部就不包含解释器，字节码全部都依靠即时编译器编译后执行。 JRockit 虚拟机是砍掉了解释器，也就是只采及时编译器。那是因为 JRockit 只部署在服务器上，一般已经有时间让他进行指令编译的过程了，对于响应来说要求不高，等及时编译器的编译完成后，就会提供更好的性能 首先明确：当程序启动后，解释器可以马上发挥作用，省去编译的时间，立即执行。编译器要想发挥作用，把代码编译成本地代码，需要一定的执行时间。但编译为本地代码后，执行效率高。 所以：尽管 JRockit VM 中程序的执行性能会非常高效，但程序在启动时必然需要花费更长的时间来进行编译。对于服务端应用来说，启动时间并非是关注重点，但对于那些看中启动时间的应用场景而言，或许就需要采用解释器与即时编译器并存的架构来换取一个平衡点。在此模式下，当 Java 虚拟器启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。 同时，解释执行在编译器进行激进优化不成立的时候，作为编译器的“逃生门”。 HotSpot JVM执行方式当虚拟机启动的时候，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成再执行，这样可以省去许多不必要的编译时间。并且随着程序运行时间的推移，即时编译器逐渐发挥作用，根据热点探测功能，将有价值的字节码编译为本地机器指令，以换取更高的程序执行效率。 案例注意解释执行与编译执行在线上环境微妙的辩证关系。机器在热机状态可以承受的负载要大于冷机状态。如果以热机状态时的流量进行切流，可能使处于冷机状态的服务器因无法承载流量而假死。 在生产环境发布过程中，以分批的方式进行发布，根据机器数量划分成多个批次，每个批次的机器数至多占到整个集群的 1/8 。曾经有这样的故障案例：某程序员在发布平台进行分批发布，在输入发布总批数时，误填写成分为两批发布。如果是热机状态，在正常情况下一半的机器可以勉强承载流量，但由于刚启动的 JVM 均是解释执行，还没有进行热点代码统计和 JIT 动态编译，导致机器启动之后，当前 1/2 发布成功的服务器马上全部宕机，此故障说明了 JIT 的存在。—阿里团队 概念解释 Java 语言的“编译期”其实是一段“不确定”的操作过程，因为它可能是指一个前端编译器（其实叫“编译器的前端”更准确一些）把 .java 文件转变成 .class 文件的过程； 也可能是指虚拟机的后端运行期编译器（JIT 编译器，Just In Time Compiler）把字节码转变成机器码的过程。 还可能是指使用静态提前编译器（AOT 编译器，Ahead of Time Compiler）直接把 .java 文件编译成本地机器代码的过程。 前端编译器：Sun 的 Javac、Eclipse JDT 中的增量式编译器（ECJ）。 JIT 编译器：HotSpot VM的 C1、C2 编译器。 AOT 编译器：GNU Compiler for the Java（GCJ）、Excelsior JET。 热点探测技术当然是否需要启动 JIT 编译器将字节码直接编译为对应平台的本地机器指令，则需要根据代码被调用执行的频率而定。关于那些需要被编译为本地代码的字节码，也被称之为“热点代码”，JIT 编译器在运行时会针对那些频繁被调用的“热点代码”做出深度优化，将其直接编译为对应平台的本地机器指令，以此提升 Java 程序的执行性能。 一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为“热点代码”，因此都可以通过 JIT 编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此被称之为栈上替换，或简称为 OSR（On Stack Replacement）编译。 一个方法究竟要被调用多少次，或者一个循环体究竟需要执行多少次循环才可以达到这个标准？必然需要一个明确的阈值，JIT 编译器才会将这些“热点代码”编译为本地机器指令执行。这里主要依靠热点探测功能。 目前 HotSpot VM 所采用的热点探测方式是基于计数器的热点探测。 采用基于计数器的热点探测，HotSpot VM 将会为每一个方法都建立2个不同类型的计数器，分别为方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter）。 方法调用计数器用于统计方法的调用次数 回边计数器则用于统计循环体执行的循环次数 方法调用计数器这个计数器就用于统计方法被调用的次数，它的默认阀值在 Client 模式下是1500次，在 Server 模式下是10000次。超过这个阈值，就会触发 JIT 编译。 这个阀值可以通过虚拟机参数 -XX:CompileThreshold 来人为设定。 当一个方法被调用时，会先检查该方法是否存在被 JIT 编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将此方法的调用计数器值加1，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阀值。如果已超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。 热点衰减如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间之内方法被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的衰减（Counter Decay），而这段时间就称为此方法统计的半衰周期（Counter Half Life Time） 半衰周期是化学中的概念，比如出土的文物通过查看 C60 来获得文物的年龄 进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数-XX:-UseCounterDecay 来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。 另外，可以使用 -XX:CounterHalfLifeTime 参数设置半衰周期的时间，单位是秒。 回边计数器它的作用是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为“回边”（Back Edge）。显然，建立回边计数器统计的目的就是为了触发 OSR 编译。 HotSpot VM 可以设置程序执行方法缺省情况下 HotSpot VM 是采用解释器与即时编译器并存的架构，当然开发人员可以根据具体的应用场景，通过命令显式地为 Java 虚拟机指定在运行时到底是完全采用解释器执行，还是完全采用即时编译器执行。如下所示： -Xint：完全采用解释器模式执行程序 -Xcomp：完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行 -Xmixed：采用解释器+即时编译器的混合模式共同执行程序。 HotSpot VM 中 JIT 分类在 HotSpot VM 中内嵌有两个 JIT 编译器，分别为 Client Compiler和Server Compiler，但大多数情况下我们简称为 C1 编译器和 C2 编译器。开发人员可以通过如下命令显式指定 Java 虚拟机在运行时到底使用哪一种即时编译器，如下所示： -client：指定 Java 虚拟机运行在 Client 模式下，并使用 C1 编译器； C1 编译器会对字节码进行简单和可靠的优化，耗时短。以达到更快的编译速度。 -server：指定 Java 虚拟机运行在 Server 模式下，并使用 C2 编译器。 C2 进行耗时较长的优化，以及激进优化。但优化的代码执行效率更高。（使用 C++ 实现） C1 和 C2 编译器不同的优化策略在不同的编译器上有不同的优化策略，C1 编译器上主要有方法内联，去虚拟化、元余消除。 方法内联：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程 去虚拟化：对唯一的实现类进行内联 冗余消除：在运行期间把一些不会执行的代码折叠掉 C2 的优化主要是在全局层面，逃逸分析是优化的基础。基于逃逸分析在 C2 上有如下几种优化： 标量替换：用标量值代替聚合对象的属性值 栈上分配：对于未逃逸的对象分配对象在栈而不是堆 同步消除：清除同步操作，通常指 synchronized 分层编译策略分层编译（Tiered Compilation）策略：程序解释执行（不开启性能监控）可以触发 C1 编译，将字节码编译成机器码，可以进行简单优化，也可以加上性能监控，C2 编译会根据性能监控信息进行激进优化。 不过在 Java 7 版本之后，一旦开发人员在程序中显式指定命令“-server”时，默认将会开启分层编译策略，由 C1 编译器和 C2 编译器相互协作共同来执行编译任务。 总结 一般来讲，JIT 编译出来的机器码性能比解释器高 C2 编译器启动时长比 C1 慢，系统稳定执行以后，C2 编译器执行速度远快于 C1 编译器 AOT编译器JDK 9 引入了 AOT 编译器（静态提前编译器，Ahead of Time Compiler） Java 9 引入了实验性 AOT 编译工具 jaotc。它借助了 Graal 编译器，将所输入的 Java 类文件转换为机器码，并存放至生成的动态共享库之中。 所谓 AOT 编译，是与即时编译相对立的一个概念。我们知道，即时编译指的是在程序的运行过程中，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而 AOT 编译指的则是，在程序运行之前，便将字节码转换为机器码的过程。 1.java -&gt; .class -&gt; (使用jaotc) -&gt; .so 最大的好处：Java 虚拟机加载已经预编译成二进制库，可以直接执行。不必等待及时编译器的预热，减少 Java 应用给人带来“第一次运行慢” 的不良体验 缺点： 破坏了 Java “ 一次编译，到处运行”，必须为每个不同的硬件，OS 编译对应的发行包 降低了 Java 链接过程的动态性，加载的代码在编译器就必须全部已知。 还需要继续优化中，最初只支持 Linux X64 java base 写到最后 自 JDK 10 起，HotSpot 又加入了一个全新的及时编译器：Graal 编译器 编译效果短短几年时间就追平了 C2 编译器，未来可期 目前，带着实验状态标签，需要使用开关参数 -XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler 去激活才能使用","link":"/2020/10/16/%E5%B0%9A%E7%A1%85%E8%B0%B7JVM/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/"},{"title":"尚硅谷JVM&#x2F;第十五章_垃圾回收相关算法","text":"垃圾回收相关算法标记阶段：引用计数算法 在堆里存放着几乎所有的 Java 对象实例，在 GC 执行垃圾回收之前，首先需要区分出内存中哪些是存活对象，哪些是已经死亡的对象。只有被标记为己经死亡的对象，GC 才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以称为垃圾标记阶段。 那么在 JVM 中究竟是如何标记一个死亡对象呢？简单来说，当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡。 判断对象存活一般有两种方式：引用计数算法和可达性分析算法。 引用计数算法（Reference Counting）比较简单，对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。 对于一个对象 A，只要有任何一个对象引用了 A，则 A 的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象 A 的引用计数器的值为0，即表示对象 A 不可能再被使用，可进行回收。 优点：实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。 缺点： 它需要单独的字段存储计数器，这样的做法增加了存储空间的开销。 每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了时间开销。 引用计数器有一个严重的问题，即无法处理循环引用的情况。这是一条致命缺陷，导致在 Java 的垃圾回收器中没有使用这类算法。 循环引用当 p 的指针断开的时候，内部的引用形成一个循环，这就是循环引用，从而造成内存泄漏 123456789101112131415161718public class RefCountGC { // 这个成员属性的唯一作用就是占用一点内存 private byte[] bigSize = new byte[5*1024*1024]; // 引用 Object reference = null; public static void main(String[] args) { RefCountGC obj1 = new RefCountGC(); RefCountGC obj2 = new RefCountGC(); obj1.reference = obj2; obj2.reference = obj1; obj1 = null; obj2 = null; // 显式的执行垃圾收集行为 //这里发生GC，obj1和obj2能否被回收？ System.gc(); }} 运行结果 1234567891011[GC (System.gc()) [PSYoungGen: 15490K-&gt;808K(76288K)] 15490K-&gt;816K(251392K), 0.0061980 secs] [Times: user=0.00 sys=0.00, real=0.36 secs] [Full GC (System.gc()) [PSYoungGen: 808K-&gt;0K(76288K)] [ParOldGen: 8K-&gt;672K(175104K)] 816K-&gt;672K(251392K), [Metaspace: 3479K-&gt;3479K(1056768K)], 0.0045983 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] Heap PSYoungGen total 76288K, used 655K [0x000000076b500000, 0x0000000770a00000, 0x00000007c0000000) eden space 65536K, 1% used [0x000000076b500000,0x000000076b5a3ee8,0x000000076f500000) from space 10752K, 0% used [0x000000076f500000,0x000000076f500000,0x000000076ff80000) to space 10752K, 0% used [0x000000076ff80000,0x000000076ff80000,0x0000000770a00000) ParOldGen total 175104K, used 672K [0x00000006c1e00000, 0x00000006cc900000, 0x000000076b500000) object space 175104K, 0% used [0x00000006c1e00000,0x00000006c1ea8070,0x00000006cc900000) Metaspace used 3486K, capacity 4496K, committed 4864K, reserved 1056768K class space used 385K, capacity 388K, committed 512K, reserved 1048576K 我们能够看到，上述进行了 GC 收集的行为，将上述的新生代中的两个对象都进行回收了 1PSYoungGen: 15490K-&gt;808K(76288K)] 15490K-&gt;816K(251392K) 如果使用引用计数算法，那么这两个对象将会无法回收。而现在两个对象被回收了，说明 Java 使用的不是引用计数算法来进行标记的。 小结引用计数算法，是很多语言的资源回收选择，例如因人工智能而更加火热的 Python，它更是同时支持引用计数和垃圾收集机制。 具体哪种最优是要看场景的，业界有大规模实践中仅保留引用计数机制，以提高吞吐量的尝试。 Java 并没有选择引用计数，是因为其存在一个基本的难题，也就是很难处理循环引用关系。 Python 如何解决循环引用？ 手动解除：很好理解，就是在合适的时机，解除引用关系。 使用弱引用 weakref，weakref 是 Python 提供的标准库，旨在解决循环引用。 标记阶段：可达性分析算法(或根搜索算法、追踪性垃圾收集)概念相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地解决在引用计数算法中循环引用的问题，防止内存泄漏的发生。 相较于引用计数算法，这里的可达性分析就是 Java、C# 选择的。这种类型的垃圾收集通常也叫作追踪性垃圾收集（Tracing Garbage Collection） 思路所谓 “GC Roots” 根集合就是一组必须活跃的引用。 基本思路： 可达性分析算法是以根对象集合（GC Roots）为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达。 使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链（Reference Chain） 如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。 在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。 这里需要注意的是，可达性分析算法中，每次标记的是直接或间接与 GC Roots 连接的对象，标记完成后，遍历整个内存空间，将没有被标记的对象删除 官场上的裙带关系，可达性分析在人类关系网中 Java 中 GC Roots 可以是哪些？ 虚拟机栈中引用的对象 比如：各个线程被调用的方法中使用到的参数、局部变量等。 本地方法栈内 JNI（通常说的本地方法）引用的对象方法区中类静态属性引用的对象 比如：Java 类的引用类型静态变量 方法区中常量引用的对象 比如：字符串常量池（String Table）里的引用 所有被同步锁 synchronized 持有的对象 Java 虚拟机内部的引用。 基本数据类型对应的 Class 对象，一些常驻的异常对象（如：NullPointerException、OutOfMemoryError），系统类加载器。 反映 Java 虚拟机内部情况的 JMXBean、JVMTI 中注册的回调、本地代码缓存等。 总结总结一句话就是，堆空间外的一些结构，比如虚拟机栈、本地方法栈、方法区、字符串常量池等地方对堆空间进行引用的，都可以作为 GC Roots 进行可达性分析 除了这些固定的 GC Roots 集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整 GC Roots 集合。比如：分代收集和局部回收（Partial GC）。 如果只针对 Java 堆中的某一块区域进行垃圾回收（比如：典型的只针对新生代），必须考虑到内存区域是虚拟机自己的实现细节，而不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入 GC Roots 集合中去考虑，才能保证可达性分析的准确性。 小技巧由于 Root 采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个 Root。 注意如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。 这点也是导致 GC 进行时必须“Stop The World”的一个重要原因。 即使是号称（几乎）不会发生停顿的 CMS 收集器中，枚举根节点时也是必须要停顿的。 对象的 finalization机制Java 语言提供了对象终止（finalization）机制来允许开发人员提供对象被销毁之前的自定义处理逻辑。 当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的 finalize() 方法。 finalize() 方法允许在子类中被重写，用于在对象被回收时进行资源释放。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。 注意永远不要主动调用某个对象的 finalize() 方法，应该交给垃圾回收机制调用。理由包括下面三点： 在 finalize() 时可能会导致对象复活。 finalize() 方法的执行时间是没有保障的，它完全由 GC 线程决定，极端情况下，若不发生 GC，则 finalize() 方法将没有执行机会。 因为优先级比较低，即使主动调用该方法，也不会因此就直接进行回收 一个糟糕的 finalize() 会严重影响 GC 的性能。 从功能上来说， finalize() 方法与 C++ 中的析构函数比较相似，但是 Java 采用的是基于垃圾回收器的自动内存管理机制，所以 finalize() 方法在本质上不同于 C++ 中的析构函数。 由于 finalize() 方法的存在，虚拟机中的对象一般处于三种可能的状态。 生存还是死亡？如果从所有的根节点都无法访问到某个对象，说明对象己经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。一个无法触及的对象有可能在某一个条件下“复活”自己，如果这样，那么对它的回收就是不合理的，为此，定义虚拟机中的对象可能的三种状态。如下： 可触及的：从根节点开始，可以到达这个对象。 可复活的：对象的所有引用都被释放，但是对象有可能在 finalize() 中复活。 不可触及的：对象的 finalize() 被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为 finalize() 只会被调用一次。 以上3种状态中，是由于 finalize() 方法的存在，进行的区分。只有在对象不可触及时才可以被回收。 具体过程判定一个对象 objA 是否可回收，至少要经历两次标记过程： 如果对象 objA 到 GC Roots 没有引用链，则进行第一次标记。 进行筛选，判断此对象是否有必要执行 finalize() 方法 如果对象 objA 没有重写 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，objA 被判定为不可触及的。 如果对象 objA 重写了 finalize() 方法，且还未执行过，那么 objA 会被插入到 F-Queue 队列中，由一个虚拟机自动创建的、低优先级的 Finalizer 线程触发其 finalize() 方法执行。 finalize() 方法是对象逃脱死亡的最后机会，稍后 GC 会对 F-Queue 队列中的对象进行第二次标记。如果 objA 在 finalize() 方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA 会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。在这个情况下， finalize() 方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的 finalize() 方法只会被调用一次。 上图就是我们看到的 Finalizer 线程 代码演示我们使用重写 finalize() 方法，然后在方法的内部，重写将其存放到 GC Roots 中 12345678910111213141516171819202122232425262728293031323334353637public class CanReliveObj { // 类变量，属于GC Roots的一部分 public static CanReliveObj canReliveObj; @Override protected void finalize() throws Throwable { super.finalize(); System.out.println(\"调用当前类重写的finalize()方法\"); canReliveObj = this; } public static void main(String[] args) throws InterruptedException { canReliveObj = new CanReliveObj(); canReliveObj = null; System.gc(); System.out.println(\"-----------------第一次gc操作------------\"); // 因为Finalizer线程的优先级比较低，暂停2秒，以等待它 Thread.sleep(2000); if (canReliveObj == null) { System.out.println(\"obj is dead\"); } else { System.out.println(\"obj is still alive\"); } System.out.println(\"-----------------第二次gc操作------------\"); canReliveObj = null; System.gc(); // 下面代码和上面代码是一样的，但是 canReliveObj却自救失败了 Thread.sleep(2000); if (canReliveObj == null) { System.out.println(\"obj is dead\"); } else { System.out.println(\"obj is still alive\"); } }} 最后运行结果 12345-----------------第一次gc操作------------调用当前类重写的finalize()方法obj is still alive-----------------第二次gc操作------------obj is dead 在进行第一次清除的时候，我们会执行 finalize() 方法，然后对象进行了一次自救操作，但是因为 finalize() 方法只会被调用一次，因此第二次该对象将会被垃圾清除。 MAT 与 JProfiler 的 GC Roots 溯源MAT 是什么？MAT 是Memory Analyzer 的简称，它是一款功能强大的 Java 堆内存分析器。用于查找内存泄漏以及查看内存消耗情况。 MAT 是基于 Eclipse 开发的，是一款免费的性能分析工具。 大家可以在http://www.eclipse.org/mat/下载并使用 MAT 方法一：命令行使用 jmap 方法二：使用 JVisualVM捕获的 Heap Dump 文件是一个临时文件，关闭 JVisualVM 后自动删除，若要保留，需要将其另存为文件。可通过以下方法捕获 Heap Dump： 在左侧“Application”（应用程序）子窗口中右击相应的应用程序，选择 Heap Dump（堆Dump）。 在 Monitor（监视）子标签页中点击Heap Dump（堆Dump）按钮。本地应用程序的 Heap Dumps 作为应用程序标签页的一个子标签页打开。同时，Heap Dump 在左侧的 Application（应用程序）栏中对应一个含有时间戳的节点。 右击这个节点选择 Save As（另存为）即可将 Heap Dump 保存到本地。 使用 MAT 打开 Dump 文件打开后，我们就可以看到有哪些可以作为 GC Roots 的对象 里面我们能够看到有一些常用的 Java 类，然后 Thread 线程。 JProfiler 的 GC Roots 溯源我们在实际的开发中，一般不会查找全部的 GC Roots，可能只是查找某个对象的整个链路，或者称为 GC Roots溯源，这个时候，我们就可以使用 JProfiler 如何判断什么原因造成 OOM当我们程序出现 OOM 的时候，我们就需要进行排查，我们首先使用下面的例子进行说明 12345678910111213141516171819202122/** * 内存溢出排查 * -Xms8m -Xmx8m -XX:HeapDumpOnOutOfMemoryError */public class HeapOOM { // 创建1M的文件 byte [] buffer = new byte[1 * 1024 * 1024]; public static void main(String[] args) { ArrayList&lt;HeapOOM&gt; list = new ArrayList&lt;&gt;(); int count = 0; try { while (true) { list.add(new HeapOOM()); count++; } } catch (Exception e) { e.getStackTrace(); System.out.println(\"count:\" + count); } }} 上述代码就是不断的创建一个 1M 小字节数组，然后让内存溢出，我们需要限制一下内存大小，同时使用HeapDumpOnOutOfMemoryError 将出错时候的 dump 文件输出 1-Xms8m -Xmx8m -XX:HeapDumpOnOutOfMemoryError 我们将生成的 dump 文件打开，然后点击 Biggest Objects 就能够看到超大对象 然后我们通过线程，还能够定位到哪里出现 OOM 清除阶段：标记-清除算法当成功区分出内存中存活对象和死亡对象后，GC 接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。目前在 JVM 中比较常见的三种垃圾收集算法是 标记一清除算法（Mark-Sweep） 复制算法（Copying） 标记-压缩算法（Mark-Compact） 背景标记-清除算法（Mark-Sweep）是一种非常基础和常见的垃圾收集算法，该算法被 J.McCarthy 等人在1960年提出并并应用于 Lisp 语言。 执行过程当堆中的有效内存空间（Available Memory）被耗尽的时候，就会停止整个程序（也被称为Stop The World），然后进行两项工作，第一项则是标记，第二项则是清除 标记：Collector 从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的 Header 中记录为可达对象。 标记的是引用的对象，不是垃圾！！ 清除：Collector 对堆内存从头到尾进行线性的遍历，如果发现某个对象在其 Header 中没有标记为可达对象，则将其回收 什么是清除？这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放覆盖原有的地址。 关于空闲列表是在为对象分配内存的时候 如果内存规整 采用指针碰撞的方式进行内存分配 如果内存不规整 虚拟机需要维护一个列表 空闲列表分配 缺点 标记清除算法的效率不算高 在进行 GC 的时候，需要停止整个应用程序，导致用户体验较差 这种方式清理出来的空闲内存是不连续的，产生内存碎片，需要维护一个空闲列表 清除阶段：复制算法背景为了解决标记-清除算法在垃圾收集效率方面的缺陷，M.L.Minsky 于1963年发表了著名的论文，“使用双存储区的 Lisp 语言垃圾收集器 CA LISP Garbage Collector Algorithm Using Serial Secondary Storage）”。M.L.Minsky 在该论文中描述的算法被人们称为复制（Copying）算法，它也被 M.L.Minsky 本人成功地引入到了Lisp 语言的一个实现版本中。 核心思想将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收 把可达的对象，直接复制到另外一个区域中复制完成后，A 区就没有用了，里面的对象可以直接清除掉，其实里面的新生代里面就用到了复制算法 优点 没有标记和清除过程，实现简单，运行高效 复制过去以后保证空间的连续性，不会出现“碎片”问题。 缺点 此算法的缺点也是很明显的，就是需要两倍的内存空间。 对于 G1 这种分拆成为大量 region 的 GC，复制而不是移动，意味着 GC 需要维护 region 之间对象引用关系，不管是内存占用或者时间开销也不小 注意如果系统中的垃圾对象很多，复制算法需要复制的存活对象数量并不会太大，或者说非常低才行（老年代大量的对象存活，那么复制的对象将会有很多，效率会很低），特别适合垃圾对象很多，存活对象很少的场景；例如：Young 区的 Survivor0 和 Survivor1 区 应用场景在新生代，对常规应用的垃圾回收，一次通常可以回收 70% - 99% 的内存空间。回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代。 清除阶段：标记-压缩(整理)算法背景复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，基于老年代垃圾回收的特性，需要使用其他的算法。 标记一清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以 JVM 的设计者需要在此基础之上进行改进。标记-压缩（Mark-Compact）算法由此诞生。 1970年前后，G.L.Steele、C.J.Chene 和 D.s.Wise 等研究者发布标记-压缩算法。在许多现代的垃圾收集器中，人们都使用了标记-压缩算法或其改进版本。 执行过程第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象 第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。之后，清理边界外所有的空间。 标清和标整的区别标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为标记-清除-压缩（Mark-Sweep-Compact）算法。 二者的本质差异在于标记-清除算法是一种非移动式的回收算法，标记-压缩是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策。可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM 只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。 指针碰撞(Bump the Pointer)如果内存空间以规整和有序的方式分布，即已用和未用的内存都各自一边，彼此之间维系着一个记录下一次分配起始点的标记指针，当为新对象分配内存时，只需要通过修改指针的偏移量将新对象分配在第一个空闲内存位置上，这种分配方式就叫做指针碰撞(Bump the Pointer) 标整的优缺点优点 消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM 只需要持有一个内存的起始地址即可。 消除了复制算法当中，内存减半的高额代价。 缺点 从效率上来说，标记-整理算法要低于复制算法。 移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址 移动过程中，需要全程暂停用户应用程序。即：STW 小结效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存。 而为了尽量兼顾上面提到的三个指标，标记-整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记的阶段，比标记-清除多了一个整理内存的阶段。 标记清除 标记整理 复制 速率 中等 最慢 最快 空间开销 少（但会堆积碎片） 少（不堆积碎片） 通常需要活对象的2倍空间（不堆积碎片） 移动对象 否 是 是 综合我们可以找到，没有最好的算法，只有最合适的算法 分代收集算法前面所有这些算法中，并没有一种算法可以完全替代其他算法，它们都具有自己独特的优势和特点。分代收集算法应运而生。 分代收集算法，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。 在 Java 程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如 Http 请求中的 Session对象、线程、Socket 连接，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：String对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。 目前几乎所有的 GC 都采用分代收集算法执行垃圾回收的 在 HotSpot 中，基于分代的概念，GC 所使用的内存回收算法必须结合年轻代和老年代各自的特点。 年轻代（Young Gen） 年轻代特点：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。 这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过 HotSpot 中的两个 Survivor 的设计得到缓解。 老年代（Tenured Gen） 老年代特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。 这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记-清除或者是标记-清除与标记-整理的混合实现。 Mark 阶段的开销与存活对象的数量成正比。 Sweep 阶段的开销与所管理区域的大小成正相关。 Compact 阶段的开销与存活对象的数据成正比。 以 HotSpot 中的 CMS 回收器为例，CMS 是基于 Mark-Sweep 实现的，对于对象的回收效率很高。而对于碎片问题，CMS 采用基于 Mark-Compact 算法的 Serial Old 回收器作为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure 时），将采用 Serial Old 执行 Full GC 以达到对老年代内存的整理。 分代的思想被现有的虚拟机广泛使用。几乎所有的垃圾回收器都区分新生代和老年代 增量收集算法概述上述现有的算法，在垃圾回收过程中，应用软件将处于一种 Stop the World 的状态。在 Stop the World 状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集（Incremental Collecting）算法的诞生。 基本思想如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。 总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过对线程间冲突的妥善处理允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作 缺点使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。 分区算法一般来说，在相同条件下，堆空间越大，一次 GC 时所需要的时间就越长，有关 GC 产生的停顿也越长。为了更好地控制 GC 产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次 GC 所产生的停顿。 分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。 写到最后注意，这些只是基本的算法思路，实际 GC 实现过程要复杂的多，目前还在发展中的前沿 GC 都是复合算法，并且并行和并发兼备。","link":"/2020/10/16/%E5%B0%9A%E7%A1%85%E8%B0%B7JVM/%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/"},{"title":"尚硅谷JVM&#x2F;第十四章_垃圾回收概述","text":"垃圾回收概述概念 这次我们主要关注的是黄色部分，内存的分配与回收 什么是垃圾在提到什么是垃圾之前，我们先看下面一张图 从上图我们可以很明确的知道，Java 和 C++ 语言的区别，就在于垃圾收集技术和内存动态分配上，C 语言没有垃圾收集技术，需要我们手动的收集。 垃圾收集，不是 Java 语言的伴生产物。早在1960年，第一门开始使用内存动态分配和垃圾收集技术的 Lisp 语言诞生。关于垃圾收集有三个经典问题： 哪些内存需要回收？ 什么时候回收？ 如何回收？ 垃圾收集机制是 Java 的招牌能力，极大地提高了开发效率。如今，垃圾收集几乎成为现代语言的标配，即使经过如此长时间的发展，Java 的垃圾收集机制仍然在不断的演进中，不同大小的设备、不同特征的应用场景，对垃圾收集提出了新的挑战，这当然也是面试的热点。 什么是垃圾？垃圾是指在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾。 如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空间会一直保留到应用程序的结束，被保留的空间无法被其它对象使用，甚至可能导致内存溢出。 磁盘碎片整理机械硬盘需要进行磁盘整理，同时还有坏道 大厂面试题蚂蚁金服 你知道哪几种垃圾回收器，各自的优缺点，重点讲一下 CMS 和 G1？ JVM GC 算法有哪些，目前的 JDK 版本采用什么回收算法？ G1 回收器讲下回收过程 GC 是什么？为什么要有 GC？ GC 的两种判定方法？CMS 收集器与 G1 收集器的特点 百度 说一下 GC 算法，分代回收说下 垃圾收集策略和算法 天猫 JVM GC 原理，JVM 怎么回收内存 CMS 特点，垃圾回收算法有哪些？各自的优缺点，他们共同的缺点是什么？ 滴滴Java 的垃圾回收器都有哪些，说下 G1 的应用场景，平时你是如何搭配使用垃圾回收器的 京东 你知道哪几种垃圾收集器，各自的优缺点，重点讲下 CMS 和 G1， 包括原理，流程，优缺点。垃圾回收算法的实现原理 阿里 讲一讲垃圾回收算法。 什么情况下触发垃圾回收？ 如何选择合适的垃圾收集算法？ JVM 有哪三种垃圾回收器？ 字节跳动 常见的垃圾回收器算法有哪些，各有什么优劣？ System.gc（）和 Runtime.gc（）会做什么事情？ Java GC 机制？GC Roots 有哪些？ Java 对象的回收方式，回收算法。 CMS 和 G1 了解么，CMS 解决什么问题，说一下回收的过程。 CMS 回收停顿了几次，为什么要停顿两次? 为什么需要 GC对于高级语言来说，一个基本认知是如果不进行垃圾回收，内存迟早都会被消耗完，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫一样。 除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，以便JVM 将整理出的内存分配给新的对象。 随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，没有 GC 就不能保证应用程序的正常进行。而经常造成 STW 的 GC 又跟不上实际的需求，所以才会不断地尝试对 GC 进行优化。 早期垃圾回收在早期的 C/C++ 时代，垃圾回收基本上是手工进行的。开发人员可以使用 new 关键字进行内存申请，并使用delete 关键字进行内存释放。比如以下代码： 1234MibBridge * pBridge = new cmBaseGroupBridge（）；//如果注册失败，使用Delete释放该对象所占内存区域if（pBridge -&gt; Register（kDestroy）！= NO ERROR） delete pBridge； 这种方式可以灵活控制内存释放的时间，但是会给开发人员带来频繁申请和释放内存的管理负担。倘若有一处内存区间由于程序员编码的问题忘记被回收，那么就会产生内存泄漏，垃圾对象永远无法被清除，随着系统运行时间的不断增长，垃圾对象所耗内存可能持续上升，直到出现内存溢出并造成应用程序崩溃。 有了垃圾回收机制后，上述代码极有可能变成这样 12MibBridge * pBridge = new cmBaseGroupBridge(); pBridge -&gt; Register(kDestroy); 现在，除了 Java 以外，C#、Python、Ruby 等语言都使用了自动垃圾回收的思想，也是未来发展趋势，可以说这种自动化的内存分配和来及回收方式已经成为了线代开发语言必备的标准。 Java 垃圾回收机制优点自动内存管理，无需开发人员手动参与内存的分配与回收，这样降低内存泄漏和内存溢出的风险 没有垃圾回收器，Java 也会和 C++ 一样，各种悬垂指针，野指针，泄露问题让你头疼不已。 自动内存管理机制，将程序员从繁重的内存管理中释放出来，可以更专心地专注于业务开发 Oracle 官网关于垃圾回收的介绍https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html 担忧对于 Java 开发人员而言，自动内存管理就像是一个黑匣子，如果过度依赖于“自动”，那么这将会是一场灾难，最严重的就会弱化 Java 开发人员在程序出现内存溢出时定位问题和解决问题的能力。 此时，了解 JVM 的自动内存分配和内存回收原理就显得非常重要，只有在真正了解 JVM 是如何管理内存后，我们才能够在遇见 OutOfMemoryError 时，快速地根据错误异常日志定位问题和解决问题。 当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术实施必要的监控和调节。 GC 主要关注的区域GC 主要关注于方法区和堆中的垃圾收集 垃圾收集器可以对年轻代回收，也可以对老年代回收，甚至是全栈和方法区的回收 其中，Java 堆是垃圾收集器的工作重点 从次数上讲： 频繁收集 Young 区 较少收集 Old 区 基本不收集 Perm 区（元空间）","link":"/2020/10/16/%E5%B0%9A%E7%A1%85%E8%B0%B7JVM/%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0/"},{"title":"尚硅谷JVM&#x2F;第十章_对象实例化内存布局与访问定位","text":"对象实例化内存布局与访问定位对象实例化 面试题 对象在 JVM 中是怎么存储的？ 对象头信息里面有哪些东西？ Java 对象头有什么？ 从对象创建的方式和步骤开始说 对象创建方式 new：最常见的方式、单例类中调用 getInstance 的静态类方法，XXXFactory 的静态方法 Class 的 newInstance 方法：在 JDK 9 里面被标记为过时的方法，因为只能调用空参构造器，权限必须是 public Constructor 的 newInstance(XXX)：反射的方式，可以调用空参的，或者带参的构造器，权限没有要求 使用 clone()：不调用任何的构造器，要求当前的类需要实现 Cloneable 接口中的 clone() 方法 使用反序列化：序列化一般用于 Socket 的网络传输，从文件、网络中获取文件二进制流 第三方库 Objenesis 创建对象的步骤判断对象对应的类是否加载、链接、初始化虚拟机遇到一条 new 指令，首先去检查这个指令的参数能否在 Metaspace 的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化（即判断类元信息是否存在）。如果没有，那么在双亲委派模式下，使用当前类加载器以 ClassLoader + 包名 + 类名为 Key 进行查找对应的 .class 文件，如果没有找到文件，则抛出 ClassNotFoundException 异常，如果找到，则进行类加载，并生成对应的 Class 对象。 为对象分配内存首先计算对象占用空间的大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小（ long 和 double 是8个字节） 如果内存规整：使用指针碰撞 如果内存是规整的，那么虚拟机将采用的是指针碰撞法（Bump The Point）来为对象分配内存。 意思是所有用过的内存在一边，空闲的内存放另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针指向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是 Serial ，ParNew 这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带 Compact（整理）过程的收集器时，使用指针碰撞。 如果内存不规整：虚拟表需要维护一个列表：空闲列表分配 如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表来为对象分配内存。意思是虚拟机维护了一个列表，记录上那些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式成为了 “空闲列表（Free List）”。 说明：选择哪种分配方式由 Java 堆是否规整所决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。 处理并发问题在分配内存空间时，另外一个问题是及时保证 new 对象时候的线程安全性：创建对象是非常频繁的操作，虚拟机需要解决并发问题。虚拟机采用了两种方式解决并发问题： CAS（Compare And Swap）失败重试、区域加锁：保证指针更新操作的原子性 TLAB 把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java 堆中预先分配一个小块内存，称为本地线程分配缓冲区，（TLAB，Thread Local Allocation Buffer）虚拟机是否使用 TLAB，可以通过 -XX:+/-UseTLAB 参数来设定 初始化分配到的内存内存分配结束，虚拟机将分配到的内存空间都初始化为零值（不包括对象头），这一步保证了对象的实例字段在 Java 代码中可以不用赋初始值就可以直接使用，程序能访问到这些字段的数据类型所对应的零值 属性的默认初始化 显示初始化 代码块中的初始化 构造器初始化 所有属性设置默认值，保证对象实例字段在不赋值可以直接使用 设置对象的对象头将对象的所属类（即类的元数据信息）、对象的 HashCode 和对象的 GC 信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于 JVM 实现。 执行 init 方法进行初始化在 Java 程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量 因此一般来说（由字节码中跟随 invokespecial 指令所决定），new 指令之后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完成创建出来。 对象实例化的过程 加载类元信息 为对象分配内存 处理并发问题 属性的默认初始化（零值初始化） 设置对象头信息 属性的显示初始化、代码块中初始化、构造器中初始化 对象内存布局 对象头（Header）对象头包含了两部分，分别是运行时元数据（Mark Word）和类型指针 如果是数组，还需要记录数组的长度 运行时元数据 哈希值（HashCode） GC 分代年龄 锁状态标志 线程持有的锁 偏向线程 ID 偏向时间戳 类型指针指向类元数据 InstanceKlass ，确定该对象所属的类型。指向的其实是方法区中存放的类元信息 实例数据（Instance Data）说明它是对象真正存储的有效信息，包括程序代码中定义的各种类型的字段（包括从父类继承下来的和本身拥有的字段） 规划 相同宽度的字段总是被分配在一起 父类中定义的变量会出现在子类之前 如果 CompactFields 参数为 true（默认为 true），子类的窄变量可能插入到父类变量的空隙 对齐填充（Padding）不是必须的，也没有特别含义，仅仅起到占位符的作用 小结 对象的访问定位图示JVM 是如何通过栈帧中的对象引用访问到其内部的对象实例呢？——定位，通过栈上 reference 访问 创建对象的目的就是为了使用它 对象访问的两种方式句柄访问 句柄访问就是说栈的局部变量表中，记录的对象的引用，然后在堆空间中开辟了一块空间，也就是句柄池 优点reference 中存储稳定句柄地址，对象被移动（垃圾收集时移动对象很普遍）时只会改变句柄中实例数据指针即可，reference 本身不需要被修改 直接指针（HotSpot采用） 直接指针是局部变量表中的引用，直接指向堆中的实例，在对象实例中有类型指针，指向的是方法区中的对象类型数据","link":"/2020/10/16/%E5%B0%9A%E7%A1%85%E8%B0%B7JVM/%E7%AC%AC%E5%8D%81%E7%AB%A0_%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/"},{"title":"尚硅谷JVM&#x2F;第十六章_垃圾回收相关概念","text":"垃圾回收相关概念System.gc() 的理解 在默认情况下，通过 System.gc() 者 Runtime.getRuntime().gc() 的调用，会显式触发 Full GC，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。 然而 System.gc() 调用附带一个免责声明，无法保证对垃圾收集器的调用。(不能确保立即生效) JVM 实现者可以通过 System.gc() 调用来决定 JVM 的 GC 行为。而一般情况下，垃圾回收应该是自动进行的，无须手动触发，否则就太过于麻烦了。在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用 System.gc() 代码演示是否出发GC操作 1234567891011121314public class SystemGCTest { public static void main(String[] args) { new SystemGCTest(); // 提醒 JVM 进行垃圾回收 System.gc(); //System.runFinalization(); } @Override protected void finalize() throws Throwable { super.finalize(); System.out.println(\"SystemGCTest 执行了 finalize方法\"); }} 运行结果，但是不一定会触发销毁的方法，调用 System.runFinalization() 会强制调用失去引用对象的 finalize() 1SystemGCTest 执行了 finalize方法 手动 GC 来理解不可达对象的回收代码如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class LocalVarGC { /** * 触发Minor GC没有回收对象，然后在触发Full GC将该对象存入old区 */ public void localvarGC1() { byte[] buffer = new byte[10*1024*1024]; System.gc(); } /** * 触发YoungGC的时候，已经被回收了 */ public void localvarGC2() { byte[] buffer = new byte[10*1024*1024]; buffer = null; System.gc(); } /** * 不会被回收，因为它还存放在局部变量表索引为1的槽中 */ public void localvarGC3() { { byte[] buffer = new byte[10*1024*1024]; } System.gc(); } /** * 会被回收，因为它还存放在局部变量表索引为1的槽中，但是后面定义的value把这个槽给替换了 */ public void localvarGC4() { { byte[] buffer = new byte[10*1024*1024]; } int value = 10; System.gc(); } /** * localvarGC5中的数组已经被回收 */ public void localvarGC5() { localvarGC1(); System.gc(); } public static void main(String[] args) { LocalVarGC localVarGC = new LocalVarGC(); localVarGC.localvarGC3(); }} 内存溢出内存溢出相对于内存泄漏来说，尽管更容易被理解，但是同样的，内存溢出也是引发程序崩溃的罪魁祸首之一。 由于 GC 一直在发展，所有一般情况下，除非应用程序占用的内存增长速度非常快，造成垃圾回收已经跟不上内存消耗的速度，否则不太容易出现 OOM 的情况。 大多数情况下，GC 会进行各种年龄段的垃圾回收，实在不行了就放大招，来一次独占式的 Full GC 操作，这时候会回收大量的内存，供应用程序继续使用。 javadoc 中对 OutOfMemoryError 的解释是，没有空闲内存，并且垃圾收集器也无法提供更多内存。 首先说没有空闲内存的情况：说明 Java 虚拟机的堆内存不够。原因有二： Java 虚拟机的堆内存设置不够。 比如：可能存在内存泄漏问题；也很有可能就是堆的大小不合理，比如我们要处理比较可观的数据量，但是没有显式指定 JVM 堆大小或者指定数值偏小。我们可以通过参数 -Xms 、-Xmx 来调整。 代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用） 对于老版本的 Oracle JDK，因为永久代的大小是有限的，并且 JVM 对永久代垃圾回收（如，常量池回收、卸载不再需要的类型）非常不积极，所以当我们不断添加新类型的时候，永久代出现 OutOfMemoryError 也非常多见，尤其是在运行时存在大量动态类型生成的场合；类似 intern 字符串缓存占用太多空间，也会导致 OOM 问题。对应的异常信息，会标记出来和永久代相关：“java.lang.OutOfMemoryError:PermGen space”。 随着元数据区的引入，方法区内存已经不再那么窘迫，所以相应的 OOM 有所改观，出现 OOM，异常信息则变成了：“java.lang.OutOfMemoryError:Metaspace”。直接内存不足，也会导致 OOM。 这里面隐含着一层意思是，在抛出 OutOfMemoryError 之前，通常垃圾收集器会被触发，尽其所能去清理出空间。 例如：在引用机制分析中，涉及到 JVM 会去尝试回收软引用指向的对象等。 在 java.nio.BIts.reserveMemory() 方法中，我们能清楚的看到，System.gc() 会被调用，以清理空间。 当然，也不是在任何情况下垃圾收集器都会被触发的 比如，我们去分配一个超大对象，类似一个超大数组超过堆的最大值，JVM 可以判断出垃圾收集并不能解决这个问题，所以直接抛出 OutOfMemoryError。 内存泄漏也称作“存储渗漏”。严格来说，只有对象不会再被程序用到了，但是 GC 又不能回收他们的情况，才叫内存泄漏。 但实际情况很多时候一些不太好的实践（或疏忽）会导致对象的生命周期变得很长甚至导致 OOM，也可以叫做宽泛意义上的“内存泄漏”。 尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现 OutOfMemory 异常，导致程序崩溃。 注意，这里的存储空间并不是指物理内存，而是指虚拟内存大小，这个虚拟内存大小取决于磁盘交换区设定的大小。 买房子：80平的房子，但是有10平是公摊的面积，我们是无法使用这10平的空间，这就是所谓的内存泄漏 Java 使用可达性分析算法，最上面的数据不可达，就是需要被回收的。后期有一些对象不用了，按道理应该断开引用，但是存在一些链没有断开，从而导致没有办法被回收。 举例 单例模式 单例的生命周期和应用程序是一样长的，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生。 一些提供 close 的资源未关闭导致内存泄漏 数据库连接（dataSourse.getConnection() ），网络连接（Socket）和 IO 连接必须手动 close，否则是不能被回收的。 Stop The World Stop-The-World，简称 STW，指的是 GC 事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为 STW。 可达性分析算法中枚举根节点（GC Roots）会导致所有 Java 执行线程停顿。 分析工作必须在一个能确保一致性的快照中进行 一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上 如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证 被 STW 中断的应用程序线程会在完成 GC 之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡带一样，所以我们需要减少 STW 的发生。 STW 事件和采用哪款 GC 无关所有的GC都有这个事件。 哪怕是 G1 也不能完全避免 Stop-The-World 情况发生，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能地缩短了暂停时间。 STW 是 JVM 在后台自动发起和自动完成的。在用户不可见的情况下，把用户正常的工作线程全部停掉。 开发中不要用 System.gc() 会导致 Stop-The-World 的发生。 垃圾回收的并行与并发并发在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理器上运行。 并发不是真正意义上的“同时进行”，只是 CPU 把一个时间段划分成几个时间片段（时间区间），然后在这几个时间区间之间来回切换，由于 CPU 处理的速度非常快，只要时间间隔处理得当，即可让用户感觉是多个应用程序同时在进行。 并行当系统有一个以上 CPU 时，当一个 CPU 执行一个进程时，另一个 CPU 可以执行另一个进程，两个进程互不抢占CPU 资源，可以同时进行，我们称之为并行（Parallel）。 其实决定并行的因素不是 CPU 的数量，而是 CPU 的核心数量，比如一个 CPU 多个核也可以并行。 适合科学计算，后台处理等弱交互场景 并发和并行对比并发，指的是多个事情，在同一时间段内同时发生了。 并行，指的是多个事情，在同一时间点上同时发生了。 并发的多个任务之间是互相抢占资源的。并行的多个任务之间是不互相抢占资源的。 只有在多 CPU 或者一个 CPU 多核的情况中，才会发生并行。 否则，看似同时发生的事情，其实都是并发执行的。 垃圾回收的并行与并发并发和并行，在谈论垃圾收集器的上下文语境中，它们可以解释如下： 并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。如 ParNew、Parallel Scavenge、Parallel Old； 串行（Serial） 相较于并行的概念，单线程执行。 如果内存不够，则程序暂停，启动 JVM 垃圾回收器进行垃圾回收。回收完，再启动程序的线程。 并发和并行，在谈论垃圾收集器的上下文语境中，它们可以解释如下： 并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），垃圾回收线程在执行时不会停顿用户程序的运行。 用户程序在继续运行，而垃圾收集程序线程运行于另一个CPU上 如：CMS、G1 安全点与安全区域安全点程序执行时并非在所有地方都能停顿下来开始 GC，只有在特定的位置才能停顿下来开始 GC，这些位置称为“安全点（SafePoint）”。 SafePoint 的选择很重要，如果太少可能导致 GC 等待的时间太长，如果太频繁可能导致运行时的性能问题。大部分指令的执行时间都非常短暂，通常会根据“是否具有让程序长时间执行的特征”为标准。比如：选择一些执行时间较长的指令作为 Safe Point，如方法调用、循环跳转和异常跳转等。 如何在 GC 发生时，检查所有线程都跑到最近的安全点停顿下来呢？ 抢先式中断：（目前没有虚拟机采用了）首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。 主动式中断：设置一个中断标志，各个线程运行到Safe Point的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。（有轮询的机制） 安全区域SafePoint 机制保证了程序执行时，在不太长的时间内就会遇到可进入 GC 的 SafePoint。但是，程序“不执行”的时候呢？例如线程处于 Sleep 状态或 Blocked 状态，这时候线程无法响应 JVM 的中断请求，“走”到安全点去中断挂起，JVM 也不太可能等待线程被唤醒。对于这种情况，就需要安全区域（Safe Region）来解决。 安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始 GC 都是安全的。我们也可以把 Safe Region 看做是被扩展了的 SafePoint。 执行流程： 当线程运行到 Safe Region 的代码时，首先标识已经进入了 Safe Relgion，如果这段时间内发生 GC，JVM 会忽略标识为 Safe Region 状态的线程 当线程即将离开 Safe Region 时，会检查JVM是否已经完成 GC，如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开 Safe Region 的信号为止； 再谈引用我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存中；如果内存空间在进行垃圾收集后还是很紧张，则可以抛弃这些对象。 【既偏门又非常高频的面试题】强引用、软引用、弱引用、虚引用有什么区别？具体使用场景是什么？在 JDK 1.2 版之后，Java 对引用的概念进行了扩充，将引用分为： 强引用（Strong Reference） 软引用（Soft Reference） 弱引用（Weak Reference） 虚引用（Phantom Reference） 这4种引用强度依次逐渐减弱。除强引用外，其他3种引用均可以在 java.lang.ref 包中找到它们的身影。如下图，显示了这3种引用类型对应的类，开发人员可以在应用程序中直接使用它们。 . Reference 子类中只有终结器引用是包内可见的，其他3种引用类型均为 public，可以在应用程序中直接使用 强引用（StrongReference）：最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似 “Object obj = new Object() “ 这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。 软引用（SoftReference）：在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存流出异常。 弱引用（WeakReference）：被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。 虚引用（PhantomReference）：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。 再谈引用：强引用在 Java 程序中，最常见的引用类型是强引用（普通系统99%以上都是强引用），也就是我们最常见的普通对象引用，也是默认的引用类型。 当在 Java 语言中使用 new 操作符创建一个新的对象，并将其赋值给一个变量的时候，这个变量就成为指向该对象的一个强引用。 强引用的对象是可触及的，垃圾收集器就永远不会回收掉被引用的对象。 对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为null，就是可以当做垃圾被收集了，当然具体回收时机还是要看垃圾收集策略。 相对的，软引用、弱引用和虚引用的对象是软可触及、弱可触及和虚可触及的，在一定条件下，都是可以被回收的。所以，强引用是造成 Java 内存泄漏的主要原因之一。 举例强引用的案例说明 1StringBuffer str = new StringBuffer(\"hello mogublog\"); 局部变量 str 指向 StringBuffer 实例所在堆空间，通过 str 可以操作该实例，那么 str 就是 StringBuffer 实例的强引用对应内存结构： 如果此时，在运行一个赋值语句 12StringBuffer str = new StringBuffer(\"hello mogublog\");StringBuffer str1 = str; 对应的内存结构为: 那么我们将 str = null; 则 原来堆中的对象也不会被回收，因为还有其它对象指向该区域 总结本例中的两个引用，都是强引用，强引用具备以下特点： 强引用可以直接访问目标对象。 强引用所指向的对象在任何时候都不会被系统回收，虚拟机宁愿抛出 OOM 异常，也不会回收强引用所指向对象。 强引用可能导致内存泄漏。 再谈引用： 软引用软引用是用来描述一些还有用，但非必需的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。 注意，这里的第一次回收是不可达的对象 软引用通常用来实现内存敏感的缓存。比如：高速缓存就有用到软引用。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。 垃圾回收器在某个时刻决定回收软可达的对象的时候，会清理软引用，并可选地把引用存放到一个引用队列（Reference Queue）。 类似弱引用，只不过 Java 虚拟机会尽量让软引用的存活时间长一些，迫不得已才清理。 一句话概括：当内存足够时，不会回收软引用可达的对象。内存不够时，会回收软引用的可达对象 在 JDK 1.2 版之后提供了 SoftReference 类来实现软引用 12345// 声明强引用Object obj = new Object();// 创建一个软引用SoftReference&lt;Object&gt; sf = new SoftReference&lt;&gt;(obj);obj = null; //销毁强引用，这是必须的，不然会存在强引用和软引用 再谈引用：弱引用 发现即回收 弱引用也是用来描述那些非必需对象，只被弱引用关联的对象只能生存到下一次垃圾收集发生为止。在系统 GC时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象。 但是，由于垃圾回收器的线程通常优先级很低，因此，并不一定能很快地发现持有弱引用的对象。在这种情况下，弱引用对象可以存在较长的时间。 弱引用和软引用一样，在构造弱引用时，也可以指定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况。 软引用、弱引用都非常适合来保存那些可有可无的缓存数据。如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用。 在 JDK 1.2 版之后提供了 WeakReference 类来实现弱引用 12345// 声明强引用Object obj = new Object();// 创建一个弱引用WeakReference&lt;Object&gt; sf = new WeakReference&lt;&gt;(obj);obj = null; //销毁强引用，这是必须的，不然会存在强引用和弱引用 弱引用对象与软引用对象的最大不同就在于，当 GC 在进行回收时，需要通过算法检查是否回收软引用对象，而对于弱引用对象，GC 总是进行回收。弱引用对象更容易、更快被 GC 回收。 面试题：你开发中使用过 WeakHashMap 吗？ WeakHashMap 用来存储图片信息，可以在内存不足的时候，及时回收，避免了 OOM 再谈引用：虚引用也称为“幽灵引用”或者“幻影引用”，是所有引用类型中最弱的一个 一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收 它不能单独使用，也无法通过虚引用来获取被引用的对象。当试图通过虚引用的 get() 方法取得对象时，总是 null 为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如：能在这个对象被收集器回收时收到一个系统通知 虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况 由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录。 虚引用无法获取到我们的数据 在 JDK 1.2 版之后提供了 PhantomReference 类来实现虚引用。 1234567// 声明强引用Object obj = new Object();// 声明引用队列ReferenceQueue phantomQueue = new ReferenceQueue();// 声明虚引用（还需要传入引用队列）PhantomReference&lt;Object&gt; sf = new PhantomReference&lt;&gt;(obj, phantomQueue);obj = null; 案例我们使用一个案例，来结合虚引用，引用队列，finalize 进行讲解 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class PhantomReferenceTest { // 当前类对象的声明 public static PhantomReferenceTest obj; // 引用队列 static ReferenceQueue&lt;PhantomReferenceTest&gt; phantomQueue = null; @Override protected void finalize() throws Throwable { super.finalize(); System.out.println(\"调用当前类的finalize方法\"); obj = this; } public static void main(String[] args) { Thread thread = new Thread(() -&gt; { while(true) { if (phantomQueue != null) { PhantomReference&lt;PhantomReferenceTest&gt; objt = null; try { objt = (PhantomReference&lt;PhantomReferenceTest&gt;) phantomQueue.remove(); } catch (Exception e) { e.getStackTrace(); } if (objt != null) { System.out.println(\"追踪垃圾回收过程：PhantomReferenceTest实例被GC了\"); } } } }, \"t1\"); thread.setDaemon(true); thread.start(); phantomQueue = new ReferenceQueue&lt;&gt;(); obj = new PhantomReferenceTest(); // 构造了PhantomReferenceTest对象的虚引用，并指定了引用队列 PhantomReference&lt;PhantomReferenceTest&gt; phantomReference = new PhantomReference&lt;&gt;(obj, phantomQueue); try { System.out.println(phantomReference.get()); // 去除强引用 obj = null; // 第一次进行GC，由于对象可复活，GC无法回收该对象 System.out.println(\"第一次GC操作\"); System.gc(); Thread.sleep(1000); if (obj == null) { System.out.println(\"obj 是 null\"); } else { System.out.println(\"obj 不是 null\"); } System.out.println(\"第二次GC操作\"); obj = null; System.gc(); Thread.sleep(1000); if (obj == null) { System.out.println(\"obj 是 null\"); } else { System.out.println(\"obj 不是 null\"); } } catch (Exception e) { e.printStackTrace(); } finally { } }} 最后运行结果 1234567null第一次GC操作调用当前类的finalize方法obj 不是 null第二次GC操作追踪垃圾回收过程：PhantomReferenceTest实例被GC了obj 是 null 从上述运行结果我们知道，第一次尝试获取虚引用的值，发现无法获取的，这是因为虚引用是无法直接获取对象的值，然后进行第一次 GC，因为会调用 finalize() 方法，将对象复活了，所以对象没有被回收，但是调用第二次 GC 操作的时候，因为 finalize() 方法只能执行一次，所以就触发了 GC 操作，将对象回收了，同时将会触发第二个操作就是 将回收的值存入到引用队列中。 终结器引用它用于实现对象的 finalize() 方法，也可以称为终结器引用 无需手动编码，其内部配合引用队列使用 在 GC 时，终结器引用入队。由 Finalizer 线程通过终结器引用找到被引用对象调用它的 finalize() 方法，第二次 GC 时才回收被引用的对象","link":"/2020/10/25/%E5%B0%9A%E7%A1%85%E8%B0%B7JVM/%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"title":"尚硅谷JVM&#x2F;第十七章_垃圾回收器","text":"垃圾回收器GC分类与性能指标 垃圾收集器没有在规范中进行过多的规定，可以由不同的厂商、不同版本的 JVM 来实现。 由于 JDK 的版本处于高速迭代过程中，因此 Java 发展至今已经衍生了众多的 GC 版本。 从不同角度分析垃圾收集器，可以将 GC 分为不同的类型。 Java 不同版本新特性 语法层面：Lambda 表达式、switch、自动拆箱装箱、enum API 层面：Stream API、新的日期时间、Optional、String、集合框架 底层优化：JVM 优化、GC 的变化、元空间、静态域、字符串常量池位置变化 垃圾收集器分类按线程数分按线程数分（垃圾回收线程数），可以分为串行垃圾回收器和并行垃圾回收器。 串行回收指的是在同一时间段内只允许有一个 CPU 用于执行垃圾回收操作，此时工作线程被暂停，直至垃圾收集工作结束。 在诸如单 CPU 处理器或者较小的应用内存等硬件平台不是特别优越的场合，串行回收器的性能表现可以超过并行回收器和并发回收器。所以，串行回收默认被应用在客户端的 Client 模式下的 JVM 中 在并发能力比较强的 CPU 上，并行回收器产生的停顿时间要短于串行回收器。 和串行回收相反，并行收集可以运用多个 CPU 同时执行垃圾回收，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用了“Stop-The-World”机制。 按工作模式分按照工作模式分，可以分为并发式垃圾回收器和独占式垃圾回收器。 并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间。 独占式垃圾回收器（Stop The World）一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束。 按碎片处理方式分按碎片处理方式分，可分为压缩式垃圾回收器和非压缩式垃圾回收器。 压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片。 非压缩式的垃圾回收器不进行这步操作。 按工作的内存区间分按工作的内存区间分，又可分为年轻代垃圾回收器和老年代垃圾回收器。 评估GC的性能指标 吞吐量：运行用户代码的时间占总运行时间的比例（总运行时间 = 程序的运行时间 + 内存回收的时间） 垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。 暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间。 收集频率：相对于应用程序的执行，收集操作发生的频率。 内存占用：Java 堆区所占的内存大小。 快速：一个对象从诞生到被回收所经历的时间。 吞吐量、暂停时间、内存占用 这三者共同构成一个“不可能三角”。三者总体的表现会随着技术进步而越来越好。一款优秀的收集器通常最多同时满足其中的两项。这三项里，暂停时间的重要性日益凸显。因为随着硬件发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量。而内存的扩大，对延迟反而带来负面效果。简单来说，主要抓住两点： 吞吐量 暂停时间 评估 GC 的性能指标：吞吐量(Throughput)吞吐量就是 CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值，即吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间） 比如：虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。 这种情况下，应用程序能容忍较高的暂停时间，因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的 吞吐量优先，意味着在单位时间内，STW 的时间最短：0.2 + 0.2 = 0.4 评估 GC 的性能指标：暂停时间“暂停时间”是指一个时间段内应用程序线程暂停，让 GC 线程执行的状态 例如，GC 期间100毫秒的暂停时间意味着在这100毫秒期间内没有应用程序线程是活动的。 暂停时间优先，意味着尽可能让单次 STW 的时间最短：0.1 + 0.1 + 0.1 + 0.1 + 0.1 = 0.5 吞吐量 vs 暂停时间高吞吐量较好因为这会让应用程序的最终用户感觉只有应用程序线程在做“生产性”工作。直觉上，吞吐量越高程序运行越快。 低暂停时间（低延迟）较好因为从最终用户的角度来看不管是 GC 还是其他原因导致一个应用被挂起始终是不好的。这取决于应用程序的类型，有时候甚至短暂的200毫秒暂停都可能打断终端用户体验。因此，具有低的较大暂停时间是非常重要的，特别是对于一个交互式应用程序。 不幸的是”高吞吐量”和”低暂停时间”是一对相互竞争的目标（矛盾）。 因为如果选择以吞吐量优先，那么必然需要降低内存回收的执行频率，但是这样会导致 GC 需要更长的暂停时间来执行内存回收。 相反的，如果选择以低延迟优先为原则，那么为了降低每次执行内存回收时的暂停时间，也只能频繁地执行内存回收，但这又引起了年轻代内存的缩减和导致程序吞吐量的下降。 在设计（或使用）GC 算法时，我们必须确定我们的目标：一个 GC 算法只可能针对两个目标之一（即只专注于较大吞吐量或最小暂停时间），或尝试找到一个二者的折衷。 现在标准：在最大吞吐量优先的情况下，降低停顿时间 不同的垃圾回收器概述垃圾收集机制是 Java 的招牌能力，极大地提高了开发效率。这当然也是面试的热点。 那么，Java常见的垃圾收集器有哪些？ GC垃圾收集器是和JVM一脉相承的，它是和JVM进行搭配使用，在不同的使用场景对应的收集器也是有区别 垃圾回收器发展史有了虚拟机，就一定需要收集垃圾的机制，这就是 Garbage Collection，对应的产品我们称为 Garbage Collector。 1999年随 JDK 1.3.1 一起来的是串行方式的 Serial GC ，它是第一款 GC。ParNew 垃圾收集器是 Serial 收集器的多线程版本 2002年2月26日，Parallel GC 和 Concurrent Mark Sweep GC 跟随 JDK 1.4.2 一起发布· Parallel GC 在 JDK 6 之后成为 HotSpot 默认 GC。 2012年，在 JDK 1.7u4 版本中，G1 可用。 2017年，JDK 9 中 G1 变成默认的垃圾收集器，以替代 CMS。 2018年3月，JDK 10 中 G1 垃圾回收器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟。 2018年9月，JDK 11 发布。引入 Epsilon 垃圾回收器，又被称为 “No-Op(无操作)“ 回收器。同时，引入ZGC：可伸缩的低延迟垃圾回收器（Experimental） 2019年3月，JDK 12 发布。增强 G1，自动返回未用堆内存给操作系统。同时，引入 Shenandoah GC：低停顿时间的GC（Experimental）。 2019年9月，JDK 13 发布。增强 ZGC，自动返回未用堆内存给操作系统。 2020年3月，JDK 14 发布。删除 CMS 垃圾回收器。扩展 ZGC 在 macOS 和 Windows 上的应用 7种经典的垃圾收集器 串行回收器：Serial、Serial Old 并行回收器：ParNew、Parallel Scavenge、Parallel Old 并发回收器：CMS、G11 7款经典收集器与垃圾分代之间的关系 新生代收集器：Serial、ParNew、Parallel Scavenge； 老年代收集器：Serial Old、Parallel Old、CMS； 整堆收集器：G1； 垃圾收集器的组合关系 两个收集器间有连线，表明它们可以搭配使用：Serial/Serial Old、Serial/CMS、ParNew/Serial Old、ParNew/CMS、Parallel Scavenge/Serial Old、Parallel Scavenge/Parallel Old、G1； 其中 Serial Old 作为 CMS 出现”Concurrent Mode Failure”失败的后备预案。 （红色虚线）由于维护和兼容性测试的成本，在 JDK 8 时将 Serial+CMS、ParNew+Serial Old 这两个组合声明为废弃（JEP173），并在 JDK 9 中完全取消了这些组合的支持（JEP214），即：移除。 （绿色虚线）JDK 14 中：弃用 Parallel Scavenge 和 Serialold GC 组合（JEP366） （青色虚线）JDK 14 中：删除 CMS 垃圾回收器（JEP363） 为什么 CMS GC 不可以和 Parallel Scavenge GC 搭配使用？ 答：Parallel Scavenge GC 底层框架和其他垃圾回收器不同 为什么要有很多收集器，一个不够吗？因为 Java 的使用场景很多，移动端，服务器等。所以就需要针对不同的场景，提供不同的垃圾收集器，提高垃圾收集的性能。 虽然我们会对各个收集器进行比较，但并非为了挑选一个最好的收集器出来。没有一种放之四海皆准、任何场景下都适用的完美收集器存在，更加没有万能的收集器。所以我们选择的只是对具体应用最合适的收集器。 如何查看默认垃圾收集器-XX:+PrintCommandLineFlags：查看命令行相关参数（包含使用的垃圾收集器） 使用命令行指令：jinfo -flag 相关垃圾回收器参数 进程 ID Serial 回收器：串行回收Serial 收集器是最基本、历史最悠久的垃圾收集器了。JDK 1.3 之前回收新生代唯一的选择。 Serial 收集器作为 HotSpot 中 Client 模式下的默认新生代垃圾收集器。 Serial 收集器采用复制算法、串行回收和”Stop-The-World”机制的方式执行内存回收。 除了年轻代之外，Serial 收集器还提供用于执行老年代垃圾收集的 Serial Old 收集器。Serial Old 收集器同样也采用了串行回收和”Stop The World”机制，只不过内存回收算法使用的是标记-压缩算法。 Serial Old 是运行在 Client 模式下默认的老年代的垃圾回收器 Serial Old 在 Server 模式下主要有两个用途： 与新生代的 Parallel Scavenge 配合使用 作为老年代 CMS 收集器的后备垃圾收集方案 这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它只会使用一个 CPU 或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束（Stop The World） 优势：简单而高效（与其他收集器的单线程比），对于限定单个 CPU 的环境来说，Serial 收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。 运行在 Client 模式下的虚拟机是个不错的选择。 在用户的桌面应用场景中，可用内存一般不大（几十 MB 至一两百 MB），可以在较短时间内完成垃圾收集（几十 ms 至一百多 ms），只要不频繁发生，使用串行回收器是可以接受的。 在 HotSpot 虚拟机中，使用 -XX：+UseSerialGC 参数可以指定年轻代和老年代都使用串行收集器。 等价于新生代用 Serial GC，且老年代用 Serial Old GC 总结这种垃圾收集器大家了解，现在已经不用串行的了。而且在限定单核 CPU 才可以用。现在都不是单核的了。 对于交互较强的应用而言，这种垃圾收集器是不能接受的。一般在 Java web 应用程序中是不会采用串行垃圾收集器的。 ParNew 回收器：并行回收如果说 Serial GC 是年轻代中的单线程垃圾收集器，那么 ParNew 收集器则是 Serial 收集器的多线程版本。 Par 是 Parallel 的缩写，New：只能处理的是新生代 ParNew 收集器除了采用并行回收的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。ParNew 收集器在年轻代中同样也是采用复制算法、”Stop-The-World”机制。 ParNew 是很多 JVM 运行在 Server 模式下新生代的默认垃圾收集器。 对于新生代，回收次数频繁，使用并行方式高效。 对于老年代，回收次数少，使用串行方式节省资源。（CPU 并行需要切换线程，串行可以省去切换线程的资源） 由于 ParNew 收集器是基于并行回收，那么是否可以断定 ParNew 收集器的回收效率在任何场景下都会比 Serial收集器更高效？ ParNew 收集器运行在多 CPU 的环境下，由于可以充分利用多 CPU、多核心等物理硬件资源优势，可以更快速地完成垃圾收集，提升程序的吞吐量 但是在单个 CPU 的环境下，ParNew 收集器不比 Serial 收集器更高效。虽然 Serial 收集器是基于串行回收，但是由于 CPU 不需要频繁得做任务切换，因此可以有效避免多线程交互过程中产生的一些额外开销 除 Serial Old GC 外，目前只有 ParNew GC 能与 CMS 收集器配合工作（JDK 8 中 Serial Old GC 移除对 ParNew GC 的支持，JDK 9 版本中已经明确提示 UserParNewGC was deprecated，将在后续版本中被移除，JDK 14中移除 CMS GC） 在程序中，开发人员可以通过选项”-XX：+UseParNewGC”手动指定使用 ParNew 收集器执行内存回收任务。它表示年轻代使用并行收集器，不影响老年代。 -XX:ParallelGCThreads 限制线程数量，默认开启和 CPU 数据相同的线程数。 Parallel 回收器：吞吐量优先HotSpot 的年轻代中除了拥有 ParNew 收集器是基于并行回收的以外，Parallel Scavenge 收集器同样也采用了复制算法、并行回收和”Stop The World”机制。 那么 Parallel 收集器的出现是否多此一举？ 和 ParNew 收集器不同，Parallel Scavenge 收集器的目标则是达到一个可控制的吞吐量（Throughput），它也被称为吞吐量优先的垃圾收集器。 自适应调节策略也是 Parallel Scavenge 与 ParNew 一个重要区别。 高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。因此，常见在服务器环境中使用。例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序。 Parallel 收集器在 JDK 1.6 时提供了用于执行老年代垃圾收集的 Parallel Old 收集器，用来代替老年代的Serial Old 收集器。 Parallel Old 收集器采用了标记-压缩算法，但同样也是基于并行回收和”Stop-The-World”机制。 在程序吞吐量优先的应用场景中，Parallel 收集器和 Parallel Old 收集器的组合，在 Server 模式下的内存回收性能很不错。在 Java 8 中，默认是此垃圾收集器。 参数配置-XX：+UseParallelGC 手动指定年轻代使用 Parallel 并行收集器执行内存回收任务。 -XX：+UseParalleloldGC 手动指定老年代都是使用并行回收收集器。 分别适用于新生代和老年代。默认 JDK 8 是开启的。 上面两个参数，默认开启一个，另一个也会被开启。（互相激活） -XX:ParallelGcrhreads设置年轻代并行收集器的线程数。一般地，最好与 CPU 数量相等，以避免过多的线程数影响垃圾收集性能。 在默认情况下，当 CPU 数量小于8个，ParallelGCThreads的值等于 CPU 数量。 当 CPU 数量大于8个，ParallelGCThreads 的值等于3+[5*CPU_Count] / 8] -XX:MaxGCPauseMillis 设置垃圾收集器最大停顿时间（即 STW 的时间）。单位是毫秒。 为了尽可能地把停顿时间控制在 MaxGCPauseMills 以内，收集器在工作时会调整 Java 堆大小或者其他一些参数。 对于用户来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合 Parallel，进行控制。该参数使用需谨慎。 -XX:GCTimeRatio 垃圾收集时间占总时间的比例（= 1 /（N+1））。用于衡量吞吐量的大小。 取值范围（0，100）。默认值99，也就是垃圾回收时间不超过1%。 与前一个 -XX:MaxGCPauseMillis 参数有一定矛盾性。暂停时间越长，Radio 参数就容易超过设定的比例。 -XX:+UseAdaptiveSizePolicy 设置 Parallel Scavenge 收集器具有自适应调节策略 在这种模式下，年轻代的大小、Eden 和 Survivor 的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点。 在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMills），让虚拟机自己完成调优工作。 CMS 回收器：低延迟在 JDK 1.5 时期，HotSpot 推出了一款在强交互应用中几乎可认为有划时代意义的垃圾收集器：CMS（Concurrent-Mark-Sweep）收集器，这款收集器是 HotSpot 虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作。 CMS 收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验。 目前很大一部分的 Java 应用集中在互联网站或者 B/S 系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS 收集器就非常符合这类应用的需求。 CMS 的垃圾收集算法采用标记-清除算法，并且也会”Stop-The-World” 不幸的是，CMS 作为老年代的收集器，却无法与 JDK 1.4.0 中已经存在的新生代收集器 Parallel Scavenge 配合工作，所以在 JDK 1.5 中使用 CMS 来收集老年代的时候，新生代只能选择 ParNew 或者 Serial 收集器中的一个。 在 G1 出现之前，CMS 使用还是非常广泛的。一直到今天，仍然有很多系统使用 CMS GC。 CMS 整个过程比之前的收集器要复杂，整个过程分为4个主要阶段，即初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段。(涉及STW的阶段主要是：初始标记 和 重新标记) 初始标记（Initial-Mark）阶段：在这个阶段中，程序中所有的工作线程都将会因为“Stop-The-World”机制而出现短暂的暂停，这个阶段的主要任务仅仅只是标记出 GC Roots 能直接关联到的对象。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的速度非常快。 并发标记（Concurrent-Mark）阶段：从 GC Roots 的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。 重新标记（Remark）阶段：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。 并发清除（Concurrent-Sweep）阶段：此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的 尽管 CMS 收集器采用的是并发回收（非独占式），但是在其初始化标记和再次标记这两个阶段中仍然需要执行“Stop-the-World”机制暂停程序中的工作线程，不过暂停时间并不会太长，因此可以说明目前所有的垃圾收集器都做不到完全不需要“stop-the-World”，只是尽可能地缩短暂停时间。 由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的。 另外，由于在垃圾收集阶段用户线程没有中断，所以在 CMS 回收过程中，还应该确保应用程序用户线程有足够的内存可用。因此，CMS 收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是当堆内存使用率达到某一阈值时，便开始进行回收，以确保应用程序在 CMS 工作过程中依然有足够的空间支持应用程序运行。要是 CMS 运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败，这时虚拟机将启动后备预案：临时启用 Serial Old 收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。 CMS 收集器的垃圾收集算法采用的是标记-清除算法，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，不可避免地将会产生一些内存碎片。那么 CMS 在为新对象分配内存空间时，将无法使用指针碰撞（Bump the Pointer）技术，而只能够选择空闲列表（Free List）执行内存分配。 CMS 为什么不使用标记整理(压缩)算法？答案其实很简答，因为当并发清除的时候，用 Compact 整理内存的话，原来的用户线程使用的内存还怎么用呢？要保证用户线程能继续执行，前提的它运行的资源不受影响。Mark Compact 更适合“Stop The World”这种场景下使用 优点 并发收集 低延迟 缺点 会产生内存碎片，导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发Full GC。 CMS 收集器对 CPU 资源非常敏感。在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。 CMS 收集器无法处理浮动垃圾。可能出现“Concurrent Mode Failure”失败而导致另一次 Full GC 的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么在并发标记阶段如果产生新的垃圾对象，CMS 将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，从而只能在下一次执行 GC 时释放这些之前未被回收的内存空间。 CMS 收集器可以设置的参数 -XX：+UseConcMarkSweepGC 手动指定使用 CMS 收集器执行内存回收任务。 开启该参数后会自动将 -XX：+UseParNewGC 打开。即：ParNew（Young区用）+ CMS（Old 区用）+Serial Old的组合。 -XX:CMSInitiatingoccupanyFraction 设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。 JDK 5 及以前版本的默认值为68，即当老年代的空间使用率达到68%时，会执行一次 CMS 回收。JDK 6 及以上版本默认值为92% 如果内存增长缓慢，则可以设置一个稍大的值，大的阀值可以有效降低 CMS 的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。因此通过该选项便可以有效降低 Full GC 的执行次数。 -XX：+UseCMSCompactAtFullCollection用于指定在执行完 Full GC 后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。 -XX:CMSFullGCsBeforecompaction 设置在执行多少次 Full GC 后对内存空间进行压缩整理。 -XX:ParallelcMSThreads 设置 CMS 的线程数量。 CMS 默认启动的线程数是（ParallelGCThreads+3）/ 4，ParallelGCThreads 是年轻代并行收集器的线程数。当 CPU 资源比较紧张时，受到 CMS 收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。 小结HotSpot 有这么多的垃圾回收器，那么如果有人问，Serial GC、Parallel GC、Concurrent Mark Sweep GC 这三个 GC 有什么不同呢？ 请记住以下口令： 如果你想要最小化地使用内存和并行开销，请选 Serial GC； 如果你想要最大化应用程序的吞吐量，请选 Parallel GC； 如果你想要最小化 GC 的中断或停顿时间，请选 CMS GC。 JDK 后续版本中 CMS 的变化JDK 9 新特性：CMS 被标记为 Deprecate 了（JEP291） 如果对 JDK 9 及以上版本的 HotSpot 虚拟机使用参数-XX：+UseConcMarkSweepGC 来开启 CMS 收集器的话，用户会收到一个警告信息，提示 CMS 未来将会被废弃。 JDK 14 新特性：删除 CMS 垃圾回收器（JEP363）移除了 CMS 垃圾收集器，如果在 JDK 14 中使用XX：+UseConcMarkSweepGC 的话，JVM 不会报错，只是给出一个 Warning 信息，但是不会 exit。JVM 会自动回退以默认 GC 方式启动 JVM OpenJDK 64-bit Server VM Warning: Ignoring option UseConcMarkSweepGC; support was removed in 14.0 and the VM will continue execution using the default collector. G1 回收器：区域化分代式既然我们已经有了前面几个强大的 GC，为什么还要发布 Garbage First（G1）？原因就在于应用程序所应对的业务越来越庞大、复杂，用户越来越多，没有 GC 就不能保证应用程序正常进行，而经常造成 STW 的 GC 又跟不上实际的需求，所以才会不断地尝试对 GC 进行优化。G1（Garbage-First）垃圾回收器是在 Java7 update 4 之后引入的一个新的垃圾回收器，是当今收集器技术发展的最前沿成果之一。 与此同时，为了适应现在不断扩大的内存和不断增加的处理器数量，进一步降低暂停时间（pause time），同时兼顾良好的吞吐量。 官方给G1设定的目标是在延迟可控的情况下获得尽可能高的吞吐量，所以才担当起“全功能收集器”的重任与期望。 为什么名字叫 Garbage First(G1) 呢？因为 G1 是一个并行回收器，它把堆内存分割为很多不相关的区域（Region）（物理上不连续的）。使用不同的Region 来表示 Eden、幸存者0区，幸存者1区，老年代等。 G1 GC 有计划地避免在整个 Java 堆中进行全区域的垃圾收集。G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。 由于这种方式的侧重点在于回收垃圾最大量的区间（Region），所以我们给 G1 一个名字：垃圾优先（Garbage First）。 G1（Garbage-First）是一款面向服务端应用的垃圾收集器，主要针对配备多核 CPU 及大容量内存的机器，以极高概率满足 GC 停顿时间的同时，还兼具高吞吐量的性能特征。 在 JDK 1.7 版本正式启用，移除了 Experimental 的标识，是 JDK 9 以后的默认垃圾回收器，取代了 CMS 回收器以及 Parallel + Parallel Old 组合。被 Oracel 官方称为“全功能的垃圾收集器”。 与此同时，CMS 已经在 JDK 9 中被标记为废弃（deprecated）。在 JDK 8 中还不是默认的垃圾回收器，需要使用 -XX：+UseG1GC 来启用。 G1 垃圾收集器的优点与其他 GC 收集器相比，G1 使用了全新的分区算法，其特点如下所示： 并行与并发 并行性：G1 在回收期间，可以有多个 GC 线程同时工作，有效利用多核计算能力。此时用户线程 STW 并发性：G1 拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况 分代收集 从分代上看，G1 依然属于分代型垃圾回收器，它会区分年轻代和老年代，年轻代依然有 Eden 区和 Survivor 区。但从堆的结构上看，它不要求整个 Eden 区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。 将堆空间分为若干个区域（Region），这些区域中包含了逻辑上的年轻代和老年代。 和之前的各类回收器不同，它同时兼顾年轻代和老年代。对比其他回收器，或者工作在年轻代，或者工作在老年代； G1 所谓的分代，已经不是下面这样的了 而是这样的一个区域 空间整合 CMS：“标记-清除”算法、内存碎片、若干次 GC 后进行一次碎片整理 G1 将内存划分为一个个的 Region。内存的回收是以 Region 作为基本单位的。Region 之间是复制算法，但整体上实际可看作是标记-压缩（Mark-Compact）算法，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次 GC。尤其是当 Java 堆非常大的时候，G1 的优势更加明显。 可预测的停顿时间模型（即：软实时 Soft Real-Time）这是 G1 相对于 CMS 的另一大优势，G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。 由于分区的原因，G1 可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。 G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region 。保证了 G1 收集器在有限的时间内可以获取尽可能高的收集效率。 相比于 CMS GC，G1 未必能做到 CMS 在最好情况下的延时停顿，但是最差情况要好很多。 G1 垃圾收集器的缺点相较于 CMS，G1 还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1 无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（Overload）都要比 CMS 要高。 从经验上来说，在小内存应用上 CMS 的表现大概率会优于 G1，而 G1 在大内存应用上则发挥其优势。平衡点在6-8GB 之间。 G1 参数设置 -XX:+UseG1GC：手动指定使用 G1 垃圾收集器执行内存回收任务 -XX:G1HeapRegionSize：设置每个 Region 的大小。值是2的幂，范围是 1MB 到 32MB 之间，目标是根据最小的 Java 堆大小划分出约2048个区域。默认是堆内存的1/2000。 -XX:MaxGCPauseMillis：设置期望达到的最大 GC 停顿时间指标（JVM 会尽力实现，但不保证达到）。默认值是200ms -XX:+ParallelGcThread：设置 STW 工作线程数的值。最多设置为8 -XX:ConcGCThreads：设置并发标记的线程数。将n设置为并行垃圾回收线程数（ParallelGCThreads）的1/4左右。 -XX:InitiatingHeapOccupancyPercent：设置触发并发 GC 周期的 Java 堆占用率阈值。超过此值，就触发GC。默认值是45。 G1 收集器的常见操作步骤G1 的设计原则就是简化 JVM 性能调优，开发人员只需要简单的三步即可完成调优： 第一步：开启 G1 垃圾收集器 第二步：设置堆的最大内存 第三步：设置最大的停顿时间 G1 中提供了三种垃圾回收模式：YoungGC、Mixed GC 和Full GC，在不同的条件下被触发。 G1 收集器的适用场景面向服务端应用，针对具有大内存、多处理器的机器。（在普通大小的堆里表现并不惊喜） 最主要的应用是需要低 GC 延迟，并具有大堆的应用程序提供解决方案； 如：在堆大小约 6GB 或更大时，可预测的暂停时间可以低于0.5秒；（G1 通过每次只清理一部分而不是全部的Region 的增量式清理来保证每次 GC 停顿时间不会过长）。用来替换掉 JDK 1.5 中的 CMS 收集器；在下面的情况时，使用 G1 可能比 CMS 好： 超过50%的 Java 堆被活动数据占用； 对象分配频率或年代提升频率变化很大； GC 停顿时间过长（长于0.5至1秒） HotSpot 垃圾收集器里，除了 G1 以外，其他的垃圾收集器使用内置的 JVM 线程执行 GC 的多线程操作，而 G1 GC 可以采用应用线程承担后台运行的 GC 工作，即当 JVM 的 GC 线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程。 分区 Region：化整为零使用 G1 收集器时，它将整个 Java 堆划分成约2048个大小相同的独立 Region 块，每个 Region 块大小根据堆空间的实际大小而定，整体被控制在 1MB 到 32MB 之间，且为2的N次幂，即1MB，2MB，4MB，8MB，16MB，32MB。可以通过 -XX:G1HeapRegionSize设定。所有的 Region 大小相同，且在 JVM 生命周期内不会被改变。 虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分 Region（不需要连续）的集合。通过 Region 的动态分配方式实现逻辑上的连续。 一个 Region 有可能属于 Eden，Survivor 或者 Old/Tenured 内存区域。但是一个 Region 只可能属于一个角色。图中的 E 表示该 Region 属于 Eden 内存区域，S 表示属于 Survivor 内存区域，O 表示属于 Old 内存区域。图中空白的表示未使用的内存空间。 G1 垃圾收集器还增加了一种新的内存区域，叫做 Humongous 内存区域，如图中的 H 块。主要用于存储大对象，如果超过 1.5 个 Region，就放到 H。 设置H的原因：对于堆中的对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象就会对垃圾收集器造成负面影响。为了解决这个问题，G1 划分了一个 Humongous 区，它用来专门存放大对象。如果一个H 区装不下一个大对象，那么 G1 会寻找连续的 H 区来存储。为了能找到连续的 H 区，有时候不得不启动Full GC。G1 的大多数行为都把 H 区作为老年代的一部分来看待。 每个 Region 都是通过指针碰撞来分配空间 G1 垃圾回收器的回收过程G1 GC 的垃圾回收过程主要包括如下三个环节： 年轻代 GC（Young GC） 老年代并发标记过程（Concurrent Marking） 混合回收（Mixed GC） （如果需要，单线程、独占式、高强度的 Full GC 还是继续存在的。它针对 GC 的评估失败提供了一种失败保护机制，即强力回收。） 顺时针，Young GC -&gt; Young GC + Concurrent Mark -&gt; Mixed GC 顺序，进行垃圾回收。 应用程序分配内存，当年轻代的 Eden 区用尽时开始年轻代回收过程；G1 的年轻代收集阶段是一个并行的独占式收集器。在年轻代回收期，G1 GC 暂停所有应用程序线程，启动多线程执行年轻代回收。然后从年轻代区间移动存活对象到 Survivor 区间或者老年区间，也有可能是两个区间都会涉及。 当堆内存使用达到一定值（默认45%）时，开始老年代并发标记过程。 标记完成马上开始混合回收过程。对于一个混合回收期，G1 GC 从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的 G1 回收器和其他 GC 不同，G1 的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一小部分老年代的 Region 就可以了。同时，这个老年代 Region 是和年轻代一起被回收的。 举个例子：一个 Web 服务器，Java 进程最大堆内存为4G，每分钟响应1500个请求，每45秒钟会新分配大约2G的内存。G1 会每45秒钟进行一次年轻代回收，每31个小时整个堆的使用率会达到45%，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收。 Remembered Set（记忆集）一个对象被不同区域引用的问题 一个 Region 不可能是孤立的，一个 Region 中的对象可能被其他任意 Region 中对象引用，判断对象存活时，是否需要扫描整个 Java 堆才能保证准确？ 在其他的分代收集器，也存在这样的问题（而 G1 更突出）回收新生代也不得不同时扫描老年代？这样的话会降低 Minor GC 的效率； 解决方法： 无论 G1 还是其他分代收集器，JVM 都是使用 Remembered Set 来避免全局扫描： 每个 Region 都有一个对应的 Remembered Set ；每次 Reference 类型数据写操作时，都会产生一个 Write Barrier 暂时中断操作； 然后检查将要写入的引用指向的对象是否和该 Reference 类型数据在不同的 Region（其他收集器：检查老年代对象是否引用了新生代对象）；如果不同，通过 CardTable 把相关引用信息记录到引用指向对象的所在 Region对应的 Remembered Set 中；当进行垃圾收集时，在 GC 根节点的枚举范围加入 Remembered Set；就可以保证不进行全局扫描，也不会有遗漏。 G1 回收过程一：年轻代 GCJVM 启动时，G1 先准备好 Eden 区，程序在运行过程中不断创建对象到 Eden 区，当 Eden 空间耗尽时，G1 会启动一次年轻代垃圾回收过程。 年轻代垃圾回收只会回收 Eden 区和 Survivor 区 首先 G1 停止应用程序的执行（Stop-The-World），G1 创建回收集（Collection Set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代 Eden 区和 Survivor 区所有的内存分段。 然后开始如下回收过程： 第一阶段，扫描根根是指 static 变量指向的对象，正在执行的方法调用链条上的局部变量等。根引用连同 RSet 记录的外部引用作为扫描存活对象的入口。 第二阶段，更新 RSet处理 Dirty Card Queue（见备注）中的 Card，更新 RSet。此阶段完成后，RSet 可以准确的反映老年代对所在的内存分段中对象的引用。 对于应用程序的引用赋值语句 object.field = object，JVM 会在之前和之后执行特殊的操作以在 Dirty Card Queue 中入队一个保存了对象引用信息的 Card。在年轻代回收的时候，G1 会对 Dirty Card Queue中所有的 Card 进行处理，以更新 RSet，保证 RSet 实时准确的反映引用关系。 那为什么不在引用赋值语句处直接更新 RSet 呢？这是为了性能的需要，RSet 的处理需要线程同步，开销会很大，使用队列性能会好很多。 第三阶段，处理RSet识别被老年代对象指向的 Eden 中的对象，这些被指向的 Eden 中的对象被认为是存活的对象。 第四阶段，复制对象此阶段，对象树被遍历，Eden 区内存段中存活的对象会被复制到 Survivor 区中空的内存分段，Survivor 区内存段中存活的对象如果年龄未达阈值，年龄会加1，达到阀值会被会被复制到 Old 区中空的内存分段。如果 Survivor 空间不够，Eden 空间的部分数据会直接晋升到老年代空间。 第五阶段，处理引用处理 Soft，Weak，Phantom，Final，JNI Weak 等引用。最终 Eden 空间的数据为空，GC 停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。 G1 回收过程二：并发标记过程(主要针对老年代) 初始标记阶段：标记从根节点直接可达的对象。这个阶段是 STW 的，并且会触发一次年轻代 GC。 根区域扫描（Root Region Scanning）：G1 GC 扫描 Survivor 区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在 Young GC 之前完成。 并发标记（Concurrent Marking）：在整个堆中进行并发标记（和应用程序并发执行），此过程可能被Young GC 中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收。同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）。 再次标记（Remark）：由于应用程序持续进行，需要修正上一次的标记结果。是 STW 的。G1 中采用了比CMS 更快的初始快照算法：Snapshot-At-The-Beginning（SATB）。 独占清理（cleanup，STW）：计算各个区域的存活对象和 GC 回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是 STW 的。这个阶段并不会实际上去做垃圾的收集 并发清理阶段：识别并清理完全空闲的区域。 G1 回收过程三：混合回收当越来越多的对象晋升到老年代 Old Region 时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即 Mixed GC ，该算法并不是一个 Old GC，除了回收整个 Young Region，还会回收一部分的 Old Region。这里需要注意：是一部分老年代，而不是全部老年代。可以选择哪些 Old Region 进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是 Mixed GC 并不是 Full GC。 并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算了出来。默认情况下，这些老年代的内存分段会分8次（可以通过-XX:G1MixedGCCountTarget设置）被回收 混合回收的回收集（Collection Set）包括八分之一的老年代内存分段，Eden 区内存分段，Survivor 区内存分段。混合回收的算法和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程。 由于老年代中的内存分段默认分8次回收，G1 会优先回收垃圾多的内存分段。垃圾占内存分段比例越高的，越会被先回收。并且有一个阈值会决定内存分段是否被回收， -XX:G1MixedGCLiveThresholdPercent，默认为65%，意思是垃圾占内存分段比例要达到65%才会被回收。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间。 混合回收并不一定要进行8次。有一个阈值 -XX:G1HeapWastePercent，默认值为10%，意思是允许整个堆内存中有10%的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于10%，则不再进行混合回收。因为GC 会花费很多的时间但是回收到的内存却很少。 G1 回收可选的过程四：Full GCG1 的初衷就是要避免 Full GC 的出现。但是如果上述方式不能正常工作，G1 会停止应用程序的执行（Stop-The-World），使用单线程的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。 要避免 Full GC 的发生，一旦发生需要进行调整。什么时候会发生 Full GC 呢？比如堆内存太小，当 G1 在复制存活对象的时候没有空的内存分段可用，则会回退到 Full GC ，这种情况可以通过增大内存解决。导致G1 Full GC 的原因可能有两个： Evacuation 的时候没有足够的 To-Space 来存放晋升的对象； 并发处理过程完成之前空间耗尽。 G1 回收的优化建议 从 Oracle 官方透露出来的信息可获知，回收阶段（Evacuation）其实本也有想过设计成与用户程序一起并发执行，但这件事情做起来比较复杂，考虑到 G1 只是回收一部分 Region，停顿时间是用户可控制的，所以并不迫切去实现，而选择把这个特性放到了 G1 之后出现的低延迟垃圾收集器（即ZGC）中。另外，还考虑到 G1 不是仅仅面向低延迟，停顿用户线程能够最大幅度提高垃圾收集效率，为了保证吞吐量所以才选择了完全暂停用户线程的实现方案。 年轻代大小 避免使用 -Xmn 或 -XX:NewRatio 等相关选项显式设置年轻代大小 固定年轻代的大小会覆盖暂停时间目标 暂停时间目标暂停时间目标不要太过严苛 G1 GC 的吞吐量目标是90%的应用程序时间和10%的垃圾回收时间 评估 G1 GC 的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。 垃圾回收器总结截止 JDK 1.8，一共有7款不同的垃圾收集器。每一款的垃圾收集器都有不同的特点，在具体使用的时候，需要根据具体的情况选用不同的垃圾收集器。 GC 发展阶段：Serial =&gt; Parallel（并行）=&gt; CMS（并发）=&gt; G1 =&gt; ZGC 不同厂商、不同版本的虚拟机实现差距比较大。HotSpot 虚拟机在 JDK7/8 后所有收集器及组合如下图 两个收集器间有连线，表明它们可以搭配使用：Serial/Serial Old、Serial/CMS、ParNew/Serial Old、ParNew/CMS、Parallel Scavenge/Serial Old、Parallel Scavenge/Parallel Old、G1； 其中 Serial Old 作为 CMS 出现”Concurrent Mode Failure”失败的后备预案。 （红色虚线）由于维护和兼容性测试的成本，在 JDK 8 时将 Serial+CMS、ParNew+Serial Old 这两个组合声明为废弃（JEP173），并在 JDK 9 中完全取消了这些组合的支持（JEP214），即：移除。 （绿色虚线）JDK 14 中：弃用 Parallel Scavenge 和 Serialold GC 组合（JEP366） （青色虚线）JDK 14 中：删除 CMS 垃圾回收器（JEP363） 怎么选择垃圾回收器Java 垃圾收集器的配置对于 JVM 优化来说是一个很重要的选择，选择合适的垃圾收集器可以让 JVM 的性能有一个很大的提升。怎么选择垃圾收集器？ 优先调整堆的大小让 JVM 自适应完成。 如果内存小于100M，使用串行收集器 如果是单核、单机程序，并且没有停顿时间的要求，串行收集器 如果是多 CPU、需要高吞吐量、允许停顿时间超过1秒，选择并行或者 JVM 自己选择 如果是多 CPU、追求低停顿时间，需快速响应（比如延迟不能超过1秒，如互联网应用），使用并发收集器 官方推荐 G1，性能高。现在互联网的项目，基本都是使用 G1。 最后需要明确一个观点： 没有最好的收集器，更没有万能的收集 调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器 面试对于垃圾收集，面试官可以循序渐进从理论、实践各种角度深入，也未必是要求面试者什么都懂。但如果你懂得原理，一定会成为面试中的加分项。这里较通用、基础性的部分如下： 垃圾收集的算法有哪些？如何判断一个对象是否可以回收？ 垃圾收集器工作的基本流程。 另外，大家需要多关注垃圾回收器这一章的各种常用的参数 GC 日志分析通过阅读 GC 日志，我们可以了解 Java 虚拟机内存分配与回收策略。内存分配与垃圾回收的参数列表 -XX:+PrintGC 输出 GC 日志。类似：-verbose:gc -XX:+PrintGCDetails 输出 GC 的详细日志 -XX:+PrintGCTimestamps 输出 GC 的时间戳（以基准时间的形式） -XX:+PrintGCDatestamps 输出 GC 的时间戳（以日期的形式，如2013-05-04T21：53：59.234+0800） -XX:+PrintHeapAtGC在进行 GC 的前后打印出堆的信息 -Xloggc:../logs/gc.log日志文件的输出路径 verbose:gc打开GC日志 1-verbose:gc 这个只会显示总的 GC 堆的变化，如下： 参数解析 PrintGCDetails打开 GC 日志 1-verbose:gc -XX:+PrintGCDetails 输入信息如下 参数解析 时间戳打开 GC 日志： 1-verbose:gc -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps 输入信息如下： 说明：带上了日期和时间 GC 日志把 GC 日志保存到文件 1-Xloggc:/path/to/gc.log 补充 “[GC”和”[Full GC”说明了这次垃圾收集的停顿类型，如果有”Full”则说明 GC 发生了”Stop The World” 使用 Serial 收集器在新生代的名字是Default New Generation，因此显示的是”[DefNew” 使用 ParNew 收集器在新生代的名字会变成”[ParNew”，意思是”Parallel New Generation” 使用 Parallel Scavenge 收集器在新生代的名字是”[PSYoungGen” 老年代的收集和新生代道理一样，名字也是收集器决定的 使用 G1 收集器的话，会显示为”Garbage-First Heap” Allocation Failure 表明本次引起 GC 的原因是因为在年轻代中没有足够的空间能够存储新的数据了。 [PSYoungGen：5986K-&gt;696K（8704K）]5986K-&gt;704K（9216K）中括号内： GC 回收前年轻代大小，回收后大小，（年轻代总大小） 括号外：GC回收前年轻代和老年代大小，回收后大小，（年轻代和老年代总大小） user 代表用户态回收耗时，sys 内核态回收耗时，rea 实际耗时。由于多核的原因，时间总和可能会超过 real 时间 Young GC(Minor GC) Full GC GC 回收举例我们编写一个程序，用来说明 GC 收集的过程 12345678910111213/** * GC垃圾收集过程 */public class GCUseTest { static final Integer _1MB = 1024 * 1024; public static void main(String[] args) { byte [] allocation1, allocation2, allocation3, allocation4; allocation1 = new byte[2 *_1MB]; allocation2 = new byte[2 *_1MB]; allocation3 = new byte[2 *_1MB]; allocation4 = new byte[4 *_1MB]; }} 我们设置 JVM 启动参数 1-Xms10m -Xmx10m -XX:+PrintGCDetails 首先我们会将3个 2M 的数组存放到 Eden 区，然后后面 4M 的数组来了后，将无法存储，因为 Eden 区只剩下2M 的剩余空间了，那么将会进行一次 Young GC 操作，将原来 Eden 区的内容，存放到 Survivor 区，但是Survivor 区也存放不下，那么就会直接晋级存入 Old 区 然后我们将 4M 对象存入到 Eden 区中 可以用一些工具去分析这些 GC 日志 常用的日志分析工具有：GCViewer、GCEasy、GCHisto、GCLogViewer、Hpjmeter、garbagecat 等 GCViewer GC easy 垃圾回收器的新发展GC 仍然处于飞速发展之中，目前的默认选项 G1 GC 在不断的进行改进，很多我们原来认为的缺点，例如串行的Full GC、Card Table 扫描的低效等，都已经被大幅改进，例如，JDK 10 以后，Full GC 已经是并行运行，在很多场景下，其表现还略优于 Parallel GC 的并行 Full GC 实现。 即使是 Serial GC，虽然比较古老，但是简单的设计和实现未必就是过时的，它本身的开销，不管是 GC 相关数据结构的开销，还是线程的开销，都是非常小的，所以随着云计算的兴起，在 Serverless 等新的应用场景下，Serial GC 找到了新的舞台。 比较不幸的是 CMS GC，因为其算法的理论缺陷等原因，虽然现在还有非常大的用户群体，但在 JDK 9 中已经被标记为废弃，并在 JDK 14 版本中移除 Epsilon:A No-Op GarbageCollector（Epsilon 垃圾回收器，”No-Op（无操作）”回收器）http://openidk.iava.net/iep s/318 ZGC:A Scalable Low-Latency Garbage Collector（Experimental）（ZGC：可伸缩的低延迟垃圾回收器，处于实验性阶段） 现在 G 1回收器已成为默认回收器好几年了。我们还看到了引入了两个新的收集器：ZGC（JDK 11 出现）和Shenandoah（Open JDK 12） 主打特点：低停顿时间 Open JDK 12 的 Shenandoash GCOpen JDK 12 的 Shenandoash GC：低停顿时间的 GC（实验性） Shenandoah，无疑是众多 GC 中最孤独的一个。是第一款不由 Oracle 公司团队领导开发的 HotSpot 垃圾收集器。不可避免的受到官方的排挤。比如号称 OpenJDK 和 OracleJDK 没有区别的 Oracle 公司仍拒绝在OracleJDK12中支持 Shenandoah。 Shenandoah 垃圾回收器最初由 RedHat 进行的一项垃圾收集器研究项目 Pauseless GC 的实现，旨在针对 JVM上的内存回收实现低停顿的需求。在2014年贡献给 OpenJDK。 Red Hat 研发 Shenandoah 团队对外宣称，Shenandoah 垃圾回收器的暂停时间与堆大小无关，这意味着无论将堆设置为 200MB 还是 200GB，99.9%的目标都可以把垃圾收集的停顿时间限制在十毫秒以内。不过实际使用性能将取决于实际工作堆的大小和工作负载。 这是 RedHat 在2016年发表的论文数据，测试内容是使用 ES 对200GB的维基百科数据进行索引。从结果看： 停顿时间比其他几款收集器确实有了质的飞跃，但也未实现最大停顿时间控制在十毫秒以内的目标。 而吞吐量方面出现了明显的下降，总运行时间是所有测试收集器里最长的。 总结 Shenandoah GC 的弱项：高运行负担下的吞吐量下降。 shenandoah GC 的强项：低延迟时间。 革命性的 ZGCZGC 与 Shenandoah 目标高度相似，在尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停颇时间限制在十毫秒以内的低延迟。 《深入理解Java虚拟机》一书中这样定义 ZGC：ZGC 收集器是一款基于 Region 内存布局的，（暂时）不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-压缩算法的，以低延迟为首要目标的一款垃圾收集器。 ZGC 的工作过程可以分为4个阶段：并发标记 - 并发预备重分配 - 并发重分配 - 并发重映射 等。 ZGC 几乎在所有地方并发执行的，除了初始标记的是 STW 的。所以停顿时间几乎就耗费在初始标记上，这部分的实际时间是非常少的。 停顿时间对比 在 ZGC 的强项停顿时间测试上，塔毫不留情的将 Parallel、G1 拉开了两个数量级的差距。无论平均挺对、95%停顿、99%停顿、99.9%停顿，还是最大停顿时间，ZGC 都能毫不费劲控制在10毫秒以内。 虽然 ZGC 还在试验状态，没有完成所有特性，但此时性能已经相当亮眼，用“令人震惊、革命性”来形容，不为过。未来将在服务端、大内存、低延迟应用的首选垃圾收集器。 JDK 14 之前，ZGC 仅 Linux 才支持。 尽管许多使用 ZGC 的用户都使用类 Linux 的环境，但在 Windows 和 macOS 上，人们也需要 ZGC 进行开发部署和测试。许多桌面应用也可以从 ZGC 中受益。因此，ZGC 特性被移植到了 Windows 和 macOS 上。 现在 mac 或 Windows 上也能使用 ZGC 了，示例如下： 1-XX:+UnlockExperimentalVMOptions-XX：+UseZGC AliGCAliGC 是阿里巴巴 JVM 团队基于 G1 算法，面向大堆（LargeHeap）应用场景。指定场景下的对比： 当然，其它厂商也提供了各种别具一格的 GC 实现，例如比较有名的低延迟 GC——Zing","link":"/2020/10/16/%E5%B0%9A%E7%A1%85%E8%B0%B7JVM/%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"},{"title":"尚硅谷JVM&#x2F;第四章_程序计数器","text":"程序计数器PC Register 介绍 JVM 中的程序计数寄存器（Program Counter Register）中，Register 的命名源于 CPU 的寄存器，寄存器存储指令相关的现场信息。CPU 只有把数据装载到寄存器才能够运行。这里，并非是广义上所指的物理寄存器，或许将其翻译为 PC 计数器（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。JVM 中的 PC 寄存器是对物理 PC 寄存器的一种抽象模拟。 它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。 在 JVM 规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。 任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的 Java 方法的 JVM 指令地址；或者，如果是在执行 native 方法，则是未指定值（undefined）。 它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。 字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。 它是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。 作用： PC 寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。 举例说明我们首先写一个简单的代码 1234567public class PCRegisterTest { public static void main(String[] args) { int i = 10; int j = 20; int k = i + j; }} 然后将代码进行编译成字节码文件，我们再次查看 ，发现在字节码的左边有一个行号标识，它其实就是指令地址，用于指向当前执行到哪里。 1234567890: bipush 102: istore_13: bipush 205: istore_26: iload_17: iload_28: iadd9: istore_310: return 通过 PC 寄存器，我们就可以知道当前程序执行到哪一步了 两个常见问题使用 PC 寄存器存储字节码指令地址有什么用呢？因为 CPU 需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。 JVM 的字节码解释器就需要通过改变 PC 寄存器的值来明确下一条应该执行什么样的字节码指令。 PC 寄存器为什么被设定为私有的？我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU 会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个 PC 寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。 由于 CPU 时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。 这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。 CPU 时间片CPU 时间片即 CPU 分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。 在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。 但在微观上：由于只有一个 CPU ，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。","link":"/2020/10/16/%E5%B0%9A%E7%A1%85%E8%B0%B7JVM/%E7%AC%AC%E5%9B%9B%E7%AB%A0_%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/"},{"title":"尚硅谷JVM&#x2F;第十八章_Class文件结构","text":"Class 文件结构概述 字节码文件的跨平台性 Java 语言，跨平台的(write once, run anywhere) 当 Java 源代码成功编译成字节码后，如果想在不同的平台上面运行，则无须再次编译 这个优势不再那么吸引人了。Python、PHP、Perl、Ruby、Lisp 等有强大的解释器 跨平台似乎已经快称为一门语言必选的特性 Java 虚拟机：跨语言的平台 Java 虚拟机不和包括 Java 在内的任何语言绑定，它只与”Class 文件”这种特定的二进制文件格式所关联。无论使用何种语言进行软件开发， 只要能将源文件编译为正确的 Class 文件，那么这种语言就可以在 Java 虚拟机上执行，可以说，统一而强大的 Class 文件结构，就是 Java 虚拟机的基石、桥梁。 https://docs.oracle.com/javase/specs/index.html，所有的 JVM 全部遵守 Java 虚拟机规范，也就是说所有的 JVM 环境都是一样的， 这样一来字节码文件可以在各种 JVM 上进行。 想要让一个 Java 程序正确地运行在 JVM 中，Java 源码就是必须要被编译为符合 JVM 规范的字节码 前端编译器的主要任务就是负责将符合 Java 语法规范的 Java 代码转换为符合 JVM 规范的字节码文件 javac 是一种能够将 Java 源码编译为字节码的前端编译器 javac 编译器在将 Java 源码编译为一个有效的字节码文件过程中经历了4个步骤，分别是词法分析、语法分析、语义分析以及生成字节码。 Oracle 的 JDK 软件包括两部分内容： 一部分是将 Java 源代码编译成 Java 虚拟机的指令集的编译器 另一部分是用于实现 Java 虚拟机的运行时环境 Java 的前端编译器 前端编译器 VS 后端编译器 Java 源代码的编译结果是字节码，那么肯定需要有一种编译器能够将 Java 源码编译为字节码，承担这个重要责任的就是配置在 path 环境变量中的 javac 编译器。javac 是一种能够将 Java 源码编译为字节码的前端编译器。 HotSpot VM 并没有强制要求前端编译器只能使用 javac 来编译字节码，其实只要编译结果符合 JVM 规范都可以被 JVM 所识别即可。在 Java 的前端编译器领域，除了 javac 之外，还有一种被大家经常用到的前端编译器，那就是内置在 Eclipse 中的 ECJ (Eclipse Compiler for Java)编译器。和 javac 的全量式编译不同，ECJ 是一种增量式编译器。 在 Eclipse 中，当开发人员编写完代码后，使用”Ctrl + S”快捷键时，ECJ 编译器所采取的编译方案是把未编译部分的源码逐行进行编译，而非每次都全量编译。因此 ECJ 的编译效率会比 javac 更加迅速和高效，当然编译质量和 javac 相比大致还是一样的 ECJ 不仅是 Eclipse 的默认内置前端编译器，在 Tomcat 中同样也是使用 ECJ 编译器来编译 jsp 文件。由于 ECJ 编译器是采用 GPLv2 的开源协议进行源代码公开，所以，大家可以登录 Eclipse 官网下载 ECJ 编译器的源码进行二次开发 默认情况下，IntelliJ IDEA 使用 javac 编译器（还可以自己设置为 AspectJ 编译器 ajc） 前端编译器并不会直接涉及编译优化等方面的技术，而是将这些具体优化细节移交给 HotSpot 的 JIT 编译器负责 透过字节码指令看代码细节 BAT 面试题 类文件结构有几个部分？ 知道字节码吗？字节码都有哪些？Integer x = 5; int y = 5; 比较 x == y 都经过哪些步骤？ 代码举例 1234567891011public class IntegerTest { public static void main(String[] args) { Integer i1 = 10; Integer i2 = 10; System.out.println(i1 == i2); Integer i3 = 128; Integer i4 = 128; System.out.println(i3 == i4); }} 1234567public class StringTest { public static void main(String[] args) { String str = new String(\"hello\") + new String(\"world\"); String str1 = \"helloworld\"; System.out.println(str == str1); }} 1234567891011121314151617181920212223242526272829303132public class SonTest { public static void main(String[] args) { Father f = new Son(); System.out.println(f.x); }}class Father { int x = 10; public Father() { this.print(); x = 20; } public void print() { System.out.println(\"Father.x = \" + x); }}class Son extends Father { int x = 30; public Son() { this.print(); x = 40; } public void print() { System.out.println(\"Son.x = \" + x); }} 虚拟机的基石：Class 文件字节码文件里是什么？源代码经过编译器编译之后便会生成一个字节码文件，字节码是一种二进制的类文件，它的内容是 JVM 的指令，而不像 C、C++ 经由编译器直接生成机器码 什么事字节码指令(byte code)？Java 虚拟机的指令由一个字节长度的、代表着某种特定操作含义的操作码(opcode)以及跟随其后的零至多个代表此操作所需参数的操作数(operand)所构成。虚拟机中许多指令并不包含操作数，只有一个操作码 比如： 如何解读供虚拟机解释执行的二进制字节码？方式一：一个一个二进制的看，这里用到的是 Notepad++，需要安装一个 HEX-Editor 插件，或者使用 Binary Viewer 方式二：使用 javap 指令，JDK 自带的反解析工具 方式三：使用 IDEA 插件，jclasslib 或 jclasslib bytecode viewer 客户端工具 Class 文件结构 官方文档位置 https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html Class 类的本质 任何一个 Class 文件都对应着唯一一个类或接口的定义信息，但反过来说，Class 文件实际上它并不一定以磁盘文件形式存在。Class 文件是一组以8位字节为基础单位的二进制流 Class 文件格式 Class 的结构不像 XML 等描述语言，由于它没有任何分隔符号。所以在其中的数据项，无论是字节顺序还是数量，都是被严格限定的，哪个字节代表什么含义，长度是多少，先后顺序如何，都不允许改变 Class 文件格式采用一种类似于 C 语言结构体的方式进行数据存储，这种结构中只有两种数据类型：无符号数和表 无符号数属于基本的数据类型，以 u1、u2、u4、u8 来分别代表1个字节、2个字节、4个字节、8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照 UTF-8 编码构成字符串值 表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以”_info”结尾。表用于描述有层次关系的复合结构的数据，整个 Class 文件本质上就是一张表。由于表没有固定长度，所以通常会在其前面加上个数说明 代码举例 12345678public class Demo { private int num = 1; public int add() { num = num + 2; return num; }} 对应的字节码文件： 换句话说，充分理解了每一个字节码文件的细节，自己也可以反编译出 Java 源文件来 Class 文件结构概述 Class 文件的结构并不是一成不变的，随着 Java 虚拟机的不断发展，总是不可避免地会对 Class 文件结构做出一些调整，但是其基本结构和框架是非常稳定的 Class 文件的总体结构如下： 魔数 Class 文件版本 常量池 访问标志 类索引、父类索引、接口索引集合 字段表集合 方法表集合 属性表集合 类型 名称 说明 长度 数量 u4 magic 魔数,识别Class文件格式 4个字节 1 u2 minor_version 副版本号(小版本) 2个字节 1 u2 major_version 主版本号(大版本) 2个字节 1 u2 constant_pool_count 常量池计数器 2个字节 1 cp_info constant_pool 常量池表 n个字节 constant_pool_count-1 u2 access_flags 访问标识 2个字节 1 u2 this_class 类索引 2个字节 1 u2 super_class 父类索引 2个字节 1 u2 interfaces_count 接口计数器 2个字节 1 u2 interfaces 接口索引集合 2个字节 interfaces_count u2 fields_count 字段计数器 2个字节 1 field_info fields 字段表 n个字节 fields_count u2 methods_count 方法计数器 2个字节 1 method_info methods 方法表 n个字节 methods_count u2 attributes_count 属性计数器 2个字节 1 attribute_info attributes 属性表 n个字节 attributes_count 魔数：Class 文件的标志Magic Number(魔数) 每个 Class 文件开头的4个字节的无符号整数称为魔数(Magic Number) 它的唯一作用是确定这个文件是否为一个能被虚拟机接受的有效合法的 Class 文件。即：魔数是 Class 文件的标识符 魔数值固定为 0xCAFEBABE。不会改变 如果一个 Class 文件不以 0xCAFEBABE 开头，虚拟机在进行文件校验的时候就会直接抛出以下错误： Error: A JNI error has occurred, please check your installation and try again Exception in thread “main” java.lang.ClassFormatError: Incompatible magic value 1885430635 in class file StringTest 使用魔数而不是扩展名来进行识别主要是基于安全方面的考虑，因为文件扩展名可以随意地改动 Class 文件版本号 紧接着魔数的4个字节存储的是 Class 文件的版本号。同样也是4个字节。第5个和第6个字节所代表的含义就是编译的副版本号 minor_version，而第7个和第8个字节就是编译的主版本号 major_version 它们共同构成了 Class 文件的格式版本号。譬如某个 Class 文件的主版本号为 M，服版本号为 m，那么这个 Class 文件的格式版本号就确定为 M.m 版本号和 Java 编译器的对应关系如下表： 主版本（十进制） 副版本（十进制） 编译器版本 45 3 1.1 46 0 1.2 47 0 1.3 48 0 1.4 49 0 1.5 50 0 1.6 51 0 1.7 52 0 1.8 53 0 1.9 54 0 1.10 55 0 1.11 Java 的版本号是从45开始的，JDK 1.1 之后的每个 JDK 大版本发布主版本号向上加1 不同版本的 Java 编译器编译的 Class 文件对应的版本是不一样的。目前，高版本的 Java 虚拟机可以执行由低版本编译器生成的 Class 文件，但是低版本的 Java 虚拟机不能执行由高版本编译器生成的 Class 文件。否则 JVM 会抛出 java.lang.UnsupportedClassVersionError 异常(向下兼容) 在实际应用中，由于开发环境和生产环境的不同，可能会导致该问题的发生。因此，需要我们在开发时，特别注意开发编译的 JDK 版本和生产环境的 JDK 版本是否一致 虚拟机 JDK 版本为 1.k (k &gt;= 2)时，对应的 Class 文件格式版本号的范围为 45.0 - 44 + k.0(含两端) 常量池：存放所有常量 常量池是 Class 文件中内容最为丰富的区域之一。常量池对于 Class 文件中的字段和方法解析也有着至关重要的作用 随着 Java 虚拟机的不断发展，常量池的内容也日渐丰富，可以说，常量池是整个 Class 文件的基石 在版本号之后，紧跟着的是常量池的数量，以及若干个常量池表项 常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项 u2 类型的无符号数，代表常量池容量计数值(constant_pool_count)，与 Java 中语言习惯不一样的是，这个容量计数是从1而不是0开始的 类型 名称 数量 u2(无符号数) constant_pool_count 1 cp_info(表) constant_pool constant_pool_count - 1 由上表可见，Class 文件使用了一个前置的容量计数器(constant_pool_count)加若干个连续的数据项(constant_pool)的形式来描述常量池内容，我们把这一系列连续常量池数据称为常量池集合 常量池表项中，用于存放编译时期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放 常量池计数器：存放所有常量 由于常量池的数量不固定，时长时短，所以需要放置两个字节来表示常量池容量计数值 常量池容量计数值(u2 类型)：从1开始，表示常量池中有多少项常量。即 constant_pool_count = 1 表示常量池中有0个常量项 Demo 的值为： 其值为 0x0016，对应的十进制值为22 需要注意的是，这实际上只有21项常量。索引为范围是1-21。为什么呢？ 通常我们写代码时都是从0开始的，但是这里的常量池却是从1开始，因为它把第0项常量空出来了。这是为了满足后面某些指向常量池的索引值的数据在特定情况下需要表达”不引用任何一个常量池项目”的含义，这种情况可用索引值0来表示 常量池表 constant_pool 是一种表结构，以 1 ~ constant_pool_count - 1 为索引。表明了后面有多少个常量项 常量池主要存放两大类常量：字面量(Literal)和符号引用(Symbolic References) 它包含了 Class 文件结构及其子结构中引用的所有字符串常量、类或接口名、字段名和其他常量。常量池中的每一项都具备相同的特征。第1个字节作为类型标记，用于确定该项的格式，这个字节称为 tag byte(标记字节、标签字节) 类型 标志(或标识) 描述 CONSTANT_utf8_info 1 UTF-8编码的字符串 CONSTANT_Integer_info 3 整型字面量 CONSTANT_Float_info 4 浮点型字面量 CONSTANT_Long_info 5 长整型字面量 CONSTANT_Double_info 6 双精度浮点型字面量 CONSTANT_Class_info 7 类或接口的符号引用 CONSTANT_String_info 8 字符串类型字面量 CONSTANT_Fieldref_info 9 字段的符号引用 CONSTANT_Methodref_info 10 类中方法的符号引用 CONSTANT_InterfaceMethodref_info 11 接口中方法的符号引用 CONSTANT_NameAndType_info 12 字段或方法的符号引用 CONSTANT_MethodHandle_info 15 表示方法句柄 CONSTANT_MethodType_info 16 标志方法类型 CONSTANT_InvokeDynamic_info 18 表示一个动态方法调用点 字面量和符号引用在对这些常量解读前，需要搞清楚几个概念 常量池主要存放两大类常量：字面量(Literal)和符号引用(Symbolic References)。如下表： 常量 具体的常量 字面量 文本字符串 声明为 final 的常量值 符号引用 类和接口的全限定名 字段的名称和描述符 方法的名称和描述符 全限定名com/atguigu/test/Demo 这个就是类的全限定名，仅仅是把包的”.”替换成”/“，为了使连续的多个全限定名之间不产生混淆，在使用时最后一般会加入一个”;”表示全限定名结束 简单名称简单名称是指没有类型和参数修饰的方法或者字段名称，上面例子中的类的 add() 方法和 num 字段的简单名称分别是 add 和 num 描述符描述符的作用是用来描述字段的数据类型、方法的参数列表(包括数量、类型以及顺序)和返回值。根据描述符规则，基本数据类型(byte、char、double、float、int、long、short、boolean)以及代表无返回值的 void 类型都用一个大写字符来表示，而对象类型则用字符 L 加对象的全限定名表示，详见下表： 标志符 含义 B 基本数据类型byte C 基本数据类型char D 基本数据类型double F 基本数据类型float I 基本数据类型int J 基本数据类型long S 基本数据类型short Z 基本数据类型boolean V 代表void类型 L 对象类型，比如：Ljava/lang/Object; [ 数组类型，代表一维数组。比如：double[][][] is [[[D 用描述符来藐视方法时，按照先参数列表，后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号”()”之内，如方法 java.lang.String toString()的描述符为 () Ljava/lang/String;，方法 int abc(int[] x ,int y)描述符为([II) I 虚拟机在加载 Class 文件时才会进行动态链接，也就是说，Class 文件中不会保存各个方法和字段的最终内存布局信息，因此，这些字段和方法的符号引用不经过转换是无法直接被虚拟机使用的。当虚拟机运行时，需要从常量池中获得对应的符号引用，再在类加载过程中的解析阶段将其替换为直接引用，并翻译到具体的内存地址中。 这里说明下符号引用和直接引用的区别与关联： 符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中 直接引用：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那说明引用的目标必定已经存在于内存之中了。 常量类型和结构常量池中每一项常量都是一个表，JDK 1.7 之后共14种不同的表结构数据。如下表格所示： 标志 常量 描述 细节 长度 细节描述 1 CONSTANT_utf8_info UTF-8编码的字符串 tag u1 值为1 length u2 UTF-8编码的字符串占用的字符数 bytes u1 长度为length的UTF-8编码的字符串 3 CONSTANT_Integer_info 整型字面量 tag u1 值为3 bytes u4 按照高位在前存储的int值 4 CONSTANT_Float_info 浮点型字面量 tag u1 值为4 bytes u4 按照高位在前存储的float值 5 CONSTANT_Long_info 长整型字面量 tag u1 值为5 bytes u8 按照高位在前存储的long值 6 CONSTANT_Double_info 双精度浮点型字面量 tag u1 值为6 bytes u8 按照高位在前存储的double值 7 CONSTANT_Class_info 类或接口的符号引用 tag u1 值为7 index u2 指向全限定名常量项的索引 8 CONSTANT_String_info 字符串类型字面量 tag u1 值为8 index u2 指向字符串字面量的索引 9 CONSTANT_Fieldref_info 字段的符号引用 tag u1 值为9 index u2 指向声明字段的类或接口描述符CONSTANT_Class_info的索引项 index u2 指向字段描述符CONSTANT_NameAndType的索引项 10 CONSTANT_Methodref_info 类中方法的符号引用 tag u1 值为10 index u2 指向声明方法的类描述符CONSTANT_Class_Info的索引项 index u2 指向名称及类型描述符CONSTANT_NameAndType的索引项 11 CONSTANT_InterfaceMethodref_info 接口中方法的符号引用 tag u1 值为11 index u2 指向声明方法的接口描述符CONSTANT_Class_Info的索引项 index u2 指向名称及类型描述符CONSTANT_NameAndType的索引项 12 CONSTANT_NameAndType_info 字段或方法的符号引用 tag u1 值为12 index u2 指向该字段或方法名称常量项的索引 index u2 指向该字段或方法描述符常量项的索引 15 CONSTANT_MethodHandle_info 表示方法句柄 tag u1 值为15 reference_kind u1 值必须在1-9之间，它决定了方法句柄的类型方法句柄类型的值表示方法句柄的字节码行为 reference_index u2 值必须是对常量池的有效索引 16 CONSTANT_MethodType_info 标志方法类型 tag u1 值为16 descriptor_index u2 值必须是对常量池的有效索引，常量池在该索引处的项必须是CONSTANT_Utf8_info结构，表示方法的描述符 18 CONSTANT_InvokeDynamic_info 表示一个动态方法调用点 tag u1 值为18 bootstrap_method_attr u2 值必须是对当前Class文件中引导方法表的bootstrap_methods[]数组的有效索引 name_and_type_index u2 值必须是对当前常量池的有效索引，常量池在该索引处的项必须是CONSTANT_NameAndType_Info结构，表示方法名和方法描述符 根据上图每个类型的描述我们也可以知道每个类型是用来描述常量池中那些内容(主要是字面量、符号引用)的。比如： CONSTANT_Integer_info 是用来描述常量池中字面量信息的，而且只是整型字面量信息 标志为15、16、18的常量项类型是用来支持动态语言调用的( JDK 1.7 时才加入) 细节说明 CONSTANT_Class_info 结构用于表示类或接口 CONSTANT_Fieldref_info、CONSTANT_Methodref_info 和 CONSTANT_InterfaceMethodref_info 结构表示字段、方法和接口方法 CONSTANT_String_info 结构用于表示 String 类型的常量对象 CONSTANT_Integer_info 和 CONSTANT_Float_info 表示4字节(int 和 float)的数值常量 CONSTANT_Long_info 和 CONSTANT_Double_info 结构表示8字节(long 和 double)的数值常量 在 Class 文件的常量池中，所有的8字节常量均占两个表成员(项)的空间，如果一个 CONSTANT_Long_info 或 CONSTANT_Double_info 结构的项在常量池表中的索引位 n，则常量池表中下一个可用项的索引位 n + 2，此时常量池表中索引为 n + 1，的项仍然有效但必须视为不可用的 CONSTANT_NameAndType_info 结构用于表示字段或方法，但是和之前的3个结构不同，CONSTANT_NameAndType_info 结构没有知名该字段或方法所属的类或接口 CONSTANT_Utf8_info 用于表示字符常量的值 CONSTANT_MethodHandle_info 结构用于表示方法句柄 CONSTANT_MethodType_info 结构表示方法类型 CONSTANT_InvokeDynamic_info 结构用于表示 invokedynamic 指令所用到的引导方法(bootstrap method)、引导方法所用到的动态调用名称(dynamic invocation name)、参数和返回类型，并可以给引导方法传入一系列称为静态参数(static argument)的常量 解析方式 一个字节一个字节的解析 使用 javap 命令解析：javap -verbose Demo.class 或 jclasslib 工具会更方便 总结： 这14种表(或者常量项结构)的共同点是：表开始的第一位是一个 u1 类型的标志位(tag)，代表当前这个常量项使用的是哪种表结构，即哪种常量类型 在常量池列表中，CONSTANT_Utf8_info 常量项是一种使用改进过的 UTF-8 编码格式来存储诸如文字字符串、类或者接口的全限定名、字段或者方法的简单名称以及描述符等常量字符串信息 这14种常量项结构还有一个特点是，其中13个常量项占用的字节固定，只有 CONSTANT_Utf8_info 占用字节不固定，其大小由 length 决定。为什么？因为从常量池存放的内容可知，其存放的是字面量和符号引用，最终这些内容都会是一个字符串，这些字符串的大小是在编写程序时才确定，比如你定义一个类，类名可以取长去短，所以在没编译前，大小不固定，编译后，通过 UTF-8 编码，就可以知道其长度 常量池：可以理解为 Class 文件之中的资源仓库，它是 Class 文件结构中与其他项目关联最多的数据类型(后面的很多数据类型都会指向此处)，也是占用 Class 文件空间最大的数据项目之一 常量池中为什么包含这些内容 Java 代码在进行 javac 编译的时候，并不像 C 和 C++ 那样有”连接”这一步骤，而是在虚拟机加载 Class 文件的时候进行动态链接。也就是说，在 Class 文件中不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。 访问标识 在常量池后，紧跟着访问标记。该标记使用两个字节表示，用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口；是否定义为 public 类型；是否定义为 abstract 类型；如果是类的话，是否被声明为 final 等。各种访问标记如下所示： 标志名称 标志值 含义 ACC_PUBLIC 0x0001 标志为public类型 ACC_FINAL 0x0010 标志被声明为final，只有类可以设置 ACC_SUPER 0x0020 标志允许使用invokespecial字节码指令的新语义，JDK1.0.2之后编译出来的类的这个标志默认为真。（使用增强的方法调用父类方法） ACC_INTERFACE 0x0200 标志这是一个接口 ACC_ABSTRACT 0x0400 是否为abstract类型，对于接口或者抽象类来说，次标志值为真，其他类型为假 ACC_SYNTHETIC 0x1000 标志此类并非由用户代码产生（即：由编译器产生的类，没有源码对应） ACC_ANNOTATION 0x2000 标志这是一个注解 ACC_ENUM 0x4000 标志这是一个枚举 类的访问权限通常为 ACC_ 开头的常量 每一个种类型的表示都是通过设置访问标记的32位中的特定位来实现的。比如，若是 public final 的类，则该标记为 ACC_PUBLIC | ACC_FINAL 使用 ACC_SUPER 可以让类更准确地定位到父类的方法 super.method()，现代编译器都会设置并且使用这个标记 带有 ACC_INTERFACE 标志的 Class 文件表示的是接口而不是类，反之则表示的是类而不是接口 如果一个 Class 文件被设置了 ACC_INTERFACE 标志，那么同时也得设置 ACC_ABSTRACT 标志。同时它不能再设置 ACC_FINAL、ACC_SUPER 或 ACC_ENUM 标志 如果没有设置 ACC_INTERFACE 标志，那么这个 Class 问价可以具有上表中除 ACC_ANNOTATION 外的其他所有标志。当然，ACC_FINAL 和 ACC_ABSTRACT 这类互斥的标志除外。这两个标志不能同时设置 ACC_SUPER 标志用于确定类或接口里面的 invokespecial 指令使用的是哪一种执行语义。针对 Java 虚拟机指令集的编译器都应当设置这个标志。对于 Java SE 8 及后续版本来说，无论 Class 文件中这个标志的实际值是什么，也不管 Class 文件的版本 ACC_SYNTHETIC 标志意味着该类或接口是由编译器生成的，而不是由源代码生成的 注解类型必须设置 ACC_ANNOTATION 标志。如果设置了 ACC_ANNOTATION 标志，那么也必须设置 ACC_INTERFACE 标志 ACC_ENUM 标志标明该类或其父类为枚举类型 表中没有使用的 access_flags 标志是为未来扩充而预留的，这些预留的标志在编译器中应该设置为0，Java 虚拟机实现也应该忽略他们 类索引、父类索引、接口索引集合 在访问标记后，会指定该类的类别、父类类别以及实现的接口，格式如下： 长度 含义 u2 this_class u2 super_class u2 interfaces_count u2 interfaces[interfaces_count] 这三项数据来确定这个类的继承关系 类索引用于确定这个类的全限定名 父类索引用于确定这个类的父类的全限定名。由于 Java 语言不允许多重继承，所以父类索引只有一个，除了 java.lang.Object 之外，所有的 Java 类都有父类，因此除了 java.lang.Object 外，所有 Java 类的父类索引都不为0 接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按 implements 语句(如果这个类本身是一个接口，则应当是 extends 语句)后的接口顺序从左到右排列在接口索引集合中 this_class(类索引) 2字节无符号整数，指向常量池的索引。它提供了类的全限定名，如com/atguigu/java1/Demo。this_class 的值必须是对常量池表中某项的一个有效索引值。常量池在这个索引处的成员必须为 CONSTANT_Class_info 类型结构体，该结构体表示这个 Class 文件所定义的类或接口 super_class(父类索引) 2字节无符号整数，指向常量池的索引。它提供了当前类的父类的全限定名。如果我们没有继承任何类，其默认继承的是 java/lang/Object 类。同时，由于 Java 不支持多继承，所以其父类只有一个 superclass 指向的父类不能是 final interfaces 指向常量池索引集合，它提供了一个符号引用到所有已实现的接口 由于一个类可以实现多个接口，因此需要以数组形式保存多个接口的索引，表示接口的每个索引也是一个指向常量池的 CONSTANT_Class(当然这里就必须是接口，而不是类) 3.1 interfaces_count(接口计数器) interfaces_count 项的值表示当前类或接口的直接超接口数量 3.2 interface[] (接口索引集合) interfaces[] 中每个成员的值必须是对常量池表中某项的有效索引值，它的长度为 interfaces_count。每个成员interfaces[i] 必须为 CONSTANT_Class_info 结构，其中 0 &lt;= i &lt; interfaces_count。在 interfaces[] 中，各成员所表示的接口顺序和对应的源代码中给定的接口顺序(从左至右)一样，即 interfaces[0] 对应的是源代码中最左边的接口 字段表集合(Fields) 用于描述接口或类中声明的变量。字段(field)包括类级变量以及实例级变量，但是不包括方法内部、代码块内部声明的局部变量 字段叫什么名字、字段被定义为什么数据类型，这些都是无法固定的，只能引用常量池中的常量来描述 它指向常量池索引集合，它描述了每个字段的完整信息。比如字段的标识符、访问修饰符(public、private 或 protected)、是类变量还是实例变量(static 修饰符)、是否是常量(final 修饰符)等。 注意事项： 字段表集合中不会列出从父类或者实现的接口中继承而来的字段，但有可能列出原 Java 代码中不存在的字段，譬如在内部类中为了保持对外部类的方文星，会自动添加指向外部类实例的字段 在 Java 语言中字段是无法重载的，两个字段的数据类型、修饰符不管是否相同，都必须使用不一样的名称，但是对于字节码来讲，如果两个字段的描述符不一致，那字段重名就是合法的 字段计数器(fields_count)fields_count 的值表示当前 Class 文件 fields 表的成员个数。使用两个字节来表示 fields 表中每个成员都是一个 field_info 结构，用于表示该类或接口所声明的所有类字段或者实例字段，不包括方法内部声明的变量，也不包括从父类或父接口继承的那些字段 fields [] (字段表)fields 表中的每个成员都必须是一个 fields_info 结构的数据项，用于表示当前类或接口中某个字段的完整描述 一个字段的信息包括如下这些信息，这些信息中，各个修饰符都是布尔值，要么有，要么没有 作用域(public、private、protected 修饰符) 是实例变量还是类变量(static 修饰符) 可变性(final) 并发可见性(volatile 修饰符，是否强制从主内存读写) 可否序列化(transient 修饰符) 字段数据类型(基本数据类型、对象、数组) 字段名称 字段表结构： 类型 名称 含义 数量 u2 access_flags 访问标志 1 u2 name_index 字段名索引 1 u2 descriptor_index 描述符索引 1 u2 attributes_count 属性计数器 1 attribute_info attributes 属性集合 attributes_count 字段表访问标识我们知道，一个字段可以被各种关键字去修饰，比如：作用域修饰符(public、private、protected)、static 修饰符、final 修饰符、volatile 修饰符等等。因此，其可像类的访问标志那样，使用一些标志来标记字段。字段的访问标志有如下这些： 标志名称 标志值 含义 ACC_PUBLIC 0x0001 字段是否为public ACC_PRIVATE 0x0002 字段是否为private ACC_PROTECTED 0x0004 字段是否为protected ACC_STATIC 0x0008 字段是否为static ACC_FINAL 0x0010 字段是否为final ACC_VOLATILE 0x0040 字段是否为volatile ACC_TRANSTENT 0x0080 字段是否为transient ACC_SYNCHETIC 0x1000 字段是否为由编译器自动产生 ACC_ENUM 0x4000 字段是否为enum 字段名索引根据字段名索引的值，查询常量池中的指定索引项即可 描述符索引描述符的作用是用来描述字段的数据类型、方法的参数列表(包括数量、类型以及顺序)和返回值。根据描述符规则，基本数据类型(byte、char、double、float、int、long、short、boolean)及代表无返回值的 void 类型都用一个大写字符来表示，而对象则用字符L加对象的全限定名来表示，如下所示： 标志符 含义 B 基本数据类型 byte C 基本数据类型 char D 基本数据类型 double F 基本数据类型 float I 基本数据类型 int J 基本数据类型 long S 基本数据类型 short Z 基本数据类型 boolean V 代表 void 类型 L 对象类型，比如：Ljava/lang/Object; [ 数组类型，代表一维数组。比如：double[][][] is [[[D 属性表集合一个字段还可能拥有一些属性，用于存储更多的额外信息。比如初始化值、一些注释信息等。属性个数存放在 attribute_count 中，属性具体内容存放在 attributes 数组中 以常量属性为例，结构为： 1234567ConstantValue_attribute { u2 attribute_name_index; u4 attribute_length; u2 constantvalue_index;}说明：对于常量属性而言，attribute_length 值恒为2 方法表集合methods: 指向常量池索引集合，它完整描述了每个方法的签名 在字节码文件中，每一个 method_info 项都对应着一个类或者接口中的方法信息。比如方法的访问修饰符(public、private 或 protected)，方法的返回值类型以及方法的参数信息等 如果这个方法不是抽象的或者不是 native 的，那么字节码中会体现出来 一方面，methods 表只描述当前类或接口中声明的方法，不包括从父类或父接口继承的方法。另一方面，methods 表有可能会出现由编译器自动添加的方法，最典型的便是编译器产生的方法信息(比如：类(接口)初始化方法 () 和实例初始化方法 () 使用注意事项： 在 Java 语言中，要重载(Overload)一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名，特征签名就是一个方法中各个参数在常量池中的字段符号引用的集合，也就是因为返回值不会包含在特征签名之中，因此 Java 语言里无法仅仅依靠返回值的不同来对一个已有方法进行重载。但在 Class 文件格式中，特征签名的范围更大一些，只要描述符不是完全一致的两个方法就可以共存。也就是说，如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存于同一个 Class 文件中。 也就是说，尽管 Java 语法规范并不允许在一个类或者接口中声明多个方法签名相同的方法，但是和 Java 语法规范相反，字节码文件中却恰恰允许存放多个方法签名相同的方法，唯一的条件就是这些方法之间的返回值不能相同。 methods_count(方法计数器)methods_count 的值表示当前 Class 文件 methods 表的成员个数，使用两个字节来表示 methods 表中每个成员都是一个 method_info 结构 methods[] (方法表) methods 表中的每个成员都必须是一个 method_info 结构，用于表示当前类或接口中某个方法的完整描述。如果某个 method_info 结构的 access_flags 项既没有设置 ACC_NATIVE 标志也没有设置 ACC_ABSTRACT 标志，那么该结构中也应包含实现这个方法所有的 Java 虚拟机指令 method_info 结构可以表示类和接口中定义的所有方法，包括实例方法、类方法、实例初始化方法和类或接口初始化方法 方法表的结构实际跟字段表是一样的，方法表结构如下： 类型 名称 含义 数量 u2 access_flags 访问标志 1 u2 name_index 方法名索引 1 u2 descriptor_index 描述符索引 1 u2 attributes_count 属性计数器 1 attribute_info attributes 属性集合 attributes_count 方法表访问标志跟字段表一样，方法表也有访问标志，而且他们的标志有部分相同，部分则不同，方法表的具体访问标志如下： 标记名 值 说明 ACC_PUBLIC 0x0001 public，方法可以从包外访问 ACC_PRIVATE 0x0002 private，方法只能本类中访问 ACC_PROTECTED 0X0004 protected，方法在自身和子类可以访问 ACC_STATIC 0x0008 static，静态方法 属性表结合方法表集合之后的属性表集合，指的是 Class 文件所携带的辅助信息，比如该 Class 文件的源文件的名称。以及任何带有 RetentionPolicy.CLASS 或者 RetentionPolicy.RUNTIME 的注解。这类信息通常被用于 Java 虚拟机的验证和运行，以及 Java 程序的调试，一般无需深入了解 此外，字段表、方法表都可以有自己的属性表。用于描述某些场景专有的信息 属性表集合的限制没有那么严格，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，但 Java 虚拟机运行时会忽略掉它不认识的属性 attributes_count(属性计数器)attributes_count 的值表示当前 Class 文件属性表的成员个数。属性表中每一项都是一个 attribute_info 结构 attributes[] (属性表)属性表的每个项的值必须是 attribute_info 结构。属性表的结构比较灵活，各种不同的属性只要满足以下结构即可 属性的通用格式 类型 名称 数量 含义 u2 attribute_name_index 1 属性名索引 u4 attribute_length 1 属性长度 u1 info attribute_length 属性表 即只需说明属性的名称以及占用位数的长度即可，属性表具体的结构可以去自定义 属性类型属性表实际上可以有很多类型，上面看到的 Code 属性只是其中一种， Java 8 里面定义了23种属性 下面这些是虚拟机中预定义的属性： 属性名称 使用位置 含义 Code 方法表 Java 代码编译成的字节码指令 ConstantValue 字段表 final 关键字定义的常量池 Deprecated 类、方法、字段表 被声明为 deprecated 的方法和字段 Exceptions 方法表 方法抛出的异常 EnclosingMethod 类文件 仅当一个类为局部类或者匿名类时才能拥有这个属性，这个属性用于标识这个类所在的外围方法 InnerClass 类文件 内部类列表 LineNumberTable Code 属性 Java 源码的行号与字节码指令的对应关系 LocalVariableTable Code 属性 方法的局部变量描述 StackMapTable Code 属性 JDK 1.6 中新增的属性，供新的类型检查检验器检查和处理目标方法的局部变量和操作数所需要的类是否匹配 Signature 类、方法表、字段表 用于支持泛型情况下的方法签名 SourceFile 类文件 记录源文件名称 SourceDebugExtension 类文件 用于存储额外的调试信息 Synthetic 类、方法表、字段表 标志方法或字段为编译器自动生成的 LocalVariableTypeTable 类 使用特征签名代替描述符，是为了引入泛型语法之后能描述泛型参数化类型而添加 RuntimeVisibleAnnotations 类、方法表、字段表 为动态注解提供支持 RuntimeInvisibleAnnotations 表、方法表、字段表 用于指明哪些注解是运行时不可见的 RuntimeVisibleParameterAnnotation 方法表 作用与 RuntimeVisibleAnnotations 属性类似，只不过作用对象为方法 RuntimeInvisibleParameterAnnotation 方法表 作用与 RuntimeInvisibleAnnotations 属性类似，作用对象哪个为方法参数 AnnotationDefault 方法表 用于记录注解类元素的默认值 BootstrapMethods 类文件 用于保存 invokeddynamic 指令引用的引导方式限定符 部分属性详解 ConstantValue 属性 ConstantValue 属性表示一个常量字段的值。位于 field_info 结构的属性表中 12345ConstantValue_attribute { u2 attribute_name_index; u4 attribute_length; u2 constantvalue_index; //字段值在常量池中的索引，常量池在该索引处的项给出该属性表示的常量值。(例如，值是 long 型的，在常量池中便是 CONSTANT_Long)} Deprecated 属性 1234Deprecated_attribute { u2 attribute_name_index; u4 attribute_length;} Code 属性 Code 属性就是存放方法体里面的代码，但是，并非所有方法表都有 Code 属性，像接口或者抽象方法，他们没有具体的方法体，因此也就不会有 Code 属性了 Code 属性表的结构，如下： 类型 名称 数量 含义 u2 attribute_name_index 1 属性名索引 u4 attribute_length 1 属性长度 u2 max_stack 1 操作数栈深度的最大值 u2 max_locals 1 局部变量表所需的存续空间 u4 code_length 1 字节码指令的长度 u1 code code_length 存储字节码指令 u2 exception_table_length 1 异常表长度 exception_info exception_table exception_length 异常表 u2 attributes_count 1 属性集合计数器 attribute_info attributes attributes_count 属性集合 可以看到：Code 属性表的前两项跟属性表是一致的，即 Code 属性表遵循属性表的结构，后面那些则是他自定义的结构 InnerClasses 属性 为了方便说明特别定义一个表示类或接口的 Class 格式为 C。如果 C 的常量池中包含某个 CONSTANT_Class_info 成员，且这个成员所表示的类或接口不属于任何一个包，那么 C 的 ClassFile 结构的属性表中就必须含有对应的 InnerClasses 属性。InnerClasses 属性是在 JDK 1.1 中为了支持内部类和内部接口而引入的，位于 ClassFile 结构的属性表 LineNumberTable 属性 LineNumberTable 属性是可选变长属性，位于 Code 结构的属性表 LineNumberTable 属性是用来描述 Java 源码行号与字节码行号之间的对应关系，这个属性可以用来在调试的时候定位代码执行的行数 start_pc，即字节码行号；line_number，即 Java 源代码行号 在 Code 属性的属性表中，LineNumberTable 属性可以按照任意顺序出现，此外，多个 LineNumberTable 属性可以共同表示一个行号在源文件中表示的内容，即 LineNumberTable 属性不需要与源文件的行一一对应 LineNumberTable 属性表结构： 123456789LineNumberTable_attribute { u2 attribute_name_index; u4 attribute_length; u2 line_number_table_length; { u2 start_pc; u2 line_number; } line_number_table[line_number_table_length];} LocalVariableTable 属性 LocalVariableTable 是可选变长属性，位于 Code 属性的属性表中。它被调试器用于确定方法在执行过程中局部变量的信息。在 Code 属性的属性中，LocalVariableTable 属性可以按照任意顺序出现。Code 属性中的每个局部变量最多只能有一个 LocalVariableTable 属性。 start_pc + length 表示这个变量在字节码中的生命周期起始和结束的偏移位置(this 生命周期从头0到结尾10) index 就是这个变量在局部变量表中的槽位(槽位可复用) name 就是变量名称 Descriptor 表示局部变量类型描述 LocalVariableTable 属性表结构： 123456789101112LocalVariableTable_attribute { u2 attribute_name_index; u4 attribute_length; u2 local_variable_table_length; { u2 start_pc; u2 length; u2 name_index; u2 descriptor_index; u2 index; } local_variable_table[local_variable_table_length];} Signature 属性 Signature 属性是可选的定长属性，位于 ClassFile，field_info 或 method_info 结构的属性表中。在 Java 语言中，任何类、接口、初始化方法或成员的泛型签名如果包含了类型变量(Type Variables)或参数化类型(Parameterized Types)，则 Signature 属性会为它记录泛型签名信息 SourceFile 属性 SourceFile 属性结构 类型 名称 数量 含义 u2 attribute_name_index 1 属性名索引 u4 attribute_length 1 属性长度 u2 sourcefile_index 1 源码文件索引 可以看到，其长度总是固定的8个字节 其他属性 Java 虚拟机中预定义的属性有20多个，这里就不一一介绍了，通过上面几个属性的介绍，只要领会其精髓，其他属性的解读也是易如反掌 总结通过手动去解读字节码文件，终于大概了解到其构成和原理了 实际上，我们可以使用各种工具来帮我们去解读字节码文件，而不用直接去看这些16进制，太繁琐了 小结本章主要介绍了 Class 文件的基本格式 随着 Java 平台的不断发展，在将来，Class 文件的内容也一定会做进一步的扩充，但是其基本的格式和结构不会做重大调整 从 Java 虚拟机的角度看，通过 Class 文件，可以让更多的计算机语言支持 Java 虚拟机平台。因此，Class 文件结构不仅仅是 Java 虚拟机的执行入口，更是 Java 生态圈的基础和核心 使用 javap 指令解析 Class 文件自己分析类文件结构太麻烦了！Oracle 提供了 javap 工具 当然这些信息中，有些信息(如本地变量表、指令和代码行偏移量映射表、常量池中方法的参数名称等等)需要在使用 javac 编译成 Class 文件时，指定参数才能输出，比如，你直接 javac xx.java，就不会再生成对应的局部变量表等信息，如果你使用 javac -g xx.java 就可以生成所有相关信息了。如果你使用的是 Eclipse，则默认情况下，Eclipse 在编译时会帮你生成局部变量表、指令和代码行盘一辆映射表等信息 通过反编译生成的汇编代码，我们可以深入的了解 Java 代码的工作机制。比如我们看到的 i++，这行代码实际运行时是先获取变量 i 的值，然后将这个值加1，最后再将加1后的值赋值给变量 i 解析字节码的作用通过反编译生成的字节码文件，我们可以深入的了解 Java 代码的工作机制。但是，自己分析类文件结构太麻烦了，除了使用第三方的 jclasslib 工具之外，Oracle 官方也提供了工具：javap javap 是 JDK 自带的反解析工具。它的作用就是根据 Class 字节码文件，反解析出当前类对应的 Code 区(字节码指令)、局部变量表、异常表和代码行偏移量映射表、常量池等信息 通过局部变量表，我们可以查看局部变量的作用域范围、所在槽位等信息，甚至可以看到槽位复用等信息 javac -g 操作解析字节码文件得到的信息中，有些信息(如局部变量表、指令和代码行偏移量映射表、常量池中方法的参数名称等等)需要在使用 javac 编译成 Class 文件时，指定参数才能输出 比如，你直接 javac xx.java，就不会在生成对应的局部变量表等信息，如果你使用 javac -g xx.java 就可以生成所有相关信息了。如果你使用的 Eclipse 或 IDEA，则默认情况下，Eclipse、IDEA 在编译时会帮你生成局部变量表、指令和代码行偏移量映射表等信息 javap 的用法javap 的用法格式：javap 其中，classes 就是你要反编译的 Class 文件 在命令行中直接输入 javap 或 javap -help 可以看到 javap 的 options 有如下选项： 一般常用的是 -v -l -c 三个选项 javap -l 会输出行号和本地变量表信息 javap -c 会对当前 Class 字节码进行反编译生成汇编代码 javap -v classxx 除了包含 -c 内容外，还会输出行号、局部变量表信息、常量池等信息 总结 通过 javap 命令可以查看一个 Java 类反汇编得到的 Class 文件版本号、常量池、访问标识、变量表、指令代码行号表等信息。不显式类索引、父类索引、接口索引集合、()、()等结构 通过对前面的例子代码反汇编文件的简单分析，可以发现，一个方法的执行通常会涉及下面几块内存的操作 Java 栈中：局部变量表、操作数栈 Java 堆： 通过对象的地址引用去操作 常量池 其他如帧数据区、方法区的剩余部分等情况，测试中没有显示出来，这里说明一下 平常，我们比较关注的是 Java 类中每个方法的反汇编中的指令操作过程，这些指令都是顺序执行的，可以参考官方文档查看每个指令含义","link":"/2020/10/25/%E5%B0%9A%E7%A1%85%E8%B0%B7JVM/%E7%AC%AC%E5%8D%81%E5%85%AB%E7%AB%A0_Class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"},{"title":"数据库&#x2F;MyBatis学习笔记","text":"MyBatis学习笔记(参考官方文档 3.5.4版本) 安装使用 创建Maven工程 在pom.xml中引入Maven依赖 12345678910111213141516171819&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.19&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 在resources目录下创建mybatis-config.xml全局配置文件（这里参考官方文档创建格式） 1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;!--配置数据库链接驱动--&gt; &lt;property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"这里配置数据库URL\"/&gt; &lt;property name=\"username\" value=\"你的数据库账号\"/&gt; &lt;property name=\"password\" value=\"你的数据库密码\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--mappers标签关联映射，这些映射器的 XML 映射文件包含了 SQL 代码和映射定义信息--&gt; &lt;mappers&gt; &lt;!--这里相对路径从resources文件夹开始--&gt; &lt;mapper resource=\"mappers/BlogMapper.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 根据官方文档给出的信息在Java目录下创建实体类、映射接口和测试类 Blog实体类 12345package entity;public class Blog { } BlogMapper映射接口类 12345678package mapper;import entity.Blog;public interface BlogMapper { //创建查询方法 Blog selectBlog(Long id);} 创建测试类，这里使用junit单元测试类。 从XML文件中构建SqlSessionFactory，获取mybatis-config.xml文件资源 利用SqlSessionFactoryBuilder的build()方法创建sqlSessionFactory工厂类 通过openSession()方法获取连接 关联映射接口类，调用映射接口的查询方法 1234567891011121314@Test public void test01() throws IOException { String resource = \"src/main/resources/mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); //SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //SqlSession 的实例不是线程安全的，因此是不能被共享的 SqlSession sqlSession = sqlSessionFactory.openSession(); BlogMapper mapper = sqlSession.getMapper(BlogMapper.class); //首先得有Blog这个数据库表才能查询到数据 Blog blog = mapper.selectBlog(1L); //最后需要关闭资源 sqlSession.close(); } SqlSession的实例不是线程安全的，同时映射器实例应该在调用它们的方法中被获取，使用完毕之后即可丢弃，因此，最好将映射器放在方法作用域内。就像下面的例子一样： 1234try (SqlSession session = sqlSessionFactory.openSession()) { BlogMapper mapper = session.getMapper(BlogMapper.class); // 你的应用逻辑代码} 在resources下创建mappers文件夹用来放入mapper配置文件，创建BlogMapper接口类的映射文件 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;!-- namespace命名就可以直接映射到在命名空间中同名的映射器类， 并将已映射的 select 语句匹配到对应名称、参数和返回类型的方法--&gt;&lt;mapper namespace=\"mapper.BlogMapper\"&gt; &lt;!--id必须与映射接口中的方法名一致，resultType为返回结果类型--&gt; &lt;select id=\"selectBlog\" resultType=\"Blog\"&gt; select * from Blog where id = #{id} &lt;/select&gt;&lt;/mapper&gt; 对命名空间的一点补充 在之前版本的 MyBatis 中，命名空间（Namespaces）的作用并不大，是可选的。 但现在，随着命名空间越发重要，你必须指定命名空间。 命名空间的作用有两个，一个是利用更长的全限定名来将不同的语句隔离开来，同时也实现了你上面见到的接口绑定。就算你觉得暂时用不到接口绑定，你也应该遵循这里的规定，以防哪天你改变了主意。 长远来看，只要将命名空间置于合适的 Java 包命名空间之中，你的代码会变得更加整洁，也有利于你更方便地使用 MyBatis。 对于映射类还有另一种注解的配置方法，比如，上面的 XML 示例可以被替换成如下的配置： 1234public interface BlogMapper { @Select(\"SELECT * FROM blog WHERE id = #{id}\") Blog selectBlog(int id);} 优先使用XML配置文件的方式开发 创建完成后层级目录如下图： XML 配置配置文档的顶层结构如下： 属性（properties）12345678910&lt;!--配置数据库用户名密码--&gt;&lt;!-- 这些属性可以在外部进行配置，并可以进行动态替换, 既可以在典型的 Java 属性文件中配置这些属性， 也可以在 properties 元素的子元素中设置--&gt;&lt;properties resource=\"org/mybatis/example/config.properties\"&gt; &lt;property name=\"username\" value=\"dev_user\"/&gt; &lt;property name=\"password\" value=\"F2Fa3!33TYyg\"/&gt;&lt;/properties&gt; 设置好的属性可以在整个配置文件中用来替换需要动态配置的属性值 123456789&lt;!-- username 和 password 将会由 properties 元素中设置的相应值来替换。 driver 和 url 属性将会由 config.properties 文件中对应的值来替换--&gt;&lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"${driver}\"/&gt; &lt;property name=\"url\" value=\"${url}\"/&gt; &lt;property name=\"username\" value=\"${username}\"/&gt; &lt;property name=\"password\" value=\"${password}\"/&gt;&lt;/dataSource&gt; 类型别名（typeAliases）类型别名可为 Java 类型设置一个缩写名字。 它仅用于 XML 配置，意在降低冗余的全限定类名书写。例如： 12345678&lt;typeAliases&gt; &lt;typeAlias alias=\"Author\" type=\"domain.blog.Author\"/&gt; &lt;typeAlias alias=\"Blog\" type=\"domain.blog.Blog\"/&gt; &lt;typeAlias alias=\"Comment\" type=\"domain.blog.Comment\"/&gt; &lt;typeAlias alias=\"Post\" type=\"domain.blog.Post\"/&gt; &lt;typeAlias alias=\"Section\" type=\"domain.blog.Section\"/&gt; &lt;typeAlias alias=\"Tag\" type=\"domain.blog.Tag\"/&gt;&lt;/typeAliases&gt; 映射器（mappers）123456&lt;!-- 使用相对于类路径的资源引用 --&gt;&lt;mappers&gt; &lt;mapper resource=\"org/mybatis/builder/AuthorMapper.xml\"/&gt; &lt;mapper resource=\"org/mybatis/builder/BlogMapper.xml\"/&gt; &lt;mapper resource=\"org/mybatis/builder/PostMapper.xml\"/&gt;&lt;/mappers&gt; 123456&lt;!-- 使用完全限定资源定位符（URL） --&gt;&lt;mappers&gt; &lt;mapper url=\"file:///var/mappers/AuthorMapper.xml\"/&gt; &lt;mapper url=\"file:///var/mappers/BlogMapper.xml\"/&gt; &lt;mapper url=\"file:///var/mappers/PostMapper.xml\"/&gt;&lt;/mappers&gt; 123456&lt;!-- 使用映射器接口实现类的完全限定类名 --&gt;&lt;mappers&gt; &lt;mapper class=\"org.mybatis.builder.AuthorMapper\"/&gt; &lt;mapper class=\"org.mybatis.builder.BlogMapper\"/&gt; &lt;mapper class=\"org.mybatis.builder.PostMapper\"/&gt;&lt;/mappers&gt; 1234&lt;!-- 将包内的映射器接口实现全部注册为映射器 --&gt;&lt;mappers&gt; &lt;package name=\"org.mybatis.builder\"/&gt;&lt;/mappers&gt; XML映射器 select标签 1234&lt;!--select标签用于查询数据库数据，其中id为映射接口对应的方法名，必须保持一致，parameterType为接收参数类型，resultType为返回查询结果的数据类型，#{id}用以获取传入参数数值--&gt;&lt;select id=\"selectPerson\" parameterType=\"int\" resultType=\"HashMap\"&gt; SELECT * FROM PERSON WHERE ID = #{id}&lt;/select&gt; 官方提供的select语句的标签属性： 123456789101112&lt;select id=\"selectPerson\" //命名空间中唯一标识符 parameterType=\"int\" //可选，传入参数的类全限定名或别名 parameterMap=\"deprecated\" //已废弃 resultType=\"hashmap\" //返回结果的类全限定名或别名 resultMap=\"personResultMap\" //对外部 resultMap 的命名引用，resultType 和 resultMap 之间只能同时使用一个 flushCache=\"false\" //是否清空本地缓存和二级缓存，默认为false useCache=\"true\" //是否启用二级缓存 timeout=\"10\" //在抛出异常之前，驱动程序等待数据库返回请求结果的秒数 fetchSize=\"256\" //让驱动程序每次批量返回的结果行数等于这个设置值 statementType=\"PREPARED\" //可选 STATEMENT，PREPARED 或 CALLABLE resultSetType=\"FORWARD_ONLY\" //FORWARD_ONLY，SCROLL_SENSITIVE, SCROLL_INSENSITIVE 或 DEFAULT（等价于 unset） 中的一个&gt; insert、update和delete 1234567891011121314151617&lt;insert id=\"insertAuthor\"&gt; insert into Author (id,username,password,email,bio) values (#{id},#{username},#{password},#{email},#{bio})&lt;/insert&gt;&lt;update id=\"updateAuthor\"&gt; update Author set username = #{username}, password = #{password}, email = #{email}, bio = #{bio} where id = #{id}&lt;/update&gt;&lt;delete id=\"deleteAuthor\"&gt; delete from Author where id = #{id}&lt;/delete&gt; 1234567891011121314151617181920212223&lt;insert id=\"insertAuthor\" parameterType=\"domain.blog.Author\" flushCache=\"true\" statementType=\"PREPARED\" keyProperty=\"\" //（仅适用于 insert 和 update）指定能够唯一识别对象的属性 keyColumn=\"\" //（仅适用于 insert 和 update）设置生成键值在表中的列名 useGeneratedKeys=\"\" //（仅适用于 insert 和 update）取出由数据库内部生成的主键 timeout=\"20\"&gt;&lt;update id=\"updateAuthor\" parameterType=\"domain.blog.Author\" flushCache=\"true\" statementType=\"PREPARED\" timeout=\"20\"&gt;&lt;delete id=\"deleteAuthor\" parameterType=\"domain.blog.Author\" flushCache=\"true\" statementType=\"PREPARED\" timeout=\"20\"&gt; 字符串替换 有时你就是想直接在 SQL 语句中直接插入一个不转义的字符串。 比如 ORDER BY 子句，这时候你可以： 1ORDER BY ${columnName} 当 SQL 语句中的元数据（如表名或列名）是动态生成的时候，字符串替换将会非常有用。举个例子，如果你想 select 一个表任意一列的数据时，不需要这样写： 12345678@Select(\"select * from user where id = #{id}\")User findById(@Param(\"id\") long id);@Select(\"select * from user where name = #{name}\")User findByName(@Param(\"name\") String name);@Select(\"select * from user where email = #{email}\")User findByEmail(@Param(\"email\") String email); 而是可以只写这样一个方法： 12@Select(\"select * from user where ${column} = #{value}\")User findByColumn(@Param(\"column\") String column, @Param(\"value\") String value); 其中 ${column} 会被直接替换，而 #{value} 会使用 ? 预处理。 这样，就能完成同样的任务： 123User userOfId1 = userMapper.findByColumn(\"id\", 1L);User userOfNameKid = userMapper.findByColumn(\"name\", \"kid\");User userOfEmail = userMapper.findByColumn(\"email\", \"noone@nowhere.com\");","link":"/2020/05/31/%E6%95%B0%E6%8D%AE%E5%BA%93/MyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"算法4笔记&#x2F;排序算法","text":"排序类算法模板12345678910111213141516171819202122232425262728293031public static void sort(Comparable[] a) { //排序内容}private static boolean less(Comparable v, Comparable w) { //比较两数大小，若v小于w，则返回true return v.compareTo(w) &lt; 0;}private static void exch(Comparable[] a, int i, int j) { //交换两元素位置 Comparable t = a[i]; a[i] = a[j]; a[j] = t;}private static void show(Comparable[] a) { // 在单行中打印数组 for (int i = 0; i &lt; a.length; i++) StdOut.print(a[i] + \" \"); StdOut.println();}public static boolean isSorted(Comparable[] a) { //测试数组元素是否有序 for (int i = 1; i &lt; a.length; i++) { if (less(a[i], a[i - 1])) return false; } return true;} 选择排序首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置（如果第一个元素就是最小元素那么它就和自己交换）。再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。这种方法叫做选择排序，因为它在不断地选择剩余元素之中的最小者。 对于长度为 N 的数组，选择排序需要大约$N^2/ 2 $次比较和 N 次交换。 123456789101112public class Selection { public static void sort(Comparable[] a) { // 将a[]按升序排列 int N = a.length; // 数组长度 for (int i = 0; i &lt; N; i++) { // 将a[i]和a[i+1..N]中最小的元素交换 int min = i; // 最小元素的索引 for (int j = i + 1; j &lt; N; j++) if (less(a[j], a[min])) min = j; exch(a, i, min); } } // less()、exch()、isSorted()和main()方法见“排序算法类模板”} 冒泡排序从左到右不断交换相邻逆序的元素，在一轮的循环之后，可以让未排序的最大元素上浮到右侧。在一轮循环中，如果没有发生交换，那么说明数组已经是有序的，此时可以直接退出。 123456789101112131415public class Bubble { public void sort(Comparable[] nums) { int N = nums.length; boolean isSorted = false; for (int i = N - 1; i &gt; 0 &amp;&amp; !isSorted; i--) { isSorted = true; for (int j = 0; j &lt; i; j++) { if (less(nums[j + 1], nums[j])) { isSorted = false; exch(nums, j, j + 1); } } } }} 插入排序每次都将当前元素插入到左侧已经排序的数组中，使得插入之后左侧数组依然有序。 对于随机排列的长度为 N 且主键不重复的数组，平均情况下插入排序需要$N^2 / 4$ 次比较以及$N^2 / 4$ 次交换。最坏情况下需要$N^2 / 2$ 次比较和$N^2 / 2$ 次交换，最好情况下需要 N-1次比较和 0 次交换。 12345678910public class Insertion { public static void sort(Comparable[] a) { // 将a[]按升序排列 int N = a.length; for (int i = 1; i &lt; N; i++) { // 将 a[i] 插入到 a[i-1]、a[i-2]、a[i-3]...之中 for (int j = i; j &gt; 0 &amp;&amp; less(a[j], a[j - 1]); j--) exch(a, j, j - 1); } } // less()、exch()、isSorted()和main()方法见“排序算法类模板”} 插入排序需要的交换操作和数组中倒置的数量相同，需要的比较次数大于等于倒置的数量，小于等于倒置的数量加上数组的大小再减一。 希尔排序希尔排序使用插入排序对间隔 h 的序列进行排序。通过不断减小 h，最后令 h=1，就可以使得整个数组是有序的。 123456789101112131415public class Shell { public static void sort(Comparable[] a) { // 将a[]按升序排列 int N = a.length; int h = 1; while (h &lt; N / 3) h = 3 * h + 1; // 1, 4, 13, 40, 121, 364, 1093, ... while (h &gt;= 1) { // 将数组变为h有序 for (int i = h; i &lt; N; i++) { // 将a[i]插入到a[i-h], a[i-2*h], a[i-3*h]... 之中 for (int j = i; j &gt;= h &amp;&amp; less(a[j], a[j - h]); j -= h) exch(a, j, j - h); } h = h / 3; } } // less()、exch()、isSorted()和main()方法见“排序算法类模板”} 希尔排序的运行时间达不到平方级别，使用递增序列 1, 4, 13, 40, … 的希尔排序所需要的比较次数不会超过 N 的若干倍乘于递增序列的长度。后面介绍的高级排序算法只会比希尔排序快两倍左右。 归并排序要将一个数组排序，可以先（递归地）将它分成两半分别排序，然后将结果归并起来。 归并排序最吸引人的性质是它能够保证将任意长度为 N 的数组排序所需时间和 NlogN 成正比；它的主要缺点则是它所需的额外空间和 N 成正比。 原地归并的抽象方法 merge(a, lo, mid, hi)，它会将子数组 a[lo..mid] 和 a[mid+1..hi] 归并成一个有序的数组并将结果存放在a[lo..hi] 中。 12345678910public static void merge(Comparable[] a, int lo, int mid, int hi) { // 将a[lo..mid] 和 a[mid+1..hi] 归并 int i = lo, j = mid + 1; for (int k = lo; k &lt;= hi; k++) // 将a[lo..hi]复制到aux[lo..hi] aux[k] = a[k]; for (int k = lo; k &lt;= hi; k++) // 归并回到a[lo..hi] if (i &gt; mid) a[k] = aux[j++]; else if (j &gt; hi) a[k] = aux[i++]; else if (less(aux[j], aux[i])) a[k] = aux[j++]; else a[k] = aux[i++];} 该方法先将所有元素复制到 aux[] 中，然后再归并回 a[] 中。方法在归并时（第二个 for 循环）进行了 4 个条件判断：左半边用尽（取右半边的元素）、右半边用尽（取左半边的元素）、右半边的当前元素小于左半边的当前元素（取右半边的元素）以及右半边的当前元素大于等于左半边的当前元素（取左半边的元素）。 自顶向下的归并排序 1234567891011121314151617public class Merge { private static Comparable[] aux; // 归并所需的辅助数组 public static void sort(Comparable[] a) { aux = new Comparable[a.length]; // 一次性分配空间 sort(a, 0, a.length - 1); } private static void sort(Comparable[] a, int lo, int hi) { // 将数组a[lo..hi]排序 if (hi &lt;= lo) return; int mid = lo + (hi - lo) / 2; // 防止数组太大越界 sort(a, lo, mid); // 将左半边排序 sort(a, mid + 1, hi); // 将右半边排序 merge(a, lo, mid, hi); // 归并结果（代码见“原地归并的抽象方法”） }} 对于长度为 N 的任意数组，自顶向下的归并排序需要 ½NlgN 至 NlgN 次比较。 对于长度为 N 的任意数组，自顶向下的归并排序最多需要访问数组 6NlgN 次。 自底向上的归并排序 实现归并排序的另一种方法是先归并那些微型数组，然后再成对归并得到的子数组，如此这般，直到我们将整个数组归并在一起。 123456789101112public class MergeBU { private static Comparable[] aux; // 归并所需的辅助数组 // merge()方法的代码请见“原地归并的抽象方法” public static void sort(Comparable[] a) { // 进行lgN次两两归并 int N = a.length; aux = new Comparable[N]; for (int sz = 1; sz &lt; N; sz = sz + sz) // sz子数组大小 for (int lo = 0; lo &lt; N - sz; lo += sz + sz) // lo:子数组索引 merge(a, lo, lo + sz - 1, Math.min(lo + sz + sz - 1, N - 1)); }} 对于长度为 N 的任意数组，自底向上的归并排序需要 1/2NlgN 至 NlgN 次比较，最多访问数组 6NlgN 次。 排序算法的复杂度 没有任何基于比较的算法能够保证使用少于 lg（N!）～ NlgN 次比较将长度为 N 的数组排序。 归并排序是一种渐进最优的基于比较排序的算法。 快速排序12345678910111213public class Quick { public static void sort(Comparable[] a) { StdRandom.shuffle(a); // 消除对输入的依赖 sort(a, 0, a.length - 1); } private static void sort(Comparable[] a, int lo, int hi) { if (hi &lt;= lo) return; int j = partition(a, lo, hi); // 切分（请见“快速排序的切分”） sort(a, lo, j - 1); // 将左半部分a[lo .. j-1]排序 sort(a, j + 1, hi); // 将右半部分a[j+1 .. hi]排序 }} 12345678910111213private static int partition(Comparable[] a, int lo, int hi) { // 将数组切分为a[lo..i-1], a[i], a[i+1..hi] int i = lo, j = hi + 1; // 左右扫描指针 Comparable v = a[lo]; // 切分元素 while (true) { // 扫描左右，检查扫描是否结束并交换元素 while (less(a[++i], v)) if (i == hi) break; while (less(v, a[--j])) if (j == lo) break; if (i &gt;= j) break; exch(a, i, j); } exch(a, lo, j); // 将v = a[j]放入正确的位置 return j; // a[lo..j-1] &lt;= a[j] &lt;= a[j+1..hi] 达成 } 将长度为 N 的无重复数组排序，快速排序平均需要 ~2NlnN 次比较（以及 1/6 的交换）。 快速排序最多需要约$N^2 / 2 $次比较，但随机打乱数组能够预防这种情况。 不存在任何基于比较的排序算法能够保证在 NH-N 次比较之内将 N 个元素排序，其中H 为由主键值出现频率定义的香农信息量。 对于大小为 N 的数组，三向切分的快速排序需要 ~(2ln2)NH 次比较。其中 H 为由主键值出现频率定义的香农信息量。 优先队列一个合适的数据结构应该支持两种操作：删除最大元素和插入元素。这种数据类型叫做优先队列。 堆排序数据结构二叉堆能够很好地实现优先队列的基本操作。在二叉堆的数组中，每个元素都要保证大于等于另两个特定位置的元素。 当一棵二叉树的每个结点都大于等于它的两个子结点时，它被称为堆有序。 根结点是堆有序的二叉树中的最大结点。 二叉堆是一组能够用堆有序的完全二叉树排序的元素，并在数组中按照层级储存（不使用数组的第一个位置）。 一棵大小为 N 的完全二叉树的高度为 $\\lfloor lgN \\rfloor$。 有关堆的相关操作 123456789101112131415161718192021222324252627282930313233343536private boolean less(int i, int j) { return pq[i].compareTo(pq[j]) &lt; 0;}private void exch(int i, int j) { Key t = pq[i]; pq[i] = pq[j]; pq[j] = t;}//上浮操作private void swim(int k) { while (k &gt; 1 &amp;&amp; less(k / 2, k)) { exch(k / 2, k); k = k / 2; }}//下沉操作private void sink(int k) { // 当该节点的左子节点小于元素个数时循环 while (2 * k &lt;= N) { // 将左子节点赋值给j int j = 2 * k; // 判断左右子节点大小，如果左子节点小于右子节点，j++ if (j &lt; N &amp;&amp; less(j, j + 1)) j++; // 若k的左子节点大于k的右子节点，则上面if不成立，k比左子节点小就下沉，否则跳出循环 if (!less(k, j)) break; // 若k左子节点大于右子节点且k小于左子节点，直接下沉 // 若k左子节点小于右子节点，则第一个if成立，k和右子节点比较大小，满足条件则下沉 exch(k, j); k = j; } //这里不考虑左右子节点的大小排序问题（理论上说堆有序情况下左子节点应该小于右子节点），我们要做的只是下沉k节点即可} 对于一个含有N个元素的基于堆的优先队列，插入元素操作只需不超过（lgN+1）次比较，删除最大元素的操作需要不超过 2lgN 次比较。 在一个大小为 N 的索引优先队列中，插入元素（insert）、改变优先级（change）、删除（delete）和删除最小元素（remove the minimum）操作所需的比较次数和 logN 成正比。 用下沉操作由 N 个元素构造堆只需少于 2N 次比较以及少于 N 次交换。 堆排序 123456789public static void sort(Comparable[] a) { int N = a.length; for (int k = N / 2; k &gt;= 1; k--) sink(a, k, N); while (N &gt; 1) { exch(a, 1, N--); sink(a, 1, N); }} 将 N 个元素排序，堆排序只需少于（2NlgN +2N）次比较（以及一半次数的交换）。 快速排序是最快的通用排序算法。","link":"/2020/05/14/%E7%AE%97%E6%B3%954%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"title":"数据库&#x2F;数据库链接报错解决&#x2F;IDEA2019.2链接MySQL数据库以及问题解决","text":"使用IDEA链接MySQL 首先介绍一下我所使用的版本：IDEA Ultimate 2019.02、MySQL用的是5.7的版本 启动IDEA完成后，在View-&gt;ToolWindows中点击Database 在出现的Database界面中选择加号，点击你要链接的数据库，这里我选择MySQL 在Data Sources and Drivers中输入你数据库的基本信息，重要的是Host、Port、User以及Password这几项内容，填写完毕后点击Test Connection测试，如果出现绿色对勾则配置正确 在Drivers中选择MySQL，点击加号安装对应的Connector即可 如果报错你可不填写User和Password然后测试，在出现的对话框中填写信息，然后确定进行配置 配置完成后在Database界面就会出现你刚才的数据库信息，这时你可以查看MySQL中存储的表 配置完成后我们进行一个简单的测试来看看是否配置成功 需要去MySQL官网下载jar包，我这里下载的是mysql-connector-java-8.0.17最新的版本:官网下载链接) 在你的工程中创建lib文件夹，将解压缩的jar包导入 编写程序进行测试 1234567891011121314151617181920212223242526import org.junit.Test;import java.sql.Connection;import java.sql.Driver;import java.sql.SQLException;import java.util.Properties;public class JDBCTest { @Test public void testDriver() throws SQLException { //1.创建一个Driver实现类的对象 Driver driver = new com.mysql.cj.jdbc.Driver(); //2.准备链接数据库基本信息：url,user,password String url = \"jdbc:mysql://localhost:3306/myemployees\"; Properties info = new Properties(); info.put(\"user\", \"root\"); info.put(\"password\", \"3570\"); //3.调用Driver接口的connect(url,info)获取数据库链接 Connection connect = driver.connect(url, info); System.out.println(connect); } } 若能出现如图结果则证明链接成功 解决java.sql.SQLException问题 首次运行可能会出现时区不对的问题，具体报错如下The server time zone value ‘�й���׼ʱ��’ is unrecognized or represents more than one time zone. You must configure either the server or JDBC driver (via the serverTimezone configuration property) to use a more specifc time zone 解决方法就是重新设置时区信息 1234//修改mysql全局时区为北京时间set global time_zone = '+8:00'; 修改mysql全局时区为北京时间//修改当前会话时区set time_zone = '+8:00'; 这种方法有个缺陷，就是每次都需要进行上述修改，所以我们直接修改my.ini文件 找到MySQL数据目录C:\\ProgramData\\MySQL\\MySQL Server 8.0，修改my.ini配置文件，添加default-time-zone='+08:00'如下图所示，保存退出。 至此，关于IDEA链接MySQL配置过程全部结束","link":"/2020/05/31/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%93%BE%E6%8E%A5%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/IDEA2019.2%E9%93%BE%E6%8E%A5MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BB%A5%E5%8F%8A%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"},{"title":"数据库&#x2F;数据库链接报错解决&#x2F;JDBC踩坑集合","text":"JDBC向MySQL中添加字段时利用JUnit测试报错:java.lang.Exception: Method getConnection2() should be void，源码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import org.junit.Test;import java.io.InputStream;import java.sql.*;import java.util.Properties;public class JDBCTest { @Test public Connection getConnection2() throws Exception { Properties properties = new Properties(); InputStream in = this.getClass().getClassLoader().getResourceAsStream(\"JDBC.properties\"); properties.load(in); String driverClass = properties.getProperty(\"driver\"); String jdbcUrl = properties.getProperty(\"jdbcUrl\"); String user = properties.getProperty(\"user\"); String password = properties.getProperty(\"password\"); Class.forName(driverClass); return DriverManager.getConnection(jdbcUrl, user, password); } /** * 通过JDBC向指定的数据表中插入一条记录 */ @Test public void testStatement() throws Exception{ //1.获取数据库链接 Connection conn = getConnection2(); //2.准备插入的SQL语句 String sql = \"INSERT INTO customers(`Name`,Email,Birth) VALUES('xiaoming','456@sina.com','2001-1-2');\"; //3.执行插入 //(1)获取操作SQL语句的Statement对象：调用Connection的createStatement()方法来获取 Statement statement = conn.createStatement(); //(2)调用Statement对象的executeUpdate(sql)执行SQL语句进行插入 statement.executeUpdate(sql); //(3)关闭Statement对象 statement.close(); //4.关闭连接 conn.close(); }} 根据提示可以看到getConnection2()在测试单元里返回值必须是void，解决方法是注释掉getConnection2()方法上面的@Test语句 问题二：JDBC向表中添加字段时，使用中文出现乱码问题在Navicat中右键表选择设计表，在选项中修改表的默认字符集将默认的gb2321字符集改为utf8并保存然后在添加代码url中加入?useUnicode=true&amp;characterEncoding=utf8重新添加数据，显示正常","link":"/2020/05/27/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%93%BE%E6%8E%A5%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/JDBC%E8%B8%A9%E5%9D%91%E9%9B%86%E5%90%88/"},{"title":"数据库&#x2F;数据库链接报错解决&#x2F;DataGrip-serverTimezone报错解决","text":"在每次链接DataGrip时执行SQL语句都会报错，具体报错信息如下： 主要原因就是数据库时区设置错误，解决方法就是在你所在的数据库上右键，点击Properties，如图所示； 点击Advanced，将serverTimezone的Value设置为CST(中国标准时间)； 再次尝试执行SQL语句，执行成功。","link":"/2020/05/27/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%93%BE%E6%8E%A5%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/DataGrip-serverTimezone%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/"}],"tags":[{"name":"乱码","slug":"乱码","link":"/tags/%E4%B9%B1%E7%A0%81/"},{"name":"Maven","slug":"Maven","link":"/tags/Maven/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"JDK","slug":"JDK","link":"/tags/JDK/"},{"name":"Tomcat","slug":"Tomcat","link":"/tags/Tomcat/"},{"name":"Nginx","slug":"Nginx","link":"/tags/Nginx/"},{"name":"配置静态IP","slug":"配置静态IP","link":"/tags/%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP/"},{"name":"刷题笔记","slug":"刷题笔记","link":"/tags/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"},{"name":"热部署","slug":"热部署","link":"/tags/%E7%83%AD%E9%83%A8%E7%BD%B2/"},{"name":"SSM整合","slug":"SSM整合","link":"/tags/SSM%E6%95%B4%E5%90%88/"},{"name":"最小二乘分类","slug":"最小二乘分类","link":"/tags/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E5%88%86%E7%B1%BB/"},{"name":"最小二乘法","slug":"最小二乘法","link":"/tags/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95/"},{"name":"集成分类","slug":"集成分类","link":"/tags/%E9%9B%86%E6%88%90%E5%88%86%E7%B1%BB/"},{"name":"学习模型","slug":"学习模型","link":"/tags/%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B/"},{"name":"稀疏学习","slug":"稀疏学习","link":"/tags/%E7%A8%80%E7%96%8F%E5%AD%A6%E4%B9%A0/"},{"name":"支持向量机","slug":"支持向量机","link":"/tags/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"},{"name":"鲁棒学习","slug":"鲁棒学习","link":"/tags/%E9%B2%81%E6%A3%92%E5%AD%A6%E4%B9%A0/"},{"name":"序列分类","slug":"序列分类","link":"/tags/%E5%BA%8F%E5%88%97%E5%88%86%E7%B1%BB/"},{"name":"监督降维","slug":"监督降维","link":"/tags/%E7%9B%91%E7%9D%A3%E9%99%8D%E7%BB%B4/"},{"name":"无监督降维","slug":"无监督降维","link":"/tags/%E6%97%A0%E7%9B%91%E7%9D%A3%E9%99%8D%E7%BB%B4/"},{"name":"多任务学习","slug":"多任务学习","link":"/tags/%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%AD%A6%E4%B9%A0/"},{"name":"在线学习","slug":"在线学习","link":"/tags/%E5%9C%A8%E7%BA%BF%E5%AD%A6%E4%B9%A0/"},{"name":"异常检测","slug":"异常检测","link":"/tags/%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B/"},{"name":"迁移学习","slug":"迁移学习","link":"/tags/%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0/"},{"name":"概率分类法","slug":"概率分类法","link":"/tags/%E6%A6%82%E7%8E%87%E5%88%86%E7%B1%BB%E6%B3%95/"},{"name":"带约束","slug":"带约束","link":"/tags/%E5%B8%A6%E7%BA%A6%E6%9D%9F/"},{"name":"本地方法栈","slug":"本地方法栈","link":"/tags/%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88/"},{"name":"半监督学习","slug":"半监督学习","link":"/tags/%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/"},{"name":"运行时数据区概述及线程","slug":"运行时数据区概述及线程","link":"/tags/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%BA%BF%E7%A8%8B/"},{"name":"JVM与Java体系结构","slug":"JVM与Java体系结构","link":"/tags/JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"},{"name":"聚类","slug":"聚类","link":"/tags/%E8%81%9A%E7%B1%BB/"},{"name":"方法区","slug":"方法区","link":"/tags/%E6%96%B9%E6%B3%95%E5%8C%BA/"},{"name":"类的加载过程详解","slug":"类的加载过程详解","link":"/tags/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/"},{"name":"再谈类的加载器","slug":"再谈类的加载器","link":"/tags/%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/"},{"name":"本地方法将接口","slug":"本地方法将接口","link":"/tags/%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E5%B0%86%E6%8E%A5%E5%8F%A3/"},{"name":"类加载子系统","slug":"类加载子系统","link":"/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/"},{"name":"直接内存","slug":"直接内存","link":"/tags/%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98/"},{"name":"堆","slug":"堆","link":"/tags/%E5%A0%86/"},{"name":"虚拟机栈","slug":"虚拟机栈","link":"/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/"},{"name":"StringTable","slug":"StringTable","link":"/tags/StringTable/"},{"name":"字节码指令集与解析举例","slug":"字节码指令集与解析举例","link":"/tags/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/"},{"name":"执行引擎","slug":"执行引擎","link":"/tags/%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/"},{"name":"垃圾回收相关算法","slug":"垃圾回收相关算法","link":"/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/"},{"name":"垃圾回收概述","slug":"垃圾回收概述","link":"/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0/"},{"name":"对象实例化内存布局与访问定位","slug":"对象实例化内存布局与访问定位","link":"/tags/%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/"},{"name":"垃圾回收相关概念","slug":"垃圾回收相关概念","link":"/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"name":"垃圾回收器","slug":"垃圾回收器","link":"/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"},{"name":"程序计数器","slug":"程序计数器","link":"/tags/%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/"},{"name":"Class文件结构","slug":"Class文件结构","link":"/tags/Class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"},{"name":"MyBatis官方文档学习笔记","slug":"MyBatis官方文档学习笔记","link":"/tags/MyBatis%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"排序算法","slug":"排序算法","link":"/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"name":"JDBC","slug":"JDBC","link":"/tags/JDBC/"}],"categories":[{"name":"并发编程","slug":"并发编程","link":"/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"name":"服务器","slug":"服务器","link":"/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"设计模式","slug":"并发编程/设计模式","link":"/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Tomcat","slug":"服务器/Tomcat","link":"/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/Tomcat/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"安装Oracle JDK","slug":"Linux/安装Oracle-JDK","link":"/categories/Linux/%E5%AE%89%E8%A3%85Oracle-JDK/"},{"name":"安装Maven","slug":"Linux/安装Maven","link":"/categories/Linux/%E5%AE%89%E8%A3%85Maven/"},{"name":"安装Tomcat","slug":"Linux/安装Tomcat","link":"/categories/Linux/%E5%AE%89%E8%A3%85Tomcat/"},{"name":"Nginx安装","slug":"Linux/Nginx安装","link":"/categories/Linux/Nginx%E5%AE%89%E8%A3%85/"},{"name":"Git安装","slug":"Linux/Git安装","link":"/categories/Linux/Git%E5%AE%89%E8%A3%85/"},{"name":"虚拟机配置","slug":"Linux/虚拟机配置","link":"/categories/Linux/%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%85%8D%E7%BD%AE/"},{"name":"MySQL安装","slug":"Linux/MySQL安装","link":"/categories/Linux/MySQL%E5%AE%89%E8%A3%85/"},{"name":"LeetCode","slug":"LeetCode","link":"/categories/LeetCode/"},{"name":"Docker","slug":"Docker","link":"/categories/Docker/"},{"name":"IDEA使用技巧","slug":"IDEA使用技巧","link":"/categories/IDEA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"name":"Spring框架","slug":"Spring框架","link":"/categories/Spring%E6%A1%86%E6%9E%B6/"},{"name":"机器学习","slug":"机器学习","link":"/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"项目热部署","slug":"IDEA使用技巧/项目热部署","link":"/categories/IDEA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/%E9%A1%B9%E7%9B%AE%E7%83%AD%E9%83%A8%E7%BD%B2/"},{"name":"SSM整合","slug":"Spring框架/SSM整合","link":"/categories/Spring%E6%A1%86%E6%9E%B6/SSM%E6%95%B4%E5%90%88/"},{"name":"图解机器学习笔记","slug":"机器学习/图解机器学习笔记","link":"/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%9B%BE%E8%A7%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Java虚拟机","slug":"Java虚拟机","link":"/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"Java框架","slug":"Java框架","link":"/categories/Java%E6%A1%86%E6%9E%B6/"},{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"},{"name":"MyBatis","slug":"Java框架/MyBatis","link":"/categories/Java%E6%A1%86%E6%9E%B6/MyBatis/"},{"name":"算法4笔记","slug":"Algorithm/算法4笔记","link":"/categories/Algorithm/%E7%AE%97%E6%B3%954%E7%AC%94%E8%AE%B0/"},{"name":"数据库","slug":"数据库","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL","slug":"数据库/MySQL","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"}]}